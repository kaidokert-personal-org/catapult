<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<script src="/bower_components/webcomponentsjs/webcomponents-loader.js"></script>
<script src="/bower_components/web-component-tester/browser.js"></script>

<link rel="import" href="/dashboard/spa/result-channel-receiver.html">

<script type="module" src="/dashboard/spa/result-channel-sender.js"></script>
<script type="module">
'use strict';
import ResultChannelSender from './result-channel-sender.js';

suite('ResultChannelReceiver', function() {
  test('receives_two_queued_messages', async() => {
    const url = 'receives_two_queued_messages';
    const sender = new ResultChannelSender(url);
    const receiver = new cp.ResultChannelReceiver(url);
    sender.send((async function* () {
      yield 'foo';
      yield 'bar';
    })());

    // Start the receiver after the sender has sent its messages.
    // The receiver should queue all messages until the caller is ready for
    // them.
    const results = [];
    for await (const result of receiver) {
      results.push(result);
    }
    assert.deepEqual(results, ['foo', 'bar']);
  });

  test('receives_two_delayed_messages', async() => {
    const url = 'receives_two_delayed_messages';
    const sender = new ResultChannelSender(url);
    const receiver = new cp.ResultChannelReceiver(url);

    // Start the receiver before the sender has sent any messages.
    // The receiver should block until the sender sends messages.
    const results = [];
    const receiverDone = (async() => {
      for await (const result of receiver) {
        results.push(result);
      }
    })();

    sender.send((async function* () {
      yield 'foo';
      yield 'bar';
    })());

    await receiverDone;
    assert.deepEqual(results, ['foo', 'bar']);
  });

  test('receives_one_queued_message_and_one_delayed_message', async() => {
    const url = 'receives_one_queued_message_and_one_delayed_message';
    const receiver = new cp.ResultChannelReceiver(url);
    const sender = new ResultChannelSender(url);

    let resolveDelay;
    sender.send((async function* () {
      yield 'foo';
      await new Promise(resolve => {
        resolveDelay = resolve;
      });
      yield 'bar';
    })());

    // Start the receiver after the sender has sent one message but before it
    // has sent the second.
    // The receiver should yield the first message immediately, then block until
    // the second message is sent.
    const results = [];
    let resolveFirst;
    const receivedFirst = new Promise(resolve => {
      resolveFirst = resolve;
    });
    const receiverDone = (async() => {
      for await (const result of receiver) {
        results.push(result);
        resolveFirst();
      }
    })();

    await receivedFirst;
    assert.deepEqual(results, ['foo']);

    resolveDelay();
    await receiverDone;
    assert.deepEqual(results, ['foo', 'bar']);
  });
});
</script>
