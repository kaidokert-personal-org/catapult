<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<script src="/bower_components/webcomponentsjs/webcomponents-loader.js"></script>
<script src="/bower_components/web-component-tester/browser.js"></script>
<link rel="import" href="/dashboard/spa/simple-redux.html">
<link rel="import" href="/dashboard/spa/timeseries-cache.html">

<script type="module" src="/dashboard/spa/sw-utils/cache-request-base.js"></script>
<script type="module" src="/dashboard/spa/sw-utils/timeseries-cache-request.js"></script>
<script type="module">
'use strict';
import cacheRequest from './cache-request-base.js';
import TimeseriesCacheRequest from './timeseries-cache-request.js';

global.testUtils = cacheRequest;
global.TimeseriesCacheRequest = TimeseriesCacheRequest;
</script>

<script>
'use strict';
suite('TimeseriesCacheRequest', function() {
  /**
   * mockRequest returns a `Request`[1] object mimicking a typical request to
   * the "/api/timeseries2" endpoint. The request is later used by `fetch`.
   * [1]: https://developer.mozilla.org/en-US/docs/Web/API/Request
   *
   *   type options = {
   *     testSuite: string,
   *     measurement: string,
   *     bot: string,
   *     statistic: string,
   *     levelOfDetail: LEVEL_OF_DETAIL,
   *     testCase?: string,
   *     buildType?: string,
   *     minRevision?: number,
   *     maxRevision?: number,
   *   }
   */
  function mockRequest(options) {
    return new Request(new cp.TimeseriesRequest(options).url_);
  }

  /**
   * mockApiResponse differs from cp.RequestBase#localhostResponse_ by
   * being simpler, predictable, and tunable.
   *
   * levelOfDetail: string,
   * minRevision?: number,
   * maxRevision?: number,
   */
  function mockApiResponse({levelOfDetail, minRevision = 1, maxRevision = 3}) {
    const columns = cp.getColumnsByLevelOfDetail(levelOfDetail, 'avg');
    const data = [];
    for (let i = minRevision; i <= maxRevision; ++i) {
      const dataPoint = [];
      for (const _ of columns) {
        dataPoint.push(i);
      }
      data.push(dataPoint);
    }
    return {
      improvement_direction: 1,
      units: 'sizeInBytes_smallerIsBetter',
      data,
    };
  }

  function mockFetch(response) {
    global.fetch = async() => {
      await cp.timeout(30);
      return testUtils.jsonResponse(response);
    };
  }

  test('mockFetch', async() => {
    const req = mockRequest({
      testSuite: 'testSuite',
      measurement: 'measurement',
      bot: 'bot',
      statistic: 'statistic',
      levelOfDetail: cp.LEVEL_OF_DETAIL.XY,
    });
    mockFetch({
      improvement_direction: 1,
      data: [
        [1, 1],
        [2, 2],
        [3, 3],
      ],
      units: 'sizeInBytes_smallerIsBetter',
    });
    const res = await fetch(req);
    const json = await res.json();
    assert.deepEqual(json, {
      improvement_direction: 1,
      data: [
        [1, 1],
        [2, 2],
        [3, 3],
      ],
      units: 'sizeInBytes_smallerIsBetter',
    });
  });

  test('mockResponse', async() => {
    const response = mockApiResponse({
      levelOfDetail: cp.LEVEL_OF_DETAIL.XY,
      minRevision: 1,
      maxRevision: 3
    });
    assert.deepEqual(response, {
      improvement_direction: 1,
      data: [
        [1, 1, 1, 1],
        [2, 2, 2, 2],
        [3, 3, 3, 3],
      ],
      units: 'sizeInBytes_smallerIsBetter',
    });
  });

  test('yields_only_network', async() => {
    const parameters = {
      testSuite: 'testSuite',
      measurement: 'measurement',
      bot: 'bot',
      statistic: 'avg',
      levelOfDetail: cp.LEVEL_OF_DETAIL.XY,
    };

    const databaseName = TimeseriesCacheRequest.databaseName(parameters);
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(databaseName);

    const response = mockApiResponse(parameters);
    mockFetch(response);

    const request = mockRequest(parameters);
    const race = new TimeseriesCacheRequest({request});
    const results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 1);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.deepEqual(results[0], response);
  });

  test('handles_same_ranges', async() => {
    const parameters = {
      testSuite: 'testSuite',
      measurement: 'measurement',
      bot: 'bot',
      statistic: 'avg',
      levelOfDetail: cp.LEVEL_OF_DETAIL.XY,
    };

    const databaseName = TimeseriesCacheRequest.databaseName(parameters);
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(databaseName);

    const request = mockRequest(parameters);
    let response = mockApiResponse(parameters);
    mockFetch(response);

    let race = new TimeseriesCacheRequest({request});
    let results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }
    assert.lengthOf(results, 1);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.deepEqual(results[0], response);

    await testUtils.flushWriterForTest();
    response = mockApiResponse(parameters);
    mockFetch(response);

    race = new TimeseriesCacheRequest({request});
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 3);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.include(results, response);
  });

  test('handles_separate_ranges', async() => {
    const parameters = {
      testSuite: 'testSuite',
      measurement: 'measurement',
      bot: 'bot',
      statistic: 'avg',
      levelOfDetail: cp.LEVEL_OF_DETAIL.XY,
      minRevision: 1,
      maxRevision: 3,
    };

    const databaseName = TimeseriesCacheRequest.databaseName(parameters);
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(databaseName);

    let request = mockRequest(parameters);
    let response = mockApiResponse(parameters);
    mockFetch(response);

    let race = new TimeseriesCacheRequest({request});
    let results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }
    assert.lengthOf(results, 1);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.deepEqual(results[0], response);

    await testUtils.flushWriterForTest();
    parameters.minRevision = 4;
    parameters.maxRevision = 7;
    request = mockRequest(parameters);
    response = mockApiResponse(parameters);

    mockFetch(response);

    race = new TimeseriesCacheRequest({request});
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Only results from the network should be returned since the previous range
    // was [1, 3] and the current range is [4, 7].
    assert.lengthOf(results, 1);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.deepEqual(results[0], response);
  });

  test('handles_overlapping_ranges', async() => {
    const parameters = {
      testSuite: 'testSuite',
      measurement: 'measurement',
      bot: 'bot',
      statistic: 'avg',
      levelOfDetail: cp.LEVEL_OF_DETAIL.XY,
      minRevision: 1,
      maxRevision: 3,
    };

    const databaseName = TimeseriesCacheRequest.databaseName(parameters);
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(databaseName);

    let request = mockRequest(parameters);
    let response = mockApiResponse(parameters);
    mockFetch(response);

    let race = new TimeseriesCacheRequest({request});
    let results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 1);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.deepEqual(results[0], response);

    parameters.minRevision = 2;
    parameters.maxRevision = 4;
    request = mockRequest(parameters);
    response = mockApiResponse(parameters);
    mockFetch(response);

    await testUtils.flushWriterForTest();
    race = new TimeseriesCacheRequest({request});
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Results from the cache and network should be returned since the previous
    // range [1, 3] intersects with the current range [2, 4].
    parameters.minRevision = 2;
    parameters.maxRevision = 3;
    const cacheResponse = mockApiResponse(parameters);
    cacheResponse.data = cacheResponse.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));

    assert.lengthOf(results, 2);
    assert.include(results, cacheResponse);
    assert.include(results, response);
  });

  test('handles_multiple_separate_ranges', async() => {
    // Start a request with the first data point
    const parameters = {
      testSuite: 'testSuite',
      measurement: 'measurement',
      bot: 'bot',
      statistic: 'avg',
      levelOfDetail: cp.LEVEL_OF_DETAIL.XY,
      minRevision: 1,
      maxRevision: 1,
    };

    const databaseName = TimeseriesCacheRequest.databaseName(parameters);
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(databaseName);

    let request = mockRequest(parameters);
    let response = mockApiResponse(parameters);
    mockFetch(response);

    let race = new TimeseriesCacheRequest({request});
    let results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 1);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.deepEqual(results[0], response);

    parameters.minRevision = 3;
    parameters.maxRevision = 3;
    request = mockRequest(parameters);
    response = mockApiResponse(parameters);
    mockFetch(response);

    await testUtils.flushWriterForTest();
    race = new TimeseriesCacheRequest({request});
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 1);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.deepEqual(results[0], response);

    parameters.minRevision = 2;
    parameters.maxRevision = 2;
    request = mockRequest(parameters);
    response = mockApiResponse(parameters);
    mockFetch(response);

    await testUtils.flushWriterForTest();
    race = new TimeseriesCacheRequest({request});
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 1);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.deepEqual(results[0], response);

    parameters.minRevision = 1;
    parameters.maxRevision = 3;
    request = mockRequest(parameters);
    response = mockApiResponse(parameters);
    mockFetch(response);

    await testUtils.flushWriterForTest();
    race = new TimeseriesCacheRequest({request});
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 2);
    response.data = response.data.map(d => cp.normalize(
        [...cp.getColumnsByLevelOfDetail(cp.LEVEL_OF_DETAIL.XY, 'avg')], d));
    assert.include(results, response);
  });
});
</script>
