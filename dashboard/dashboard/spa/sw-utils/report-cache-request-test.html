<!DOCTYPE html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/core/test_utils.html">
<script type="module" src="/dashboard/spa/sw-utils/cache-request-base.js"></script>
<script type="module" src="/dashboard/spa/sw-utils/report-cache-request.js"></script>
<script type="module">
'use strict';
import cacheRequest from './cache-request-base.js';
import ReportCacheRequest from './report-cache-request.js';

global.testUtils = cacheRequest;
global.ReportCacheRequest = ReportCacheRequest;
</script>

<script>
'use strict';

class ReportMock {
  /*
   * type options = {
   *   id: number,
   *   name: string,
   *   modified: Date,
   *   revisions: [number|"latest"],
   *   editable?: boolean,
   *   internal?: boolean,
   *   owners?: [string],
   * }
   */
  constructor(options) {
    this._options = options;
  }

  update(newOptions) {
    this._options = {
      ...this._options,
      ...newOptions,
    };
  }

  get _url() {
    return '/api/report/generate';
  }

  get databaseName() {
    return `report/${this._options.id}`;
  }

  get request() {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(this._options)) {
      if (value instanceof Date) {
        params.set(key, value.getTime());
      } else if (typeof value !== 'undefined') {
        params.set(key, value);
      }
    }

    return new Request(`${this._url}?${params}`);
  }

  get response() {
    const {
      id,
      name,
      revisions,
      editable = false,
      internal = false,
      owners = ['a@google.com', 'b@google.com', 'c@google.com'],
    } = this._options;

    const rows = [];
    for (const group of ['Pixel', 'Android Go']) {
      rows.push({
        ...this._generateRow('memory:a_size', 1),
        label: group + ':Memory',
        units: 'sizeInBytes_smallerIsBetter',
      });
      rows.push({
        ...this._generateRow('loading', 2),
        label: group + ':Loading',
        units: 'ms_smallerIsBetter',
      });
      rows.push({
        ...this._generateRow('startup', 3),
        label: group + ':Startup',
        units: 'ms_smallerIsBetter',
      });
      rows.push({
        ...this._generateRow('cpu:a', 4),
        label: group + ':CPU',
        units: 'ms_smallerIsBetter',
      });
      rows.push({
        ...this._generateRow('power', 5),
        label: group + ':Power',
        units: 'W_smallerIsBetter',
      });
    }

    return {
      editable,
      id,
      internal,
      name,
      owners,
      report: {
        rows,
        statistics: ['avg', 'std'],
      },
    };
  }

  _generateRow(measurement, seed) {
    const row = {
      testSuites: ['system_health.common_mobile'],
      bots: ['master:bot0', 'master:bot1', 'master:bot2'],
      testCases: [],
      data: {},
      measurement,
    };
    for (const revision of this._options.revisions) {
      row.data[revision] = {
        descriptors: [
          {
            testSuite: 'system_health.common_mobile',
            measurement,
            bot: 'master:bot0',
            testCase: 'search:portal:google',
          },
          {
            testSuite: 'system_health.common_mobile',
            measurement,
            bot: 'master:bot1',
            testCase: 'search:portal:google',
          },
        ],
        statistics: [10, 0, 0, seed * 1000, 0, 0, seed * 1000],
        revision,
      };
    }
    return row;
  }
}

const actualFetch = global.fetch;

function mockFetch(response, {
  delay = 50,
  status = 200,
} = {}) {
  global.fetch = () => new Promise((resolve, reject) => {
    setTimeout(() => {
      const blob = new Blob([JSON.stringify(response, null, 2)], {
        type: 'application/json',
      });
      const res = new Response(blob, { status });
      resolve(res);
    }, delay);
  });
}

tr.b.unittest.testSuite(() => {
  const testOptions = {
    setUp() {
      // Revoke access to fetch so tests can be more deterministic.
      mockFetch();
    },
    tearDown() {
      // Restore access to fetch after running tests.
      global.fetch = actualFetch;
    },
  };

  test('mock_fetch', async() => {
    mockFetch({ foo: 'bar' });
    const res = await fetch('www.google.com');
    const json = await res.json();
    assert.isObject(json);
    assert.deepEqual(json.foo, 'bar');
  }, testOptions);

  test('mock_response', async() => {
    const mock = new ReportMock({
      id: 123,
      name: 'name',
      modified: new Date(0),
      revisions: [1, 2, 3],
    });
    const { response } = mock;
    assert.isObject(response);
    assert.isBoolean(response.editable);
    assert.isNumber(response.id);
    assert.isBoolean(response.internal);
    assert.isString(response.name);
    assert.isArray(response.owners);
    for (const owner of response.owners) {
      assert.isString(owner);
    }
    assert.isObject(response.report);
    assert.isArray(response.report.rows);
    assert.isArray(response.report.statistics);
    for (const statistic of response.report.statistics) {
      assert.isString(statistic);
    }
  }, testOptions);

  test('it_exports', () => {
    assert.isTrue(typeof ReportCacheRequest.constructor === 'function');
    assert.isTrue(
        typeof testUtils.disableAutomaticWritingForTest === 'function'
    );
    assert.isTrue(typeof testUtils.deleteDatabaseForTest === 'function');
    assert.isTrue(typeof testUtils.flushWriterForTest === 'function');
  }, testOptions);

  // Results from the network should be yielded when there is no existing data
  // in the cache.
  test('it_yields_network', async() => {
    const mock = new ReportMock({
      id: 123,
      name: 'name',
      modified: new Date(0),
      revisions: [1, 2, 3],
    });
    testUtils.disableAutomaticWritingForTest();
    await testUtils.deleteDatabaseForTest(mock.databaseName);

    // Start a request
    mockFetch(mock.response);
    await testUtils.flushWriterForTest();
    const race = new ReportCacheRequest(mock.request);
    const results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 1, 'network contestant');
    assert.deepEqual(results[0], { name: 'Network', result: mock.response },
        'network returns response');
  }, testOptions);

  // After receiving results from the network, the cache will start yielding
  // results in addition to the network.
  test('it_yields_cache', async() => {
    const mock = new ReportMock({
      id: 123,
      name: 'name',
      modified: new Date(0),
      revisions: [1, 2, 3],
    });
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(mock.databaseName);

    // Start a request
    mockFetch(mock.response);
    let race = new ReportCacheRequest(mock.request);
    let results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    assert.lengthOf(results, 1, 'network contestant');
    assert.deepEqual(results[0], { name: 'Network', result: mock.response },
        'network returns response');

    // Write results to IndexedDB
    await testUtils.flushWriterForTest();

    // Start another request
    mockFetch(mock.response);
    race = new ReportCacheRequest(mock.request);
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Results of both IndexedDB and the network should be returned.
    assert.lengthOf(results, 2, 'cache and network contestants');

    // The order of results do not matter for this test.
    assert.include(results, { name: 'IndexedDB', result: mock.response },
        'cache returns response');
    assert.include(results, { name: 'Network', result: mock.response },
        'network returns response');
  }, testOptions);

  // When template ids change, the cache should not yield non-relevant data.
  test('it_yields_new_data_for_different_ids', async() => {
    const mock1 = new ReportMock({
      id: 123,
      name: 'name',
      modified: new Date(0),
      revisions: [1, 2, 3],
    });
    const mock2 = new ReportMock({
      id: 321,
      name: 'name',
      modified: new Date(0),
      revisions: [1, 2, 3],
    });
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(mock1.databaseName);
    await testUtils.deleteDatabaseForTest(mock2.databaseName);

    // Start a request
    mockFetch(mock1.response);
    let race = new ReportCacheRequest(mock1.request);
    let results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Only the result of the network should be returned
    assert.lengthOf(results, 1, 'network contestant');
    assert.deepEqual(results[0], { name: 'Network', result: mock1.response },
        'network returns response');

    await testUtils.flushWriterForTest();

    // Request a report with a different id.
    mockFetch(mock2.response);
    race = new ReportCacheRequest(mock2.request);
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Only results from the network should be returned since the revision range
    // is different.
    assert.lengthOf(results, 1, 'network contestant');
    assert.deepEqual(results[0], { name: 'Network', result: mock2.response },
        'network returns response');
  }, testOptions);

  // If the "modified" query parameter is changed, the database should be wiped
  // clear of any previous data.
  test('it_yields_new_data_for_different_modified_dates', async() => {
    const mock = new ReportMock({
      id: 12345,
      name: 'name',
      modified: new Date(0),
      revisions: [1, 2, 3],
    });
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(mock.databaseName);

    // Start a request
    mockFetch(mock.response);
    let race = new ReportCacheRequest(mock.request);
    let results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Only the result of the network should be returned
    assert.lengthOf(results, 1, 'network contestant');
    assert.deepEqual(results[0], { name: 'Network', result: mock.response },
        'network returns response');

    // Write results to IndexedDB
    await testUtils.flushWriterForTest();

    // Start another request with a modified date
    mock.update({
      modified: new Date(1),
    });
    mockFetch(mock.response);
    race = new ReportCacheRequest(mock.request);
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Only the result of the network should be returned
    assert.lengthOf(results, 1, 'network contestant');
    assert.deepEqual(results[0], { name: 'Network', result: mock.response },
        'network returns response');

    // Write results to IndexedDB
    await testUtils.flushWriterForTest();

    // Start the same request (with the same modified date)
    mockFetch(mock.response);
    race = new ReportCacheRequest(mock.request);
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Results of both IndexedDB and the network should be returned.
    assert.lengthOf(results, 2, 'cache and network contestants');

    // The order of results do not matter for this test.
    assert.include(results, { name: 'IndexedDB', result: mock.response },
        'cache returns response');
    assert.include(results, { name: 'Network', result: mock.response },
        'network returns response');
  }, testOptions);

  // When revisions change, the cache should not yield non-relevant data.
  test('it_yields_new_data_for_different_revisions', async() => {
    const mock = new ReportMock({
      id: 123,
      name: 'name',
      modified: new Date(0),
      revisions: [1, 2, 3],
    });
    testUtils.disableAutomaticWritingForTest();
    await testUtils.flushWriterForTest();
    await testUtils.deleteDatabaseForTest(mock.databaseName);

    // Start a request
    mockFetch(mock.response);
    let race = new ReportCacheRequest(mock.request);
    let results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Only the result of the network should be returned
    assert.lengthOf(results, 1, 'network contestant');
    assert.deepEqual(results[0], { name: 'Network', result: mock.response },
        'network returns response');

    await testUtils.flushWriterForTest();

    // Request a different revision range.
    mock.update({
      revisions: [4, 5, 6],
    });
    mockFetch(mock.response);
    race = new ReportCacheRequest(mock.request);
    results = [];
    for await (const contestant of race) {
      results.push(contestant);
    }

    // Only results from the network should be returned since the revision range
    // is different.
    assert.lengthOf(results, 1, 'network contestant');
    assert.deepEqual(results[0], { name: 'Network', result: mock.response },
        'network returns response');
  }, testOptions);
});

</script>
