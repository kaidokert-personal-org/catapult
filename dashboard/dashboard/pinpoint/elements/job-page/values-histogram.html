<!DOCTYPE html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<dom-module id="values-histogram">
  <template>
    <style>
      svg {
        height: 224px;
        margin-top: 16px;
        width: 100%;
      }

      g {
        height: 100%;
        width: 100%;
      }

      #bar_a {
        fill: #3F51B5;
      }

      #bar_b {
        fill: #FF4081;
      }
    </style>

    <svg id="plot">
      <g id="bar_a"></g>
      <g id="bar_b"></g>
    </svg>
  </template>

  <script>
    'use strict';
    Polymer({
      is: 'values-histogram',

      properties: {
        job: {
          type: Object,
          observer: '_jobChanged',
        },

        changeIndex: {
          type: Number,
          observer: '_changeIndexChanged',
        },
      },

      _jobChanged() {
        this.async(this.draw, 1);
      },

      _changeIndexChanged() {
        this.async(this.draw, 1);
      },

      draw() {
        if (!this.job) {
          return;
        }
        if (this.changeIndex === null) {
          return;
        }

        // Compute y scale.
        const valuesByChange = this.job.state.map(s => s.result_values);
        const allValues = [].concat(...valuesByChange);
        const y = d3.scaleLinear()
            .domain(d3.extent(allValues)).nice()
            .rangeRound([224, 0]);

        // Compute x scale. First, compute all the buckets, then scale all
        // numbers to the bucket with the largest frequency percentage.
        const histogram = d3.histogram()
            .domain(y.domain())
            .thresholds(y.ticks(20));
        const histograms = valuesByChange.map(values => bins(histogram, values));
        const maxBucket =
            d3.max(d3.merge(histograms), bucket => bucket.proportion);
        const x = d3.scaleLinear()
            .domain([0, maxBucket])
            .range([0, 100]);

        // Draw histograms.
        const histogramA = this.changeIndex ? histograms[this.changeIndex - 1] : [];
        const histogramB = histograms[this.changeIndex];
        d3.select(this.$.bar_a).call(drawHistogram, x, y, histogramA, false);
        d3.select(this.$.bar_b).call(drawHistogram, x, y, histogramB, true);

        // Update Polymer about changes.
        // TODO(dtu): This adds scope classes every time the histogram changes.
        // Remove this when we use native shadow dom.
        this.scopeSubtree(this.$.plot);
      }
    });

    function drawHistogram(svg, x, y, values, bottom) {
      const bar = svg.selectAll('rect')
          .data(values.filter(bin => bin.length));
      bar.enter().append('rect').merge(bar)
          .attr('width', d => x(d.proportion) + '%')
          .attr('y', d => {
            if (bottom) {
              return (y(d.x0) + y(d.x1)) / 2;
            }
            return y(d.x1);
          })
          .attr('height', d => (y(d.x0) - y(d.x1)) / 2);
      bar.exit().remove();
    }

    function bins(histogram, resultValues) {
      const bins = histogram(resultValues);
      for (const bin of bins) {
        bin.proportion = bin.length / resultValues.length;
      }
      return bins;
    }
  </script>
</dom-module>
