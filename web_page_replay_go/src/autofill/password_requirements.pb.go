// Code generated by protoc-gen-go. DO NOT EDIT.
// source: password_requirements.proto

package autofill

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Requirements for generating passwords.
type PasswordRequirementsSpec struct {
	// The priority of this specification.
	//
	// Autofill uses crowdsourcing to learn the requirements of passwords.
	// It is possible to manually override the requirements for an entire domain
	// or for a specific form. The priority field can be used to determine which
	// specification wins. If multiple specificaitons are available, the one with
	// the highest priority value wins. In that case all other specifications
	// are discarded (i.e. completely overridden as if they were never there).
	//
	// Values:
	// - 10 default for crowd sourced data.
	// - 20 for hard-coded overrides by domain.
	// - 30 for hard-coded overrides for a specific form.
	Priority *uint32 `protobuf:"varint,1,opt,name=priority" json:"priority,omitempty"`
	// A version number to allow older versions of Chrome to notice that they
	// don't understand a new revision of the requirements spec.
	SpecVersion *uint32 `protobuf:"varint,2,opt,name=spec_version,json=specVersion" json:"spec_version,omitempty"`
	// Minimum and maximum length of generated passwords for a site. Note that
	// these defaults may override the required minimum occurrences of character
	// classes if the two contradict.
	//
	// Defaults may change over time.
	MinLength *uint32 `protobuf:"varint,4,opt,name=min_length,json=minLength" json:"min_length,omitempty"`
	MaxLength *uint32 `protobuf:"varint,5,opt,name=max_length,json=maxLength" json:"max_length,omitempty"`
	// Default: character_set = [a-z], min = 1, max = MAX_INT32
	LowerCase *PasswordRequirementsSpec_CharacterClass `protobuf:"bytes,6,opt,name=lower_case,json=lowerCase" json:"lower_case,omitempty"`
	// Default: character_set = [A-Z], min = 1, max = MAX_INT32
	UpperCase *PasswordRequirementsSpec_CharacterClass `protobuf:"bytes,7,opt,name=upper_case,json=upperCase" json:"upper_case,omitempty"`
	// Alphabetic should not be used together with lower_case and upper_case.
	// This is just an option for sites that don't differentiate the cases.
	// If you wish to use alphabetic, you should set lower_case and upper_case
	// to min = max = 0.
	// Default: character_set = [a-zA-Z], min = 0, max = 0
	Alphabetic *PasswordRequirementsSpec_CharacterClass `protobuf:"bytes,8,opt,name=alphabetic" json:"alphabetic,omitempty"`
	// Default: character_set = [0-9], min = 1, max = MAX_INT32
	Numeric *PasswordRequirementsSpec_CharacterClass `protobuf:"bytes,9,opt,name=numeric" json:"numeric,omitempty"`
	// Default: character_set = some default that works often
	// (e.g. [!@#$%^&*()_-+=]) but the default value may change over time!),
	// min = 0, max = 0
	Symbols              *PasswordRequirementsSpec_CharacterClass `protobuf:"bytes,10,opt,name=symbols" json:"symbols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *PasswordRequirementsSpec) Reset()         { *m = PasswordRequirementsSpec{} }
func (m *PasswordRequirementsSpec) String() string { return proto.CompactTextString(m) }
func (*PasswordRequirementsSpec) ProtoMessage()    {}
func (*PasswordRequirementsSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4618d6f9b78b1a45, []int{0}
}

func (m *PasswordRequirementsSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PasswordRequirementsSpec.Unmarshal(m, b)
}
func (m *PasswordRequirementsSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PasswordRequirementsSpec.Marshal(b, m, deterministic)
}
func (m *PasswordRequirementsSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PasswordRequirementsSpec.Merge(m, src)
}
func (m *PasswordRequirementsSpec) XXX_Size() int {
	return xxx_messageInfo_PasswordRequirementsSpec.Size(m)
}
func (m *PasswordRequirementsSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PasswordRequirementsSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PasswordRequirementsSpec proto.InternalMessageInfo

func (m *PasswordRequirementsSpec) GetPriority() uint32 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *PasswordRequirementsSpec) GetSpecVersion() uint32 {
	if m != nil && m.SpecVersion != nil {
		return *m.SpecVersion
	}
	return 0
}

func (m *PasswordRequirementsSpec) GetMinLength() uint32 {
	if m != nil && m.MinLength != nil {
		return *m.MinLength
	}
	return 0
}

func (m *PasswordRequirementsSpec) GetMaxLength() uint32 {
	if m != nil && m.MaxLength != nil {
		return *m.MaxLength
	}
	return 0
}

func (m *PasswordRequirementsSpec) GetLowerCase() *PasswordRequirementsSpec_CharacterClass {
	if m != nil {
		return m.LowerCase
	}
	return nil
}

func (m *PasswordRequirementsSpec) GetUpperCase() *PasswordRequirementsSpec_CharacterClass {
	if m != nil {
		return m.UpperCase
	}
	return nil
}

func (m *PasswordRequirementsSpec) GetAlphabetic() *PasswordRequirementsSpec_CharacterClass {
	if m != nil {
		return m.Alphabetic
	}
	return nil
}

func (m *PasswordRequirementsSpec) GetNumeric() *PasswordRequirementsSpec_CharacterClass {
	if m != nil {
		return m.Numeric
	}
	return nil
}

func (m *PasswordRequirementsSpec) GetSymbols() *PasswordRequirementsSpec_CharacterClass {
	if m != nil {
		return m.Symbols
	}
	return nil
}

// A CharacterClass represents a type of characters (e.g. upper case,
// lower case, numbers, special symbols, ...).
//
// With min and max it is possible to specify the desired frequency:
// - Allowed: min = 0, max = MAX_INT32
// - Required: min = 1, max = MAX_INT32
// - Prohibited: min = 0, max = 0
//
// Note that character classes are meant to be handled independently of each
// other. Therefore, it is recommended not to set max > 0 for two overlapping
// character classes.
//
// It is also possible to express special rules like "at least two numbers"
// via min = 2, max = MAX_INT32, or "only numbers" by setting min = max = 0
// for all other character classes.
type PasswordRequirementsSpec_CharacterClass struct {
	// This is the pool of characters that make up the character set. For
	// brevity, some defaults are assumed given the name/identity of the
	// character class member (i.e., lower case vs upper case).
	// Anything in UTF-8 is deemed acceptable here.
	CharacterSet *string `protobuf:"bytes,1,opt,name=character_set,json=characterSet" json:"character_set,omitempty"`
	// Minimum number of characters from this class.
	Min *uint32 `protobuf:"varint,2,opt,name=min" json:"min,omitempty"`
	// Maximum number of characters from this class.
	Max                  *uint32  `protobuf:"varint,3,opt,name=max" json:"max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PasswordRequirementsSpec_CharacterClass) Reset() {
	*m = PasswordRequirementsSpec_CharacterClass{}
}
func (m *PasswordRequirementsSpec_CharacterClass) String() string { return proto.CompactTextString(m) }
func (*PasswordRequirementsSpec_CharacterClass) ProtoMessage()    {}
func (*PasswordRequirementsSpec_CharacterClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_4618d6f9b78b1a45, []int{0, 0}
}

func (m *PasswordRequirementsSpec_CharacterClass) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PasswordRequirementsSpec_CharacterClass.Unmarshal(m, b)
}
func (m *PasswordRequirementsSpec_CharacterClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PasswordRequirementsSpec_CharacterClass.Marshal(b, m, deterministic)
}
func (m *PasswordRequirementsSpec_CharacterClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PasswordRequirementsSpec_CharacterClass.Merge(m, src)
}
func (m *PasswordRequirementsSpec_CharacterClass) XXX_Size() int {
	return xxx_messageInfo_PasswordRequirementsSpec_CharacterClass.Size(m)
}
func (m *PasswordRequirementsSpec_CharacterClass) XXX_DiscardUnknown() {
	xxx_messageInfo_PasswordRequirementsSpec_CharacterClass.DiscardUnknown(m)
}

var xxx_messageInfo_PasswordRequirementsSpec_CharacterClass proto.InternalMessageInfo

func (m *PasswordRequirementsSpec_CharacterClass) GetCharacterSet() string {
	if m != nil && m.CharacterSet != nil {
		return *m.CharacterSet
	}
	return ""
}

func (m *PasswordRequirementsSpec_CharacterClass) GetMin() uint32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *PasswordRequirementsSpec_CharacterClass) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

func init() {
	proto.RegisterType((*PasswordRequirementsSpec)(nil), "autofill.PasswordRequirementsSpec")
	proto.RegisterType((*PasswordRequirementsSpec_CharacterClass)(nil), "autofill.PasswordRequirementsSpec.CharacterClass")
}

func init() { proto.RegisterFile("password_requirements.proto", fileDescriptor_4618d6f9b78b1a45) }

var fileDescriptor_4618d6f9b78b1a45 = []byte{
	// 305 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0xd2, 0x41, 0x4b, 0xc3, 0x30,
	0x14, 0x07, 0x70, 0xb6, 0x39, 0xb7, 0xbe, 0x6d, 0x22, 0x39, 0x85, 0x89, 0x30, 0xf5, 0xb2, 0x53,
	0x41, 0x3f, 0x82, 0xbb, 0x08, 0x7a, 0x98, 0x1d, 0x08, 0x9e, 0xca, 0x5b, 0x7c, 0xda, 0x40, 0xda,
	0xc4, 0x24, 0x75, 0xdd, 0xd9, 0x2f, 0x2e, 0x8d, 0xed, 0x98, 0x07, 0x2f, 0xbd, 0x25, 0xff, 0xff,
	0xe3, 0xc7, 0x3b, 0x3c, 0xb8, 0x30, 0xe8, 0xdc, 0x4e, 0xdb, 0xb7, 0xd4, 0xd2, 0x67, 0x29, 0x2d,
	0xe5, 0x54, 0x78, 0x17, 0x1b, 0xab, 0xbd, 0x66, 0x63, 0x2c, 0xbd, 0x7e, 0x97, 0x4a, 0x5d, 0x7f,
	0x0f, 0x81, 0xaf, 0x9b, 0xc9, 0xe4, 0x68, 0x70, 0x63, 0x48, 0xb0, 0x39, 0x8c, 0x8d, 0x95, 0xda,
	0x4a, 0xbf, 0xe7, 0xbd, 0x45, 0x6f, 0x39, 0x4b, 0x0e, 0x7f, 0x76, 0x05, 0x53, 0x67, 0x48, 0xa4,
	0x5f, 0x64, 0x9d, 0xd4, 0x05, 0xef, 0x87, 0x7e, 0x52, 0x67, 0x2f, 0xbf, 0x11, 0xbb, 0x04, 0xc8,
	0x65, 0x91, 0x2a, 0x2a, 0x3e, 0x7c, 0xc6, 0x4f, 0xc2, 0x40, 0x94, 0xcb, 0xe2, 0x29, 0x04, 0xa1,
	0xc6, 0xaa, 0xad, 0x87, 0x4d, 0x8d, 0x55, 0x53, 0xaf, 0x01, 0x94, 0xde, 0x91, 0x4d, 0x05, 0x3a,
	0xe2, 0xa7, 0x8b, 0xde, 0x72, 0x72, 0x77, 0x1b, 0xb7, 0x8b, 0xc7, 0xff, 0x2d, 0x1d, 0xaf, 0x32,
	0xb4, 0x28, 0x3c, 0xd9, 0x95, 0x42, 0xe7, 0x92, 0x28, 0x20, 0x2b, 0x74, 0x54, 0x8b, 0xa5, 0x31,
	0xad, 0x38, 0xea, 0x2c, 0x06, 0x24, 0x88, 0xcf, 0x00, 0xa8, 0x4c, 0x86, 0x5b, 0xf2, 0x52, 0xf0,
	0x71, 0x57, 0xf1, 0x08, 0x61, 0x8f, 0x30, 0x2a, 0xca, 0x9c, 0xac, 0x14, 0x3c, 0xea, 0xea, 0xb5,
	0x42, 0x8d, 0xb9, 0x7d, 0xbe, 0xd5, 0xca, 0x71, 0xe8, 0x8c, 0x35, 0xc2, 0xfc, 0x15, 0xce, 0xfe,
	0x56, 0xec, 0x06, 0x66, 0xa2, 0x4d, 0x52, 0x47, 0x3e, 0x1c, 0x49, 0x94, 0x4c, 0x0f, 0xe1, 0x86,
	0x3c, 0x3b, 0x87, 0x41, 0x2e, 0xdb, 0xfb, 0xa8, 0x9f, 0x21, 0xc1, 0x8a, 0x0f, 0x9a, 0x04, 0xab,
	0xfb, 0xfe, 0xc3, 0xe0, 0x27, 0x00, 0x00, 0xff, 0xff, 0x78, 0x0e, 0x73, 0xcc, 0xb1, 0x02, 0x00,
	0x00,
}
