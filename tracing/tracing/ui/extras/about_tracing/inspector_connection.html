<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/base.html">
<link rel="import" href="/tracing/base/base64.html">
<script>

'use strict';

/**
 * Contains connection code that inspector's embedding framework calls on
 * tracing, and that tracing can use to talk to inspector.
 */
tr.exportTo('tr.ui.e.about_tracing', function() {
  const Base64 = tr.b.Base64;

  // Interface used by inspector when it hands data to us from the backend.
  window.DevToolsAPI = {
    setToolbarColors() { },
    addExtensions() { },
    setInspectedPageId() { },

    dispatchMessage(payload) {
      throw new Error('Should have been patched by InspectorConnection');
    }
  };
  // Temporary until inspector backend switches to DevToolsAPI.
  window.InspectorFrontendAPI = window.DevToolsAPI;

  /**
   * @constructor
   */
  function InspectorConnection() {
    if (InspectorConnection.instance) {
      throw new Error('Singleton');
    }

    this.nextRequestId_ = 1;
    this.pendingRequestResolversId_ = {};

    this.notificationListenersByMethodName_ = {};
    DevToolsAPI.dispatchMessage = this.dispatchMessage_.bind(this);
  }

  InspectorConnection.prototype = {
    req(method, params) {
      const id = this.nextRequestId_++;
      const msg = JSON.stringify({
        id,
        method,
        params
      });
      const devtoolsMessageStr = JSON.stringify(
        {id, 'method': 'dispatchProtocolMessage', 'params': [msg]});
      DevToolsHost.sendMessageToEmbedder(devtoolsMessageStr);

      return new Promise(function(resolve, reject) {
        this.pendingRequestResolversId_[id] = {
          resolve,
          reject
        };
      }.bind(this));
    },

    setNotificationListener(method, listener) {
      this.notificationListenersByMethodName_[method] = listener;
    },

    dispatchMessage_(payload) {
      const isStringPayload = typeof payload === 'string';
      // Special handling for Tracing.dataCollected because it is high
      // bandwidth.
      const isDataCollectedMessage = isStringPayload ?
          payload.includes('"method": "Tracing.dataCollected"') :
          payload.method === 'Tracing.dataCollected';
      if (isDataCollectedMessage) {
        const listener = this.notificationListenersByMethodName_[
            'Tracing.dataCollected'];
        if (listener) {
          // FIXME(loislo): trace viewer should be able to process
          // raw message object because string based version a few times
          // slower on the browser side.
          // see https://codereview.chromium.org/784513002.
          listener(isStringPayload ? payload : JSON.stringify(payload));
          return;
        }
      }

      const message = isStringPayload ? JSON.parse(payload) : payload;
      if (message.id) {
        const resolver = this.pendingRequestResolversId_[message.id];
        if (resolver === undefined) {
          return;
        }
        if (message.error) {
          resolver.reject(message.error);
          return;
        }
        resolver.resolve(message.result);
        return;
      }

      if (message.method) {
        const listener = this.notificationListenersByMethodName_[
          message.method];
        if (listener === undefined) return;
        listener(message.params);
        return;
      }
    },

    rateLimit_(makeRequest, maxConcurrency) {
      function addRequest() {
        const request = makeRequest();
        if (request) {
          request.then(addRequest);
        }
      }

      for (let i = 0; i < maxConcurrency; ++i) {
        addRequest();
      }
    },

    readStream(stream) {
      return new Promise(function(resolve, reject) {
        const chunks = [];
        let done = false;
        let base64 = false;

        function onStreamComplete() {
          if (base64) {
            let totalSize = 0;
            chunks.forEach(
                function(entry) {
                  totalSize += Base64.getDecodedBufferLength(entry);
                });
            const buffer = new ArrayBuffer(totalSize);
            let offset = 0;
            chunks.forEach(
                function(entry) {
                  offset += Base64.DecodeToTypedArray(
                      entry,
                      new DataView(buffer, offset));
                });
            resolve(buffer);
          } else {
            resolve(chunks.join(''));
          }

          done = true;
        }

        function onReadComplete(params) {
          if (done) {
            return;
          }
          chunks.push(params.data);
          if (params.base64Encoded) {
            base64 = true;
          }
          if (params.eof) {
            onStreamComplete();
          }
        }

        function onReadFailed(error) {
          if (done) {
            return;
          }
          reject(error);
          done = true;
        }

        function makeReadRequest() {
          if (done) {
            return;
          }
          return this.req(
              'IO.read',
              {
                handle: stream,
                size: 32768,
              }).then(onReadComplete, onReadFailed);
        }

        this.rateLimit_(makeReadRequest.bind(this), 2);
      }.bind(this));
    },

    closeStream(stream) {
      this.req('IO.close', { handle: stream });
    }
  };

  if (window.DevToolsHost) {
    InspectorConnection.instance = new InspectorConnection();
  } else {
    InspectorConnection.instance = undefined;
  }

  return {
    InspectorConnection,
  };
});
</script>
