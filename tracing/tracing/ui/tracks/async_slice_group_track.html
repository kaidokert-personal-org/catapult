<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/ui/base/ui.html">
<link rel="import" href="/tracing/ui/tracks/multi_row_track.html">
<link rel="import" href="/tracing/ui/tracks/slice_track.html">

<script>
'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a AsyncSliceGroup.
   * @constructor
   * @extends {MultiRowTrack}
   */
  const AsyncSliceGroupTrack = tr.ui.b.define(
      'async-slice-group-track',
      tr.ui.tracks.MultiRowTrack);

  AsyncSliceGroupTrack.prototype = {

    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('async-slice-group-track');
      this.group_ = undefined;
    },

    addSubTrack_(slices, opt_heading) {
      const track = new tr.ui.tracks.SliceTrack(this.viewport);
      track.slices = slices;
      Polymer.dom(this).appendChild(track);
      track.asyncStyle = true;
      if (opt_heading !== undefined) {
        track.heading = opt_heading;
      }
      return track;
    },

    get group() {
      return this.group_;
    },

    set group(group) {
      this.group_ = group;
      this.setItemsToGroup(group.slices, group);
    },

    get eventContainer() {
      return this.group;
    },

    addContainersToTrackMap(containerToTrackMap) {
      tr.ui.tracks.MultiRowTrack.prototype.addContainersToTrackMap.apply(
          this, arguments);
      containerToTrackMap.addContainer(this.group, this);
    },

    buildSubRows_(slices, opt_headings) {
      // Group already contains slices passed here but provides
      // vital grouping information.
      if (this.group_.viewSubGroups.length !== 0) {
        const rows = [];
        const headings = [];

        for (const subGroup of this.group_.viewSubGroups) {
          // Only one nested level is allowed.
          const newRows = groupAsyncSlicesIntoSubRows(subGroup.slices);
          if (newRows.length === 0) {
            continue;
          }
          headings.push(subGroup.title);
          for (let i = 1; i < newRows.length; i++) {
            headings.push('');
          }
          rows.push(...newRows);
        }

        if (opt_headings !== undefined) {
          opt_headings.push(...headings);
        }
        return rows;
      }
      // No sub-groups here.
      return groupAsyncSlicesIntoSubRows(this.group_.slices);
    }
  };

  function makeRowsFromFitSlices_(slices) {
    const rows = [];
    const putSlice = (slice, level) => {
      while (rows.length <= level) {
        rows.push([]);
      }
      rows[level].push(slice);
    };
    const putSliceRecursively = (slice, level) => {
      putSlice(slice, level);
      if (slice.subSlices !== undefined) {
        for (const subSlice of slice.subSlices) {
          putSlice(subSlice, level + 1);
        }
      }
    };

    for (const slice of slices) {
      if (slice.subSlices !== undefined && slice.subSlices.length === 1) {
        const subSlice = slice.subSlices[0];
        if (tr.b.math.approximately(subSlice.start, slice.start, 1) &&
            tr.b.math.approximately(subSlice.duration, slice.duration, 1)) {
          subSlice.parentSlice = slice;
          putSliceRecursively(subSlice, 0);
          continue;
        }
      }
      putSliceRecursively(slice, 0);
    }
    return rows;
  }

  /**
   * Breaks up the list of slices into N rows, each of which is a list of
   * slices that are non overlapping.
   */
  function groupAsyncSlicesIntoSubRows(slices, opt_skipSort) {
    const rows = [];
    let slicesToPut = slices;

    if (!opt_skipSort) {
      slicesToPut.sort((x, y) => x.start - y.start);
    }

    while (slicesToPut.length !== 0) {
      const fit = [];
      const unfit = [];  // Slices left for next levels.
      let endTime = -1;

      for (const slice of slicesToPut) {
        if (slice.start >= endTime) {
          // Assuming nested slices lie within parent's boundaries.
          endTime = slice.end;
          fit.push(slice);
        } else {
          unfit.push(slice);
        }
      }

      rows.push(...makeRowsFromFitSlices_(fit));
      slicesToPut = unfit;
    }
    return rows;
  }

  return {
    AsyncSliceGroupTrack,
    groupAsyncSlicesIntoSubRows,
  };
});
</script>
