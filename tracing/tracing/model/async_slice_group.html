<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/guid.html">
<link rel="import" href="/tracing/base/math/range.html">
<link rel="import" href="/tracing/model/async_slice.html">
<link rel="import" href="/tracing/model/event_container.html">

<script>
'use strict';

/**
 * @fileoverview Provides the AsyncSliceGroup class.
 */
tr.exportTo('tr.model', function() {
  /**
   * Group of AsyncSlices associated with a thread or an upper-level
   * AsyncSliceGroup. Thread can have number of AsyncSliceGroups and these
   * groups can have nested groups too. No further nested levels are allowed.
   */
  class AsyncSliceGroup extends tr.model.EventContainer {

    /**
     * @param {String} opt_name Optional name (no IDs please) for settings key.
     */
    constructor(parentContainer, opt_name) {
      super();
      this.parentContainer_ = parentContainer;
      this.name_ = opt_name;
      this.slices = [];
      this.viewSubGroups_ = undefined;

      // Default values for the root group.
      // Nested groups will get these values reassigned.
      this.nested_level_ = 0;
      this.indivisible_ = false;
      this.title_ = undefined;
    }

    get parentContainer() {
      return this.parentContainer_;
    }

    get model() {
      return this.parentContainer_.parent.model;
    }

    get stableId() {
      return this.parentContainer_.stableId + '.AsyncSliceGroup';
    }

    get title() {
      // |this.title_| is undefined for root group. While the root group
      // arranges slices into sub-groups, ones get their titles.
      if (this.nested_level_ === 0) {
        return '<root>';
      }
      return this.title_;
    }

    getSettingsKey() {
      if (this.name_ === undefined) {
        return undefined;
      }
      const parentKey = this.parentContainer_.getSettingsKey();
      if (parentKey === undefined) {
        return undefined;
      }
      return parentKey + '.' + this.name_;
    }

    /**
     * Helper function that pushes the provided slice onto the slices array.
     */
    push(slice) {
      if (this.viewSubGroups_ !== undefined) {
        throw new Error(
            'No new slices are allowed when view sub-groups already formed.');
      }
      slice.parentContainer = this.parentContainer;
      this.slices.push(slice);
      return slice;
    }

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    }

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified, including all nested subSlices if there are any.
     */
    shiftTimestampsForward(amount) {
      for (const slice of this.childEvents()) {
        slice.start += amount;
      }
    }

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds() {
      this.bounds.reset();
      for (let i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    }

    /**
     * Closes any open slices.
     * All open slices assumed as finished at the end of model's time bounds.
     */
    autoCloseOpenSlices() {
      const maxTimestamp = this.parentContainer_.parent.model.bounds.max;
      for (const slice of this.childEvents()) {
        if (slice.didNotFinish) {
          slice.duration = maxTimestamp - slice.start;
        }
      }
    }

    /**
     * Get AsyncSlice sub-groups arranged by title or other UX rules.
     *
     * @return {Array} An array of AsyncSliceGroups where each group has
     * a title and sub-set of the original slices. Returns an empty array
     * if group can't be sub-divided.
     */
    get viewSubGroups() {
      // Only 2 nested levels are allowed (see class description).
      // Also it's always known in advance whether group will be sub-divided or
      // not (most of them). Root group is always divisible.
      if (this.indivisible_ || this.nested_level_ === 2) {
        return [];
      }
      if (this.viewSubGroups_ !== undefined) {
        return this.viewSubGroups_;
      }

      let namePrefix = '';
      if (this.name_ !== undefined) {
        namePrefix = this.name_ + '.';
      }
      const subGroupsByTitle = new Map();

      for (const slice of this.slices) {
        // Group by title by default.
        let name = namePrefix + slice.viewSubGroupTitle;
        let title = slice.viewSubGroupTitle;
        let indivisible = true;

        // TODO(kraynov): Delegate UX-defined grouping rules to extras modules,
        // like we have NetAsyncSlice. Leave default grouping by title as is.

        // Group WebFrameScheduler states by frames (using their pointers).
        if (this.nested_level_ === 0 &&
            title.startsWith('WebFrameScheduler')) {
          name = namePrefix + 'WebFrameTuple';
          title = 'WebFrame' + slice.id;
          indivisible = false;  // To be grouped by title on the next level.
        }

        let subGroup = subGroupsByTitle.get(title);
        if (subGroup === undefined) {
          subGroup = new AsyncSliceGroup(this.parentContainer_, name);
          subGroup.title_ = title;
          subGroup.indivisible_ = indivisible;
          subGroup.nested_level_ = this.nested_level_ + 1;
          subGroupsByTitle.set(title, subGroup);
        }
        subGroup.push(slice);
      }

      this.viewSubGroups_ = Array.from(subGroupsByTitle.values());
      this.viewSubGroups_.sort((a, b) => a.title.localeCompare(b.title));
      return this.viewSubGroups_;
    }

    * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
      for (const slice of this.slices) {
        if (slice.isTopLevel) {
          yield* slice.findTopmostSlicesRelativeToThisSlice(
              eventPredicate, opt_this);
        }
      }
    }

    * childEvents() {
      for (const slice of this.slices) {
        yield slice;
        yield* slice.enumerateAllDescendents();
      }
    }

    * childEventContainers() {
    }
  }

  return {
    AsyncSliceGroup,
  };
});
</script>
