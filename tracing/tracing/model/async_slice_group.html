<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/guid.html">
<link rel="import" href="/tracing/base/math/range.html">
<link rel="import" href="/tracing/model/async_slice.html">
<link rel="import" href="/tracing/model/event_container.html">

<script>
'use strict';

/**
 * @fileoverview Provides the AsyncSliceGroup class.
 */
tr.exportTo('tr.model', function() {
  /**
   * Group of AsyncSlices associated with a thread or an upper-level
   * AsyncSliceGroup. Thread can have number of AsyncSliceGroups and these
   * groups can have nested groups too. No further nested levels are allowed.
   */
  class AsyncSliceGroup extends tr.model.EventContainer {

    /**
     * @param {String} opt_name Optional name (no IDs please) for settings key.
     */
    constructor(parentContainer, opt_name) {
      super();
      this.parentContainer_ = parentContainer;
      this.slices = [];
      this.name_ = opt_name;
      this.nested_level_ = 0;
      this.title_ = undefined;
      this.viewSubGroups_ = undefined;
    }

    get parentContainer() {
      return this.parentContainer_;
    }

    get model() {
      return this.parentContainer_.parent.model;
    }

    get stableId() {
      return this.parentContainer_.stableId + '.AsyncSliceGroup';
    }

    get title() {
      if (this.nested_level_ === 0) {
        return '<root>';
      }
      return this.title_;
    }

    getSettingsKey() {
      if (this.name_ === undefined) {
        return undefined;
      }
      const parentKey = this.parentContainer_.getSettingsKey();
      if (parentKey === undefined) {
        return undefined;
      }
      return parentKey + '.' + this.name_;
    }

    /**
     * Helper function that pushes the provided slice onto the slices array.
     */
    push(slice) {
      slice.parentContainer = this.parentContainer;
      this.slices.push(slice);
      return slice;
    }

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    }

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified, including all nested subSlices if there are any.
     */
    shiftTimestampsForward(amount) {
      for (let sI = 0; sI < this.slices.length; sI++) {
        const slice = this.slices[sI];
        slice.start = (slice.start + amount);
        // Shift all nested subSlices recursively.
        const shiftSubSlices = function(subSlices) {
          if (subSlices === undefined || subSlices.length === 0) {
            return;
          }
          for (let sJ = 0; sJ < subSlices.length; sJ++) {
            subSlices[sJ].start += amount;
            shiftSubSlices(subSlices[sJ].subSlices);
          }
        };
        shiftSubSlices(slice.subSlices);
      }
    }

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds() {
      this.bounds.reset();
      for (let i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    }

    /**
     * Closes any open slices.
     * @param {Number=} opt_maxTimestamp The end time to use for the closed
     * slices. If not provided,
     * the max timestamp for this slice is provided.
     */
    autoCloseOpenSlices() {
      const maxTimestamp = this.parentContainer_.parent.model.bounds.max;
      function autoClose(slice) {
        slice.duration = maxTimestamp - slice.start;
        for (const subSlice of slice.subSlices) {
          autoClose(subSlice);
        }
      }

      for (const slice of this.slices) {
        if (slice.didNotFinish) {
          autoClose(slice);
        }
      }
    }

    /**
     * Get AsyncSlice sub-groups arranged by title or other UX rules.
     *
     * @return {Array} An array of AsyncSliceGroups where each group has
     * a title and sub-set or original slices. Returns an empty array
     * if group can't be sub-divided.
     */
    get viewSubGroups() {
      if (this.indivisible_ || this.nested_level_ === 2) {
        return [];
      }

      if (this.viewSubGroups_ === undefined) {
        let prefix = '';
        if (this.name_ !== undefined) {
          prefix = this.name_ + '.';
        }

        const subGroupsByTitle = {};
        for (const slice of this.slices) {
          // Group by title by default.
          let name = prefix + slice.viewSubGroupTitle;
          let title = slice.viewSubGroupTitle;
          let indivisible = true;

          // Group WebFrameScheduler states by frames (using their pointers).
          if (this.nested_level_ === 0 &&
              title.startsWith('WebFrameScheduler')) {
            name = prefix + 'WebFrameTuple';
            title = 'WebFrame' + slice.id;
            indivisible = false;  // To be grouped by title on the next level.
          }

          let subGroup;
          if (!subGroupsByTitle[title]) {
            subGroup = new AsyncSliceGroup(this.parentContainer_, name);
            subGroup.title_ = title;
            subGroup.indivisible_ = indivisible;
            subGroup.nested_level_ = this.nested_level_ + 1;
            subGroupsByTitle[title] = subGroup;
          } else {
            subGroup = subGroupsByTitle[title];
          }
          subGroup.push(slice);
        }

        this.viewSubGroups_ = Object.values(subGroupsByTitle);
        this.viewSubGroups_.sort(function(a, b) {
          return a.title.localeCompare(b.title);
        });
      }
      return this.viewSubGroups_;
    }

    * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
      for (const slice of this.slices) {
        if (slice.isTopLevel) {
          yield* slice.findTopmostSlicesRelativeToThisSlice(
              eventPredicate, opt_this);
        }
      }
    }

    * childEvents() {
      // Async slices normally don't have sub-slices, and when they do,
      // the sub-slice is specific to the type of async slice. Thus,
      // it is not expected for sub-slices to themselves have sub-sub-slices,
      // which is why we don't recurse into the sub-slices here.
      for (const slice of this.slices) {
        yield slice;
        if (slice.subSlices) {
          yield* slice.subSlices;
        }
      }
    }

    * childEventContainers() {
    }
  }

  return {
    AsyncSliceGroup,
  };
});
</script>
