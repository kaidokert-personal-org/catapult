<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/math/range.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/v8/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/value/diagnostics/breakdown.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.v8', function() {
  // The time window size for mutator utilization computation.
  // It is equal to the duration of one frame corresponding to 60 FPS rendering.
  const TARGET_FPS = 60;
  const MS_PER_SECOND = 1000;
  const WINDOW_SIZE_MS = MS_PER_SECOND / TARGET_FPS;
  const EPSILON = 1e-6;

  // Events that contribute to GC metric computation, grouped by GC phase type.
  // Both the main and background thread events should be listed together.

  const V8_FULL_ATOMIC_EVENTS = [
    'V8.GCCompactor',
    'V8.GCFinalizeMC',
    'V8.GCFinalizeMCReduceMemory',
  ];

  const V8_FULL_MARK_EVENTS = [
    'V8.GC_MC_BACKGROUND_MARKING',
    'V8.GC_MC_MARK',
    'V8.GCIncrementalMarking',
    'V8.GCIncrementalMarkingFinalize',
    'V8.GCIncrementalMarkingStart',
  ];

  const V8_FULL_COMPACT_EVENTS = [
    'V8.GC_MC_BACKGROUND_EVACUATE_COPY',
    'V8.GC_MC_BACKGROUND_EVACUATE_UPDATE_POINTERS',
    'V8.GC_MC_EVACUATE',
  ];

  const V8_FULL_SWEEP_EVENTS = [
    'V8.GC_MC_BACKGROUND_SWEEPING',
    'V8.GC_MC_SWEEP',
  ];

  const V8_FULL_WEAK_EVENTS = [
    'V8.GC_MC_CLEAR',
  ];

  const V8_YOUNG_EVENTS = [
    'V8.GC_SCAVENGER_BACKGROUND_SCAVENGE_PARALLEL',
    'V8.GCScavenger',
  ];

  const CPP_GC_FULL_MARK_EVENTS = [
    'BlinkGC.AtomicPauseMarkEpilogue',
    'BlinkGC.AtomicPauseMarkPrologue',
    'BlinkGC.AtomicPauseMarkRoots',
    'BlinkGC.AtomicPauseMarkTransitiveClosure',
    'BlinkGC.ConcurrentMarkingStep',
    'BlinkGC.IncrementalMarkingStartMarking',
    'BlinkGC.IncrementalMarkingStep',
    'BlinkGC.MarkBailOutObjects',
    'BlinkGC.MarkFlushEphemeronPairs',
    'BlinkGC.MarkFlushV8References',
    'BlinkGC.UnifiedMarkingStep',
  ];

  const CPP_GC_FULL_COMPACT_EVENTS = [
    'BlinkGC.AtomicPauseSweepAndCompact',
  ];

  const CPP_GC_FULL_SWEEP_EVENTS = [
    'BlinkGC.CompleteSweep',
    'BlinkGC.ConcurrentSweepingStep',
    'BlinkGC.LazySweepInIdle',
    'BlinkGC.LazySweepOnAllocation',
  ];

  // A list of metrics that to be computed and tracked.
  const METRICS = [
    'v8:gc:cycle:full',
    'v8:gc:cycle:full:cpp',
    'v8:gc:cycle:full:mark',
    'v8:gc:cycle:full:mark:cpp',
    'v8:gc:cycle:full:weak',
    'v8:gc:cycle:full:weak:cpp',
    'v8:gc:cycle:full:sweep',
    'v8:gc:cycle:full:sweep:cpp',
    'v8:gc:cycle:full:compact',
    'v8:gc:cycle:full:compact:cpp',
    'v8:gc:cycle:main_thread:full',
    'v8:gc:cycle:main_thread:full:cpp',
    'v8:gc:cycle:main_thread:full:mark',
    'v8:gc:cycle:main_thread:full:mark:cpp',
    'v8:gc:cycle:main_thread:full:weak',
    'v8:gc:cycle:main_thread:full:weak:cpp',
    'v8:gc:cycle:main_thread:full:sweep',
    'v8:gc:cycle:main_thread:full:sweep:cpp',
    'v8:gc:cycle:main_thread:full:compact',
    'v8:gc:cycle:main_thread:full:compact:cpp',
    'v8:gc:event:main_thread:full:atomic',
    'v8:gc:event:main_thread:full:atomic:cpp',
    'v8:gc:event:main_thread:full:atomic:mark',
    'v8:gc:event:main_thread:full:atomic:mark:cpp',
    'v8:gc:event:main_thread:full:atomic:weak',
    'v8:gc:event:main_thread:full:atomic:weak:cpp',
    'v8:gc:event:main_thread:full:atomic:sweep',
    'v8:gc:event:main_thread:full:atomic:sweep:cpp',
    'v8:gc:event:main_thread:full:atomic:compact',
    'v8:gc:event:main_thread:full:atomic:compact:cpp',
    'v8:gc:event:main_thread:full:incremental',
    'v8:gc:event:main_thread:full:incremental:cpp',
    'v8:gc:event:main_thread:full:incremental:mark',
    'v8:gc:event:main_thread:full:incremental:mark:cpp',
    'v8:gc:event:main_thread:full:incremental:sweep',
    'v8:gc:event:main_thread:full:incremental:sweep:cpp',
    'v8:gc:cycle:young',
    'v8:gc:cycle:main_thread:young',
  ];

  // Rules that map events to the corresponding metrics.
  //
  // The mapping algorithm works as follows:
  // 1. Group events by GC cycles using the epoch argument of events.
  // 2. Consider each GC cycle separately.
  // 3. For each event in a GC cycle find the rule that applies to that event.
  //    There can be at most one such rule. An event E applies to a rule R if
  //    all the following conditions hold:
  //    - R.events contains E.title.
  //    - if R.inside is not empty, then at least one event X specified by
  //      R.inside appears on some thread and fully encloses E, i.e.
  //      X.start <= E.start && E.end <= X.end.
  //      Note that X and E don't have to be on the same thread, which allows
  //      us to find background thread events that happen during atomic pause.
  //    - if R.outside is not empty, then there is no such event X specified by
  //      R.outside that fully encloses E.
  // 4. The contribute_to field of the rule defines the most specific metric
  //    that the event contributes to. More generic metrics that the event also
  //    contributes to can be derived by dropping parts of the specific metric.
  const GC_METRIC_RULES = [
    {
      events: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic',
    },
    {
      events: V8_FULL_MARK_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:mark',
    },
    {
      events: CPP_GC_FULL_MARK_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:mark:cpp',
    },
    {
      events: V8_FULL_MARK_EVENTS,
      outside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:incremental:mark',
    },
    {
      events: CPP_GC_FULL_MARK_EVENTS,
      outside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:incremental:mark:cpp',
    },
    {
      events: V8_FULL_COMPACT_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:compact',
    },
    {
      events: CPP_GC_FULL_COMPACT_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:compact:cpp',
    },
    {
      events: V8_FULL_SWEEP_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:sweep',
    },
    {
      events: CPP_GC_FULL_SWEEP_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:sweep:cpp',
    },
    {
      events: V8_FULL_WEAK_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:weak',
    },
    {
      events: V8_FULL_SWEEP_EVENTS,
      outside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:incremental:sweep',
    },
    {
      events: CPP_GC_FULL_SWEEP_EVENTS,
      outside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:incremental:sweep:cpp',
    },
    {
      events: V8_YOUNG_EVENTS,
      contribute_to: 'young:atomic',
    },
  ];

  // A part of the metric name that defines how the events contributing
  // to the metric are aggregated.
  const Granularity = {
    CYCLE: 'cycle',
    EVENT: 'event',
  };

  // A thread of a V8 isolate is considered a main thread including:
  // - the main thread of the renderer.
  // - the main thread of a dedicated worker.
  // - the main thread of a service worker.
  // A thread that the scheduler uses to post background tasks is considered
  // a background thread. See jsExecutionThreadsWithTypes() below.
  const ThreadType = {
    MAIN: 'main',
    BACKGROUND: 'background',
  };

  // This class parses and models a single metric from METRICS.
  class Metric {
    constructor(name) {
      this.name = name;
      const parts = name.split(':');
      this.granularity = parts[2];
      assert(this.granularity === Granularity.CYCLE ||
             this.granularity === Granularity.EVENT);
      this.thread = null;
      if (parts[3] === 'main_thread') {
        this.thread = ThreadType.MAIN;
      }
      if (parts[3] === 'background_threads') {
        this.thread = ThreadType.BACKGROUND;
      }
      this.phases = parts.slice(this.thread ? 4 : 3);
      const perCycle = this.granularity === Granularity.CYCLE;
      const maxValue = perCycle ? 10000 : 1000;
      const boundaries =
          tr.v.HistogramBinBoundaries.createExponential(0.1, maxValue, 100);
      this.histogram = new tr.v.Histogram(name,
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, boundaries);
      this.histogram.customizeSummaryOptions({
          avg: true,
          count: true,
          max: true,
          min: false,
          std: false,
          sum: perCycle,
      });
    }

    // Checks if the phases of this metric are more generic than the given
    // phases. For example, full:atomic is more generic than full:atomic:mark.
    // Formally, if metric A is a subsequence of metric B, then metric A
    // is more generic than B.
    isMoreGenericThan(phases) {
      let matched = 0;
      for (const phase of phases.split(':')) {
        if (phase === this.phases[matched]) {
          ++matched;
          if (matched == this.phases.length) {
            return true;
          }
        }
      }
      return matched == phases.length;
    }

    // Given a list of rules and a list of events of the same GC cycle,
    // this function returns a list of relevant event, i.e. event that
    // contribute to this metric. 
    contributingEvents(rules, events) {
      // A map from an event name to the events with that name.
      // It is used to speed up encompass checks below.
      const eventsByName = groupBy(events, e => e.title);

      // Checks if the given rule matches (or applies) to the given event.
      function matches(rule, event) {
        // Checks is there is an event with the given name that encompasses
        // |event|.
        function isEncompassing(name) {
          if (!eventsByName.has(name)) return false;
          return eventsByName.get(name).some(e => encompasses(e, event));
        }
        if (!rule.events.includes(event.title)) {
          return false;
        }
        if (rule.inside && !rule.inside.some(isEncompassing)) {
          return false;
        }
        if (rule.outside && rule.outside.some(isEncompassing)) {
          return false;
        }
        return true;
      }

      // For each event find the applying rule and check if the rule also
      // applies to this metric.
      const result = [];
      for (const event of events) {
        const matching = rules.filter(r => matches(r, event));
        if (matching.length === 0) {
          continue;
        }
        assert(matching.length === 1,
            `${event.userFriendlyName} matches more than one rule: ` +
            JSON.stringify(matching));
        if (this.isMoreGenericThan(matching[0].contribute_to)) {
          result.push(event);
        }
      }
      return result;
    }

    // Finds all events that contribute to this metric and aggregates
    // them in the histogram of the metric.
    apply(rules, events, threadTypes) {
      // 1. Find all events that are relevant for this metric.
      const filtered = this.contributingEvents(rules, events);
      // 2. Group the events by thread.
      const eventsByThread = groupBy(filtered, e => e.parentContainer.tid);

      // 3. Drop events nested in other events and also drop events from
      //    the irrelevant threads.
      let flattened = [];
      for (const [tid, threadEvents] of eventsByThread) {
        if (!this.thread || this.thread === threadTypes.get(tid)) {
          flattened = flattened.concat(flatten(threadEvents));
        }
      }

      // 4. Aggregate events in the histogram.
      if (this.granularity === Granularity.CYCLE) {
        let sum = 0;
        for (const event of flattened) {
          sum += event.cpuDuration;
        }
        if (flattened.length > 0) {
          this.histogram.addSample(sum);
        }
      } else {
        for (const event of flattened) {
          this.histogram.addSample(event.cpuDuration);
        }
      }
    }
  }


  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }

  function groupBy(events, group_callback) {
    const eventsByGroup = new Map();
    for (const e of events) {
      const group = group_callback(e);
      if (eventsByGroup.has(group)) {
        eventsByGroup.get(group).push(e);
      } else {
        eventsByGroup.set(group, [e]);
      }
    }
    return eventsByGroup;
  }

  // Checks if the first event encompasses the second event.
  // It is an analog of thread-independent event nesting.
  function encompasses(event1, event2) {
    return (event1.start - EPSILON <= event2.start &&
            event2.end <= event1.end + EPSILON);
  }

  // Returns threads together with a mapping from thread id to thread type.
  function jsExecutionThreadsWithTypes(rendererHelper) {
    const mainThreads = ([rendererHelper.mainThread]
        .concat(rendererHelper.dedicatedWorkerThreads)
        .concat(rendererHelper.serviceWorkerThreads));
    const backgroundThreads = rendererHelper.foregroundWorkerThreads;
    const threadTypes = new Map();
    for (const thread of mainThreads) {
      threadTypes.set(thread.tid, ThreadType.MAIN);
    }
    for (const thread of backgroundThreads) {
      threadTypes.set(thread.tid, ThreadType.BACKGROUND);
    }
    return [mainThreads.concat(backgroundThreads), threadTypes];
  }

  // Drops events nested in other events.
  function flatten(events) {
    function compareWithEpsilon(a, b) {
      if (a.start < b.start - EPSILON) return -1;
      if (a.start > b.start + EPSILON) return 1;
      return b.end - a.end; 
    }
    events.sort(compareWithEpsilon);
    let last = events[0];
    const result = [last];
    for (const e of events) {
      if (e.end > last.end + EPSILON) {
        assert(e.start >= last.end - EPSILON,
            'Overlapping events: ' +
            e.userFriendlyName + ' ' +
            last.userFriendlyName);
        result.push(e);
        last = e;
      }
    }
    return result;
  }

  function groupByEpoch(events) {
    function isV8Event(event) {
      return event.category && event.category.includes('v8');
    }
    function getEpoch(event) {
      const result = {v8: null, cpp: null};
      while (event) {
        if ('epoch' in event.args) {
          if (isV8Event(event)) {
            result.v8 = event.args.epoch;
          } else {
            result.cpp = event.args.epoch;
          }
        }
        event = event.parentSlice;
      }
      return result;
    }
    const cppToV8 = new Map();
    for (const event of events) {
      const epoch = getEpoch(event);
      if (epoch.cpp !== null && epoch.v8 !== null) {
        cppToV8.set(epoch.cpp, epoch.v8);
      }
    }
    const result = new Map();
    for (const event of events) {
      const epoch = getEpoch(event);
      if (epoch.cpp === null && epoch.v8 === null) {
        continue;
      }
      const key = epoch.v8 === null ? cppToV8.get(epoch.cpp) : epoch.v8;
      if (result.has(key)) {
        result.get(key).push(event);
      } else {
        result.set(key, [event]);
      }
    }
    return result;
  }

  function names(rules) {
    let result = [];
    for (const rule of rules) {
      result = result.concat(rule.events);
      if (rule.inside)
        result = result.concat(rule.inside);
      if (rule.outside)
        result = result.concat(rule.outside);
    }
    return result;
  }

  function addGarbageCollectionMetrics(metricNames, histograms, model) {
    const metrics = metricNames.map(name => {
      return new Metric(name);
    });
    const gcEventNames = new Set(names(GC_METRIC_RULES));
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
      if (rendererHelper.isChromeTracingUI) continue;
      const [threads, threadTypes] = jsExecutionThreadsWithTypes(rendererHelper);
      const events = [];
      for (const thread of threads) {
        for (const event of thread.sliceGroup.childEvents()) {
          if (gcEventNames.has(event.title) &&
              !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event)) {
            events.push(event);
          }
        }
      }
      for (const cycleEvents of groupByEpoch(events).values()) {
        for (const metric of metrics) {
          metric.apply(GC_METRIC_RULES, cycleEvents, threadTypes);
        }
      }
    }
    for (const metric of metrics) {
      histograms.addHistogram(metric.histogram);
    }
  }

  function gcMetric(histograms, model, options) {
    options = options || {};
    addDurationOfTopEvents(histograms, model);
    addTotalDurationOfTopEvents(histograms, model);
    if (options.include_sub_events) {
      addDurationOfSubEvents(histograms, model);
    }
    addPercentageInV8ExecuteOfTopEvents(histograms, model);
    addTotalPercentageInV8Execute(histograms, model);
    addMarkCompactorMutatorUtilization(histograms, model);
    addTotalMarkCompactorTime(histograms, model);
    addTotalMarkCompactorMarkingTime(histograms, model);
    addScavengerSurvivedFromStackEvents(histograms, model);
    addGarbageCollectionMetrics(METRICS, histograms, model);
  }

  tr.metrics.MetricRegistry.register(gcMetric);

  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const percentage_biggerIsBetter =
      tr.b.Unit.byName.normalizedPercentage_biggerIsBetter;
  const percentage_smallerIsBetter =
      tr.b.Unit.byName.normalizedPercentage_smallerIsBetter;
  const bytes_smallerIsBetter =
      tr.b.Unit.byName.sizeInBytes_smallerIsBetter;

  // 0.1 steps from 0 to 20 since it is the most common range.
  // Exponentially increasing steps from 20 to 200.
  const CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(0, 20, 200)
      .addExponentialBins(200, 100);

  function createNumericForTopEventTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: true,
      max: true,
      min: false,
      std: true,
      sum: true,
      percentile: [0.90]});
    return n;
  }

  function createNumericForSubEventTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: false,
      percentile: [0.90]
    });
    return n;
  }

  function createNumericForIdleTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: true,
      percentile: []
    });
    return n;
  }

  function createPercentage(name, numerator, denominator, unit) {
    const hist = new tr.v.Histogram(name, unit);
    if (denominator === 0) {
      hist.addSample(0);
    } else {
      hist.addSample(numerator / denominator);
    }
    hist.customizeSummaryOptions({
      avg: true,
      count: false,
      max: false,
      min: false,
      std: false,
      sum: false,
      percentile: []
    });
    return hist;
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor.
   */
  function addDurationOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedTopGarbageCollectionEvent,
        tr.metrics.v8.utils.topGarbageCollectionEventName,
        function(name, events) {
          const cpuDuration = createNumericForTopEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        },
        tr.metrics.v8.utils.topGarbageCollectionEventNames()
    );
  }

  /**
   * Example output:
   * - v8-gc-total
   */
  function addTotalDurationOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedTopGarbageCollectionEvent,
        event => 'v8-gc-total',
        function(name, events) {
          const cpuDuration = createNumericForTopEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        },
        ['v8-gc-total']
    );
  }

  function isV8MarkCompactorSummary(event) {
    return !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event) &&
           tr.metrics.v8.utils.isMarkCompactorSummaryEvent(event);
  }

  function isV8MarkCompactorMarkingSummary(event) {
    return !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event) &&
           tr.metrics.v8.utils.isMarkCompactorMarkingSummaryEvent(event);
  }

  function createHistogramFromSummary(histograms, name, events) {
    const foregroundDuration =
        createNumericForTopEventTime(name + '-foreground');
    const backgroundDuration =
        createNumericForTopEventTime(name + '-background');
    const totalDuration =
        createNumericForTopEventTime(name + '-total');
    const relatedNames = new tr.v.d.RelatedNameMap();
    relatedNames.set('foreground', foregroundDuration.name);
    relatedNames.set('background', backgroundDuration.name);
    for (const event of events) {
      foregroundDuration.addSample(event.args.duration);
      backgroundDuration.addSample(event.args.background_duration);
      const breakdownForTotal = new tr.v.d.Breakdown();
      breakdownForTotal.set('foreground', event.args.duration);
      breakdownForTotal.set('background', event.args.background_duration);
      totalDuration.addSample(
          event.args.duration + event.args.background_duration,
          {breakdown: breakdownForTotal});
    }
    histograms.addHistogram(foregroundDuration);
    histograms.addHistogram(backgroundDuration);
    histograms.addHistogram(totalDuration, {breakdown: relatedNames});
  }

  /**
   * Example output:
   * - v8-gc-mark-compactor-foreground
   * - v8-gc-mark-compactor-background
   * - v8-gc-mark-compactor-total
   */
  function addTotalMarkCompactorTime(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isV8MarkCompactorSummary,
        event => 'v8-gc-mark-compactor',
        (name, events) => createHistogramFromSummary(histograms, name, events),
        ['v8-gc-mark-compactor']
    );
  }

  /**
   * Example output:
   * - v8-gc-mark-compactor-marking-foreground
   * - v8-gc-mark-compactor-marking-background
   * - v8-gc-mark-compactor-marking-total
   */
  function addTotalMarkCompactorMarkingTime(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isV8MarkCompactorMarkingSummary,
        event => 'v8-gc-mark-compactor-marking',
        (name, events) => createHistogramFromSummary(histograms, name, events),
        ['v8-gc-mark-compactor-marking']
    );
  }

  function createNumericForTotalBytes(name) {
    const n = new tr.v.Histogram(name,
        bytes_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: false,
      count: false,
      max: false,
      min: false,
      std: false,
      sum: true,
      percentile: []
    });
    return n;
  }

  function createNumericForSampledPercent(name) {
    const n = new tr.v.Histogram(name,
        percentage_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: true,
      std: true,
      sum: false,
      percentile: []
    });
    return n;
  }

  /**
   * Adds the following metrics:
   * - v8-gc-scavenger-survived-percentage-from-stack
   * - v8-gc-scavenger-survived-total-bytes-without-stack
   * - v8-gc-scavenger-survived-total-bytes-with-stack
   * - v8-gc-scavenger-survived-total-percentage-from-stack
   */
  function addScavengerSurvivedFromStackEvents(histograms, model) {
    const baseName = 'v8-gc-scavenger-survived';
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isScavengerStackScanningEvent,
        event => baseName,
        function(name, events) {
          const sampledPercentage = createNumericForSampledPercent(
              baseName + '-percentage-from-stack');
          let survivedWithoutStack = 0;
          let survivedWithStack = 0;
          events.forEach(function(event) {
            const bytesBefore = event.args.survived_bytes_before;
            const bytesAfter = event.args.survived_bytes_after;
            sampledPercentage.addSample((bytesAfter > 0) ?
              (bytesAfter - bytesBefore) / bytesAfter :
              0);
            survivedWithoutStack += bytesBefore;
            survivedWithStack += bytesAfter;
          });
          histograms.addHistogram(sampledPercentage);
          const totalBytesSurvivedWithoutStack = createNumericForTotalBytes(
              baseName + '-total-bytes-without-stack');
          totalBytesSurvivedWithoutStack.addSample(survivedWithoutStack);
          histograms.addHistogram(totalBytesSurvivedWithoutStack);
          const totalBytesSurvivedWithStack = createNumericForTotalBytes(
              baseName + '-total-bytes-with-stack');
          totalBytesSurvivedWithStack.addSample(survivedWithStack);
          histograms.addHistogram(totalBytesSurvivedWithStack);
          const overallPercentage = createPercentage(
              baseName + '-total-percentage-from-stack',
              survivedWithStack - survivedWithoutStack,
              survivedWithStack,
              percentage_smallerIsBetter);
          histograms.addHistogram(overallPercentage);
        },
        [baseName]
    );
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor-evacuate.
   */
  function addDurationOfSubEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedSubGarbageCollectionEvent,
        tr.metrics.v8.utils.subGarbageCollectionEventName,
        function(name, events) {
          const cpuDuration = createNumericForSubEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        }
    );
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor_percentage_in_v8_execute.
   */
  function addPercentageInV8ExecuteOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedTopGarbageCollectionEvent,
        tr.metrics.v8.utils.topGarbageCollectionEventName,
        function(name, events) {
          addPercentageInV8Execute(histograms, model, name, events);
        },
        tr.metrics.v8.utils.topGarbageCollectionEventNames()
    );
  }

  /**
   * Example output:
   * - v8-gc-total_percentage_in_v8_execute.
   */
  function addTotalPercentageInV8Execute(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedTopGarbageCollectionEvent,
        event => 'v8-gc-total',
        function(name, events) {
          addPercentageInV8Execute(histograms, model, name, events);
        },
        ['v8-gc-total']
    );
  }

  function addPercentageInV8Execute(histograms, model, name, events) {
    let cpuDurationInV8Execute = 0;
    let cpuDurationTotal = 0;
    events.forEach(function(event) {
      const v8Execute = tr.metrics.v8.utils.findParent(
          event, tr.metrics.v8.utils.isV8ExecuteEvent);
      if (v8Execute) {
        cpuDurationInV8Execute += event.cpuDuration;
      }
      cpuDurationTotal += event.cpuDuration;
    });
    const percentage = createPercentage(
        name + '_percentage_in_v8_execute', cpuDurationInV8Execute,
        cpuDurationTotal, percentage_smallerIsBetter);
    histograms.addHistogram(percentage);
  }

  /**
   * Example output:
   * - v8-gc-mark-compactor-mmu-100ms_window.
   */
  function addMarkCompactorMutatorUtilization(histograms, model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const rendererHelpers = Object.values(chromeHelper.rendererHelpers);
    tr.metrics.v8.utils.addMutatorUtilization(
        'v8-gc-mark-compactor-mmu',
        tr.metrics.v8.utils.isNotForcedMarkCompactorEvent,
        [100],
        rendererHelpers,
        histograms);
  }

  return {
    gcMetric,
    WINDOW_SIZE_MS,  // For testing purposes only.
    addGarbageCollectionMetrics, // For testing purposes only.
  };
});
</script>

