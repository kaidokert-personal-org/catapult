<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/math/range.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/v8/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/value/diagnostics/breakdown.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.v8', function() {
  // The time window size for mutator utilization computation.
  // It is equal to the duration of one frame corresponding to 60 FPS rendering.
  const TARGET_FPS = 60;
  const MS_PER_SECOND = 1000;
  const WINDOW_SIZE_MS = MS_PER_SECOND / TARGET_FPS;
  const EPSILON = 1e-6;

  const V8_FULL_ATOMIC_EVENTS = [
    'V8.GCCompactor',
    'V8.GCFinalizeMC',
    'V8.GCFinalizeMCReduceMemory',
  ];

  const V8_FULL_MARK_EVENTS = [
    'V8.GC_MC_MARK',
    'V8.GC_MC_BACKGROUND_MARKING',
    'V8.GCIncrementalMarkingStart',
    'V8.GCIncrementalMarking',
    'V8.GCIncrementalMarkingFinalize',
  ];

  const V8_FULL_COMPACT_EVENTS = [
    'V8.GC_MC_EVACUATE',
    'V8.GC_MC_BACKGROUND_EVACUATE_COPY',
    'V8.GC_MC_BACKGROUND_EVACUATE_UPDATE_POINTERS',
  ];

  const V8_FULL_SWEEP_EVENTS = [
    'V8.GC_MC_SWEEP',
    'V8.GC_MC_BACKGROUND_SWEEPING',
    'V8.GC_BACKGROUND_ARRAY_BUFFER_SWEEP',
  ];

  const V8_FULL_WEAK_EVENTS = [
    'V8.GC_MC_CLEAR',
  ];

  const V8_YOUNG_EVENTS = [
    'V8.GCScavenger',
    'V8.GC_SCAVENGER_BACKGROUND_SCAVENGE_PARALLEL',
  ];

  const CPP_GC_FULL_MARK_EVENTS = [
    'BlinkGC.AtomicPauseMarkEpilogue',
    'BlinkGC.AtomicPauseMarkPrologue',
    'BlinkGC.AtomicPauseMarkRoots',
    'BlinkGC.AtomicPauseMarkTransitiveClosure',
    'BlinkGC.ConcurrentMarkingStep',
    'BlinkGC.IncrementalMarkingStartMarking',
    'BlinkGC.IncrementalMarkingStep',
    'BlinkGC.UnifiedMarkingStep',
    'BlinkGC.MarkBailOutObjects',
    'BlinkGC.MarkFlushV8References',
    'BlinkGC.MarkFlushEphemeronPairs',
  ];

  const CPP_GC_FULL_COMPACT_EVENTS = [
    'BlinkGC.AtomicPauseSweepAndCompact',
  ];

  const CPP_GC_FULL_SWEEP_EVENTS = [
    'BlinkGC.ConcurrentSweepingStep',
    'BlinkGC.CompleteSweep',
    'BlinkGC.LazySweepInIdle',
    'BlinkGC.LazySweepOnAllocation',
  ];

  const GC_METRIC_RULES = [
    {
      events: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic',
    },
    {
      events: V8_FULL_MARK_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:mark',
    },
    {
      events: CPP_GC_FULL_MARK_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:mark:cpp',
    },
    {
      events: V8_FULL_MARK_EVENTS,
      outside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:incremental:mark',
    },
    {
      events: CPP_GC_FULL_MARK_EVENTS,
      outside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:incremental:mark:cpp',
    },
    {
      events: V8_FULL_COMPACT_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:compact',
    },
    {
      events: CPP_GC_FULL_COMPACT_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:compact:cpp',
    },
    {
      events: V8_FULL_SWEEP_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:sweep',
    },
    {
      events: CPP_GC_FULL_SWEEP_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:sweep:cpp',
    },
    {
      events: V8_FULL_WEAK_EVENTS,
      inside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:atomic:weak',
    },
    {
      events: V8_FULL_SWEEP_EVENTS,
      outside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:incremental:sweep',
    },
    {
      events: CPP_GC_FULL_SWEEP_EVENTS,
      outside: V8_FULL_ATOMIC_EVENTS,
      contribute_to: 'full:incremental:sweep:cpp',
    },
    {
      events: V8_YOUNG_EVENTS,
      contribute_to: 'young:atomic',
    },
  ];

  const Granularity = {
    CYCLE: 'cycle',
    EVENT: 'event',
  };

  const ThreadType = {
    MAIN: 'main',
    BACKGROUND: 'background',
  };

  class Metric {
    constructor(name) {
      this.name = name;
      const parts = name.split(':');
      this.granularity = parts[2];
      assert(this.granularity === Granularity.CYCLE ||
             this.granularity === Granularity.EVENT);
      this.thread = null;
      if (parts[3] === 'main_thread') {
        this.thread = ThreadType.MAIN;
      }
      if (parts[3] === 'background_threads') {
        this.thread = ThreadType.BACKGROUND;
      }
      this.phases = parts.slice(this.thread ? 4 : 3);
      const perCycle = this.granularity === Granularity.CYCLE;
      const maxValue = perCycle ? 10000 : 1000;
      const boundaries =
          tr.v.HistogramBinBoundaries.createExponential(0.1, maxValue, 100);
      this.histogram = new tr.v.Histogram(name,
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, boundaries);
      this.histogram.customizeSummaryOptions({
          avg: true,
          count: true,
          max: true,
          min: false,
          std: false,
          sum: perCycle,
      });
    }

    subsumes(phases) {
      let matched = 0;
      for (const phase of phases.split(':')) {
        if (phase === this.phases[matched]) {
          ++matched;
          if (matched == this.phases.length) {
            // The given phases are more specific than this metric. 
            return true;
          }
        }
      }
      return matched == phases.length;
    }

    contributingEvents(rules, events) {
      const eventsByName = groupBy(events, e => e.title);

      function matches(rule, event) {
        function checkCover(name) {
          if (!eventsByName.has(name)) return false;
          return eventsByName.get(name).some(e => covers(e, event));
        }
        if (!rule.events.includes(event.title)) {
          return false;
        }
        if (rule.inside && !rule.inside.some(checkCover)) {
          return false;
        }
        if (rule.outside && rule.outside.some(checkCover)) {
          return false;
        }
        return true;
      }

      const result = [];
      for (const event of events) {
        const matching = rules.filter(r => matches(r, event));
        if (matching.length === 0) {
          continue;
        }
        assert(matching.length === 1,
            `${event.userFriendlyName} matches more than one rule: ` +
            JSON.stringify(matching));
        if (this.subsumes(matching[0].contribute_to)) {
          result.push(event);
        }
      }
      return result;
    }

    apply(rules, events, threadTypes) {
      const filtered = this.contributingEvents(rules, events);
      const eventsByThread = groupBy(filtered, e => e.parentContainer.tid);

      let flattened = [];
      for (const [tid, threadEvents] of eventsByThread) {
        if (!this.thread || this.thread === threadTypes.get(tid)) {
          flattened = flattened.concat(flatten(threadEvents));
        }
      }
      if (this.granularity === Granularity.CYCLE) {
        let sum = 0;
        for (const event of flattened) {
          sum += event.cpuDuration;
        }
        if (flattened.length > 0) {
          this.histogram.addSample(sum);
        }
      } else {
        for (const event of flattened) {
          this.histogram.addSample(event.cpuDuration);
        }
      }
    }
  }


  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }

  function covers(event1, event2) {
    return (event1.start - EPSILON <= event2.start &&
            event2.end <= event1.end + EPSILON);
  }

  function groupBy(events, group_callback) {
    const eventsByGroup = new Map();
    for (const e of events) {
      const group = group_callback(e);
      if (eventsByGroup.has(group)) {
        eventsByGroup.get(group).push(e);
      } else {
        eventsByGroup.set(group, [e]);
      }
    }
    return eventsByGroup;
  }

  function jsExecutionThreadsWithTypes(rendererHelper) {
    const mainThreads = ([rendererHelper.mainThread]
        .concat(rendererHelper.dedicatedWorkerThreads)
        .concat(rendererHelper.serviceWorkerThreads));
    const backgroundThreads = rendererHelper.foregroundWorkerThreads;
    const threadTypes = new Map();
    for (const thread of mainThreads) {
      threadTypes.set(thread.tid, ThreadType.MAIN);
    }
    for (const thread of backgroundThreads) {
      threadTypes.set(thread.tid, ThreadType.BACKGROUND);
    }
    return [mainThreads.concat(backgroundThreads), threadTypes];
  }

  function flatten(events) {
    function compareWithEpsilon(a, b) {
      if (a.start < b.start - EPSILON) return -1;
      if (a.start > b.start + EPSILON) return 1;
      return b.end - a.end; 
    }
    events.sort(compareWithEpsilon);
    let last = events[0];
    const result = [last];
    for (const e of events) {
      if (e.end > last.end + EPSILON) {
        assert(e.start >= last.end - EPSILON,
            'Overlapping events: ' +
            e.userFriendlyName + ' ' +
            last.userFriendlyName);
        result.push(e);
        last = e;
      }
    }
    return result;
  }

  function groupByEpoch(events) {
    function isV8Event(event) {
      return event.category && event.category.includes('v8');
    }
    function getEpoch(event) {
      const result = {v8: null, cpp: null};
      while (event) {
        if ('epoch' in event.args) {
          if (isV8Event(event)) {
            result.v8 = event.args.epoch;
          } else {
            result.cpp = event.args.epoch;
          }
        }
        event = event.parentSlice;
      }
      return result;
    }
    const cppToV8 = new Map();
    for (const event of events) {
      const epoch = getEpoch(event);
      if (epoch.cpp !== null && epoch.v8 !== null) {
        cppToV8.set(epoch.cpp, epoch.v8);
      }
    }
    const result = new Map();
    for (const event of events) {
      const epoch = getEpoch(event);
      if (epoch.cpp === null && epoch.v8 === null) {
        continue;
      }
      const key = epoch.v8 === null ? cppToV8.get(epoch.cpp) : epoch.v8;
      if (result.has(key)) {
        result.get(key).push(event);
      } else {
        result.set(key, [event]);
      }
    }
    return result;
  }

  function names(rules) {
    let result = [];
    for (const rule of rules) {
      result = result.concat(rule.events);
      if (rule.inside)
        result = result.concat(rule.inside);
      if (rule.outside)
        result = result.concat(rule.outside);
    }
    return result;
  }

  function addGarbageCollectionMetrics(metricNames, histograms, model) {
    const metrics = metricNames.map(name => {
      return new Metric(name);
    });
    const gcEventNames = new Set(names(GC_METRIC_RULES));
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
      if (rendererHelper.isChromeTracingUI) continue;
      const [threads, threadTypes] = jsExecutionThreadsWithTypes(rendererHelper);
      const events = [];
      for (const thread of threads) {
        for (const event of thread.sliceGroup.childEvents()) {
          if (gcEventNames.has(event.title) &&
              !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event)) {
            events.push(event);
          }
        }
      }
      for (const cycleEvents of groupByEpoch(events).values()) {
        for (const metric of metrics) {
          metric.apply(GC_METRIC_RULES, cycleEvents, threadTypes);
        }
      }
    }
    for (const metric of metrics) {
      histograms.addHistogram(metric.histogram);
    }
  }

  function gcMetric(histograms, model, options) {
    options = options || {};
    addDurationOfTopEvents(histograms, model);
    addTotalDurationOfTopEvents(histograms, model);
    if (options.include_sub_events) {
      addDurationOfSubEvents(histograms, model);
    }
    addPercentageInV8ExecuteOfTopEvents(histograms, model);
    addTotalPercentageInV8Execute(histograms, model);
    addMarkCompactorMutatorUtilization(histograms, model);
    addTotalMarkCompactorTime(histograms, model);
    addTotalMarkCompactorMarkingTime(histograms, model);
    addScavengerSurvivedFromStackEvents(histograms, model);
    const metrics = [
      'v8:gc:cycle:full',
      'v8:gc:cycle:full:cpp',
      'v8:gc:cycle:full:mark',
      'v8:gc:cycle:full:mark:cpp',
      'v8:gc:cycle:full:weak',
      'v8:gc:cycle:full:weak:cpp',
      'v8:gc:cycle:full:sweep',
      'v8:gc:cycle:full:sweep:cpp',
      'v8:gc:cycle:full:compact',
      'v8:gc:cycle:full:compact:cpp',
      'v8:gc:cycle:main_thread:full',
      'v8:gc:cycle:main_thread:full:cpp',
      'v8:gc:cycle:main_thread:full:mark',
      'v8:gc:cycle:main_thread:full:mark:cpp',
      'v8:gc:cycle:main_thread:full:weak',
      'v8:gc:cycle:main_thread:full:weak:cpp',
      'v8:gc:cycle:main_thread:full:sweep',
      'v8:gc:cycle:main_thread:full:sweep:cpp',
      'v8:gc:cycle:main_thread:full:compact',
      'v8:gc:cycle:main_thread:full:compact:cpp',
      'v8:gc:event:main_thread:full:atomic',
      'v8:gc:event:main_thread:full:atomic:cpp',
      'v8:gc:event:main_thread:full:atomic:mark',
      'v8:gc:event:main_thread:full:atomic:mark:cpp',
      'v8:gc:event:main_thread:full:atomic:weak',
      'v8:gc:event:main_thread:full:atomic:weak:cpp',
      'v8:gc:event:main_thread:full:atomic:sweep',
      'v8:gc:event:main_thread:full:atomic:sweep:cpp',
      'v8:gc:event:main_thread:full:atomic:compact',
      'v8:gc:event:main_thread:full:atomic:compact:cpp',
      'v8:gc:event:main_thread:full:incremental',
      'v8:gc:event:main_thread:full:incremental:cpp',
      'v8:gc:event:main_thread:full:incremental:mark',
      'v8:gc:event:main_thread:full:incremental:mark:cpp',
      'v8:gc:event:main_thread:full:incremental:sweep',
      'v8:gc:event:main_thread:full:incremental:sweep:cpp',
      'v8:gc:cycle:young',
      'v8:gc:cycle:main_thread:young',
    ];
    addGarbageCollectionMetrics(metrics, histograms, model);
  }

  tr.metrics.MetricRegistry.register(gcMetric);

  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const percentage_biggerIsBetter =
      tr.b.Unit.byName.normalizedPercentage_biggerIsBetter;
  const percentage_smallerIsBetter =
      tr.b.Unit.byName.normalizedPercentage_smallerIsBetter;
  const bytes_smallerIsBetter =
      tr.b.Unit.byName.sizeInBytes_smallerIsBetter;

  // 0.1 steps from 0 to 20 since it is the most common range.
  // Exponentially increasing steps from 20 to 200.
  const CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(0, 20, 200)
      .addExponentialBins(200, 100);

  function createNumericForTopEventTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: true,
      max: true,
      min: false,
      std: true,
      sum: true,
      percentile: [0.90]});
    return n;
  }

  function createNumericForSubEventTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: false,
      percentile: [0.90]
    });
    return n;
  }

  function createNumericForIdleTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: true,
      percentile: []
    });
    return n;
  }

  function createPercentage(name, numerator, denominator, unit) {
    const hist = new tr.v.Histogram(name, unit);
    if (denominator === 0) {
      hist.addSample(0);
    } else {
      hist.addSample(numerator / denominator);
    }
    hist.customizeSummaryOptions({
      avg: true,
      count: false,
      max: false,
      min: false,
      std: false,
      sum: false,
      percentile: []
    });
    return hist;
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor.
   */
  function addDurationOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedTopGarbageCollectionEvent,
        tr.metrics.v8.utils.topGarbageCollectionEventName,
        function(name, events) {
          const cpuDuration = createNumericForTopEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        },
        tr.metrics.v8.utils.topGarbageCollectionEventNames()
    );
  }

  /**
   * Example output:
   * - v8-gc-total
   */
  function addTotalDurationOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedTopGarbageCollectionEvent,
        event => 'v8-gc-total',
        function(name, events) {
          const cpuDuration = createNumericForTopEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        },
        ['v8-gc-total']
    );
  }

  function isV8MarkCompactorSummary(event) {
    return !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event) &&
           tr.metrics.v8.utils.isMarkCompactorSummaryEvent(event);
  }

  function isV8MarkCompactorMarkingSummary(event) {
    return !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event) &&
           tr.metrics.v8.utils.isMarkCompactorMarkingSummaryEvent(event);
  }

  function createHistogramFromSummary(histograms, name, events) {
    const foregroundDuration =
        createNumericForTopEventTime(name + '-foreground');
    const backgroundDuration =
        createNumericForTopEventTime(name + '-background');
    const totalDuration =
        createNumericForTopEventTime(name + '-total');
    const relatedNames = new tr.v.d.RelatedNameMap();
    relatedNames.set('foreground', foregroundDuration.name);
    relatedNames.set('background', backgroundDuration.name);
    for (const event of events) {
      foregroundDuration.addSample(event.args.duration);
      backgroundDuration.addSample(event.args.background_duration);
      const breakdownForTotal = new tr.v.d.Breakdown();
      breakdownForTotal.set('foreground', event.args.duration);
      breakdownForTotal.set('background', event.args.background_duration);
      totalDuration.addSample(
          event.args.duration + event.args.background_duration,
          {breakdown: breakdownForTotal});
    }
    histograms.addHistogram(foregroundDuration);
    histograms.addHistogram(backgroundDuration);
    histograms.addHistogram(totalDuration, {breakdown: relatedNames});
  }

  /**
   * Example output:
   * - v8-gc-mark-compactor-foreground
   * - v8-gc-mark-compactor-background
   * - v8-gc-mark-compactor-total
   */
  function addTotalMarkCompactorTime(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isV8MarkCompactorSummary,
        event => 'v8-gc-mark-compactor',
        (name, events) => createHistogramFromSummary(histograms, name, events),
        ['v8-gc-mark-compactor']
    );
  }

  /**
   * Example output:
   * - v8-gc-mark-compactor-marking-foreground
   * - v8-gc-mark-compactor-marking-background
   * - v8-gc-mark-compactor-marking-total
   */
  function addTotalMarkCompactorMarkingTime(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isV8MarkCompactorMarkingSummary,
        event => 'v8-gc-mark-compactor-marking',
        (name, events) => createHistogramFromSummary(histograms, name, events),
        ['v8-gc-mark-compactor-marking']
    );
  }

  function createNumericForTotalBytes(name) {
    const n = new tr.v.Histogram(name,
        bytes_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: false,
      count: false,
      max: false,
      min: false,
      std: false,
      sum: true,
      percentile: []
    });
    return n;
  }

  function createNumericForSampledPercent(name) {
    const n = new tr.v.Histogram(name,
        percentage_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: true,
      std: true,
      sum: false,
      percentile: []
    });
    return n;
  }

  /**
   * Adds the following metrics:
   * - v8-gc-scavenger-survived-percentage-from-stack
   * - v8-gc-scavenger-survived-total-bytes-without-stack
   * - v8-gc-scavenger-survived-total-bytes-with-stack
   * - v8-gc-scavenger-survived-total-percentage-from-stack
   */
  function addScavengerSurvivedFromStackEvents(histograms, model) {
    const baseName = 'v8-gc-scavenger-survived';
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isScavengerStackScanningEvent,
        event => baseName,
        function(name, events) {
          const sampledPercentage = createNumericForSampledPercent(
              baseName + '-percentage-from-stack');
          let survivedWithoutStack = 0;
          let survivedWithStack = 0;
          events.forEach(function(event) {
            const bytesBefore = event.args.survived_bytes_before;
            const bytesAfter = event.args.survived_bytes_after;
            sampledPercentage.addSample((bytesAfter > 0) ?
              (bytesAfter - bytesBefore) / bytesAfter :
              0);
            survivedWithoutStack += bytesBefore;
            survivedWithStack += bytesAfter;
          });
          histograms.addHistogram(sampledPercentage);
          const totalBytesSurvivedWithoutStack = createNumericForTotalBytes(
              baseName + '-total-bytes-without-stack');
          totalBytesSurvivedWithoutStack.addSample(survivedWithoutStack);
          histograms.addHistogram(totalBytesSurvivedWithoutStack);
          const totalBytesSurvivedWithStack = createNumericForTotalBytes(
              baseName + '-total-bytes-with-stack');
          totalBytesSurvivedWithStack.addSample(survivedWithStack);
          histograms.addHistogram(totalBytesSurvivedWithStack);
          const overallPercentage = createPercentage(
              baseName + '-total-percentage-from-stack',
              survivedWithStack - survivedWithoutStack,
              survivedWithStack,
              percentage_smallerIsBetter);
          histograms.addHistogram(overallPercentage);
        },
        [baseName]
    );
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor-evacuate.
   */
  function addDurationOfSubEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedSubGarbageCollectionEvent,
        tr.metrics.v8.utils.subGarbageCollectionEventName,
        function(name, events) {
          const cpuDuration = createNumericForSubEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        }
    );
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor_percentage_in_v8_execute.
   */
  function addPercentageInV8ExecuteOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedTopGarbageCollectionEvent,
        tr.metrics.v8.utils.topGarbageCollectionEventName,
        function(name, events) {
          addPercentageInV8Execute(histograms, model, name, events);
        },
        tr.metrics.v8.utils.topGarbageCollectionEventNames()
    );
  }

  /**
   * Example output:
   * - v8-gc-total_percentage_in_v8_execute.
   */
  function addTotalPercentageInV8Execute(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        tr.metrics.v8.utils.isNotForcedTopGarbageCollectionEvent,
        event => 'v8-gc-total',
        function(name, events) {
          addPercentageInV8Execute(histograms, model, name, events);
        },
        ['v8-gc-total']
    );
  }

  function addPercentageInV8Execute(histograms, model, name, events) {
    let cpuDurationInV8Execute = 0;
    let cpuDurationTotal = 0;
    events.forEach(function(event) {
      const v8Execute = tr.metrics.v8.utils.findParent(
          event, tr.metrics.v8.utils.isV8ExecuteEvent);
      if (v8Execute) {
        cpuDurationInV8Execute += event.cpuDuration;
      }
      cpuDurationTotal += event.cpuDuration;
    });
    const percentage = createPercentage(
        name + '_percentage_in_v8_execute', cpuDurationInV8Execute,
        cpuDurationTotal, percentage_smallerIsBetter);
    histograms.addHistogram(percentage);
  }

  /**
   * Example output:
   * - v8-gc-mark-compactor-mmu-100ms_window.
   */
  function addMarkCompactorMutatorUtilization(histograms, model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const rendererHelpers = Object.values(chromeHelper.rendererHelpers);
    tr.metrics.v8.utils.addMutatorUtilization(
        'v8-gc-mark-compactor-mmu',
        tr.metrics.v8.utils.isNotForcedMarkCompactorEvent,
        [100],
        rendererHelpers,
        histograms);
  }

  return {
    gcMetric,
    WINDOW_SIZE_MS,  // For testing purposes only.
    addGarbageCollectionMetrics, // For testing purposes only.
  };
});
</script>

