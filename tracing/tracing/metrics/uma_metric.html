<!DOCTYPE html>
<!--
Copyright 2019 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/base64.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

/**
 * @fileoverfiew This file contains implementation of extracting UMA histograms.
 *
 * UMA histograms are logged in trace events titled 'UMAHistogramSamples'. The
 * event arguments contain the histogram name and the base-64 coded of an
 * snapshot of histogram samples serialized in a pickle.
 *
 * If there are several processes that have snapshots of the same histogram,
 * the snapshots will be merged.
 *
 * If there are two snapshots of the same histogram in the same process, we
 * assume that the first snapshot is taken when tracing started and the second
 * snapshot is taken when tracing is stopped. So, we compute the difference to
 * show the samples added during the tracing session.
 */
tr.exportTo('tr.metrics', function() {
  function parseBuckets_(buckets) {
    const len = tr.b.Base64.getDecodedBufferLength(buckets);
    const buffer = new ArrayBuffer(len);
    const dataView = new DataView(buffer);
    tr.b.Base64.DecodeToTypedArray(buckets, dataView);
    // Negative numbers are not supported, for now.
    const decoded = new Uint32Array(buffer);
    const sum = decoded[1] + decoded[2] * 0x100000000;
    const bins = [];
    let position = 4;
    while (position <= decoded.length - 4) {
      const min = decoded[position++];
      const max = decoded[position++] + decoded[position++] * 0x100000000;
      const count = decoded[position++];
      bins.push([min, max, count]);
    }
    return {sum, bins};
  }

  function mergeBins_(x, y) {
    x.sum += y.sum;
    const allBins = [];
    allBins.push(...x.bins, ...y.bins);
    allBins.sort((a, b) => a[0] - b[0]);
    x.bins = [];
    let last = undefined;
    for (let i = 0; i < allBins.length; i++) {
      if (last !== undefined && allBins[i][0] === last[0]) {
        if (last[1] !== allBins[i][1]) throw new Error('Incompatible bins');
        last[2] += allBins[i][2];
      } else {
        if (last !== undefined && allBins[i][0] < last[1]) {
          throw new Error('Incompatible bins');
        }
        x.bins.push(allBins[i]);
        last = allBins[i];
      }
    }
  }

  function subtractBins_(x, y) {
    x.sum -= y.sum;
    const len1 = x.bins.length;
    const len2 = y.bins.length;
    let p1 = 0;
    let p2 = 0;
    while (p2 < len2) {
      while (p1 < len1 && x.bins[p1][0] !== y.bins[p2][0]) {
        p1++;
      }
      if (p1 === len1) throw new Error('y is not a subset of x');
      if (x.bins[p1][1] !== y.bins[p2][1]) throw new Error('Incompatible bins');
      if (x.bins[p1][2] < y.bins[p2][2]) throw new Error('Cannot subtract');
      x.bins[p1][2] -= y.bins[p2][2];
      p2++;
    }
  }

  function umaMetric(histograms, model) {
    const histogramValues = new Map();
    for (const process of model.getAllProcesses()) {
      const histogramSnapshots = new Map();
      for (const event of process.instantEvents) {
        if (event.title !== 'UMAHistogramSamples') continue;
        const name = event.args.name;
        const snapshots = histogramSnapshots.get(name) || [];
        if (!histogramSnapshots.has(name)) {
          histogramSnapshots.set(name, snapshots);
        }
        snapshots.push(event.args.buckets);
      }
      for (const [name, snapshots] of histogramSnapshots) {
        const values = histogramValues.get(name) || {sum: 0, bins: []};
        if (!histogramValues.has(name)) histogramValues.set(name, values);
        const length = snapshots.length;
        const endValues = parseBuckets_(snapshots[length - 1]);
        if (length === 1) {
          mergeBins_(values, endValues);
        } else if (snapshots.length === 2) {
          subtractBins_(endValues, parseBuckets_(snapshots[0]));
          mergeBins_(values, endValues);
        } else {
          throw new Error('There should be at most two snapshots of an UMA ' +
                          'histogram in each process');
        }
      }
    }

    for (const [name, values] of histogramValues) {
      // If we just put samples at the middle of the bins, their sum may not
      // match the sum we read from traces. Compute how much samples should be
      // shifted so that their sum matches what we expect.
      let sumOfMiddles = 0;
      let sumOfBinLengths = 0;
      for (const bin of values.bins) {
        sumOfMiddles += bin[2] * (bin[0] + bin[1]) / 2;
        sumOfBinLengths += bin[2] * (bin[1] - bin[0]);
      }
      const shift = (values.sum - sumOfMiddles) / sumOfBinLengths;
      if (Math.abs(shift) > 0.5) throw new Error('Samples sum is wrong');

      const samples = [];
      const boundaries = [];
      let lastBoundary = undefined;
      for (const bin of values.bins) {
        if (bin[2] === 0) continue;
        const shiftedValue = (bin[0] + bin[1]) / 2 + shift * (bin[1] - bin[0]);
        samples.push(...Array(bin[2]).fill(shiftedValue));
        if (lastBoundary === undefined || bin[0] !== lastBoundary) {
          boundaries.push(bin[0]);
        }
        boundaries.push(bin[1]);
        lastBoundary = bin[1];
      }
      histograms.createHistogram(
          name, tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
          samples, {
            binBoundaries:
                tr.v.HistogramBinBoundaries.createWithBoundaries(boundaries)
          }
      );
    }
  }

  tr.metrics.MetricRegistry.register(umaMetric, {
    requiredCategories: ['benchmark'],
  });

  return {
    umaMetric,
  };
});
</script>
