<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/base/unit_scale.html">
<link rel="import" href="/tracing/metrics/rendering/cpu_utilization.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/user_model/segment.html">
<link rel="import" href="/tracing/value/diagnostics/generic_set.html">
<link rel="import" href="/tracing/value/diagnostics/related_event_set.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.rendering', function() {
  function findMainRenderer(chromeHelper) {
    for (const r of Object.values(chromeHelper.rendererHelpers)) {
      if (!r.mainThread) continue;
      if (!r.compositorThread) continue;
      for (const slice of r.mainThread.asyncSliceGroup.slices) {
        if (slice.title === 'first-renderer-thread') return r;
      }
    }
    return undefined;
  }

  function computeAvgSmoothness(histograms, renderer) {
    let totalVisibleDuration = 0;
    const allDropped = new Set();
    for (const slice of renderer.compositorThread.asyncSliceGroup.slices) {
      if (slice.title === 'PipelineReporter') {
        if (slice.args && slice.args.chrome_frame_reporter.affects_smoothness) {
          allDropped.add(slice.args.chrome_frame_reporter.frame_sequence);
        }
      } else if (slice.title === 'NeedsBeginFrames') {
        totalVisibleDuration += slice.duration;
      }
    }
    const totalDropped = allDropped.size;
    const totalVsyncs = totalVisibleDuration / 16.667;

    histograms.createHistogram('000smoothness_avg_trace',
        tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
        (totalDropped * 100 / totalVsyncs),
        {description: 'average dropped frames affecting smoothness',
          summaryOptions: {}});
  }

  function computeMaxSmoothnessOfWindow(histograms, renderer, windowLength) {
    const queue = [];
    let queueLength = 0; // Tracks the sum duration of slices
    let lastEndTime = 0;
    let totalDropped = 0;
    const allDropped = new Set();

    for (const slice of renderer.compositorThread.asyncSliceGroup.slices) {
      if (slice.title === 'PipelineReporter' && slice.args) {
        if (allDropped.has(slice.args.chrome_frame_reporter.frame_sequence)) {
          continue;
        }
        allDropped.add(slice.args.chrome_frame_reporter.frame_sequence);
        let isDropped = false;
        if (slice.args.chrome_frame_reporter.affects_smoothness) {
          isDropped = true;
          totalDropped += 1;
        } else if (
          slice.args.chrome_frame_reporter.state !== 'STATE_PRESENTED_ALL') {
          continue;
        }

        const newStartTime = Math.max(lastEndTime, slice.start);
        const endTime = slice.start + slice.duration;
        const actualDuration = endTime - newStartTime;
        queueLength += actualDuration;

        queue.push({
          'dropped': isDropped,
          'duration': actualDuration
        });

        lastEndTime = endTime;

        if (queueLength >= windowLength) {
          histograms.createHistogram(
              '000smoothness_rolling_window_length_' + windowLength + '_trace',
              tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
              (totalDropped * 100 / queue.length),
              {description: 'percentage of dropped frames affecting' +
                'smoothness in the window of length ' + windowLength,
              summaryOptions: {}});
          histograms.createHistogram(
              '000rolling_window_length_' + windowLength + '_trace',
              tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
              queueLength,
              {description: 'percentage of dropped frames affecting' +
                'smoothness in the window of length ' + windowLength,
              summaryOptions: {}});

          // Remove one element from the queue
          // (this implementation is not efficient)
          const front = queue.shift();
          queueLength -= front.duration;
          if (front.dropped === true) {
            totalDropped -= 1;
          }
        }
      }
    }
  }

  function addSmoothness(histograms, model, segments) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    let maxTotal = 0;
    let maxDropped = 0;
    const SMOOTHNESS_COUNTER_TRACE = 'SmoothnessDroppedFrame';
    const ranges = segments.map((s) => s.boundsRange);
    for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
      if (rendererHelper.compositorThread === undefined) continue;
      const slices = rendererHelper.compositorThread.sliceGroup;
      for (const slice of slices.getDescendantEventsInSortedRanges(ranges)) {
        if (slice.title !== SMOOTHNESS_COUNTER_TRACE) continue;
        if (maxTotal < parseInt(slice.args.total)) {
          maxTotal = parseInt(slice.args.total);
          maxDropped = parseInt(slice.args.smoothness);
        }
      }
    }

    histograms.createHistogram('000smoothness_avg',
        tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
        (maxDropped * 100 / maxTotal),
        {description: 'average dropped frames affecting smoothness',
          summaryOptions: {}});

    const main = findMainRenderer(chromeHelper);
    computeAvgSmoothness(histograms, main);

    const MIN_WINDOW_LENGTH = 1000;
    const MAX_WINDOW_LENGTH = 1000;
    const WINDOW_STEP = 500;
    for (let windowLength = MIN_WINDOW_SIZE; windowLength <= MAX_WINDOW_SIZE;
      windowLength += WINDOW_STEP) {
      computeMaxSmoothnessOfWindow(histograms, main, windowLength);
    }
  }

  return {
    addSmoothness,
  };
});

</script>
