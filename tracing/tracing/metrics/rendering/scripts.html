<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/base/unit_scale.html">
<link rel="import" href="/tracing/metrics/rendering/cpu_utilization.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/user_model/segment.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

/**
 */
tr.exportTo('tr.metrics.rendering', function() {
  function addScriptHistograms(histograms, model, segments) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (!chromeHelper) return;

    let targetRenderers = chromeHelper.telemetryHelper.renderersWithIR;
    if (targetRenderers.length === 0) {
      targetRenderers = Object.values(chromeHelper.rendererHelpers);
    }

    const metrics = {
      'RunDispatchEvents': {
        data: [],
        arg: 'events',
        desc: 'Dispatch JS events',
        time: [],
        percallback: [],
      },
      'RunrAFCallbacks': {
        data: [],
        arg: 'callbacks',
        desc: 'Run rAF callbacks',
        time: [],
        percallback: [],
      },
      'RunMediaQueryListenerCallbacks': {
        data: [],
        arg: 'listeners',
        desc: 'Run media-query listeners',
        time: [],
        percallback: [],
      },
      'RunTasks': {
        data: [],
        arg: 'tasks',
        desc: 'Tasks',
        time: [],
        percallback: [],
      },
    };

    for (const rendererHelper of targetRenderers) {
      const mainThread = rendererHelper.mainThread;
      if (!mainThread) continue;
      mainThread.sliceGroup.slices.forEach(slice => {
        if (!(slice.title in metrics)) return;
        if (!slice.args || !slice.args.scroll_in_progress) return;
        const p = slice.args[metrics[slice.title].arg];
        metrics[slice.title].data.push(p);
        if (p) {
          metrics[slice.title].time.push(slice.duration);
          metrics[slice.title].percallback.push(slice.duration / p);
        }
      });
    }

    for (const metric in metrics) {
      histograms.createHistogram(
          'script:count:' + metric,
          tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
          metrics[metric].data, {
            description: metrics[metric].desc,
            binBoundaries: tr.v.HistogramBinBoundaries.createLinear(0, 10, 10),
            summaryOptions: tr.metrics.rendering.SUMMARY_OPTIONS,
          });
      histograms.createHistogram(
          'script:duration:' + metric,
          tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
          metrics[metric].time, {
            description: 'Duration: ' + metrics[metric].desc,
            binBoundaries: tr.v.HistogramBinBoundaries.createLinear(0, 10, 30),
            summaryOptions: tr.metrics.rendering.SUMMARY_OPTIONS,
          });
      histograms.createHistogram(
          'script:single:' + metric,
          tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
          metrics[metric].percallback, {
            description: 'Per callback expense: ' + metrics[metric].desc,
            binBoundaries: tr.v.HistogramBinBoundaries.createLinear(0, 10, 30),
            summaryOptions: tr.metrics.rendering.SUMMARY_OPTIONS,
          });
    }
  }

  return {
    addScriptHistograms
  };
});
</script>
