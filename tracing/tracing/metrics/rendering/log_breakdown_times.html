<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/base/unit_scale.html">
<link rel="import" href="/tracing/metrics/rendering/cpu_utilization.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/user_model/segment.html">
<link rel="import" href="/tracing/value/diagnostics/generic_set.html">
<link rel="import" href="/tracing/value/diagnostics/related_event_set.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
    'use strict';
    tr.exportTo('tr.metrics.rendering', function() {
      function addBreakdownTimes(histograms, model, segments) {
        const chromeHelper = model.getOrCreateHelper(
            tr.model.helpers.ChromeModelHelper);

        let cumulative_latencies = {'BeginImplFrameToSendBeginMainFrame':+0.0,'SendBeginMainFrameToCommit':+0.0,'Commit':+0.0,'EndCommitToActivation':+0.0,
                            'Activation':+0.0,'EndActivateToSubmitCompositorFrame':+0.0,'SubmitCompositorFrameToPresentationCompositorFrame':+0.0,
                                };
        let num_complete_pipeline_reporters = 0;
        let pipeline_reporter_latencies = [];

        for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
          let pipeline_reporters = [];
          let all_slices = [];

          if (rendererHelper.compositorThread === undefined) continue;
          const slices = rendererHelper.compositorThread.asyncSliceGroup.slices;
          for (const slice of slices) {            
            if (slice.title !== 'PipelineReporter') continue;
            pipeline_reporters.push(slice);
          }

          pipeline_reporters.sort(function (a, b) {
            if (a.start == b.start) return (a.duration - b.duration);
            return (a.start - b.start);
          });
        
          
          let total_pipeline_reporters = 0;                   

          for (const pr of pipeline_reporters) {
            total_pipeline_reporters += 1;
            let CFR = pr.args.chrome_frame_reporter;
            
            if (pr.subSlices.some(e => e.title === 'BeginImplFrameToSendBeginMainFrame') && 
                pr.subSlices.some(e => e.title === 'EndActivateToSubmitCompositorFrame') &&
                pr.subSlices.some(e => e.title === 'SubmitCompositorFrameToPresentationCompositorFrame')){                
                num_complete_pipeline_reporters += 1;  
                let stage_latencies = Object.assign({}, ...pr.subSlices.map((x) => ({[x.title]: x.duration})));
                let skipped_stages = Object.keys(cumulative_latencies).filter(f => !(Object.keys(stage_latencies)).includes(f));
                let skipped_stages_latencies = Object.assign({}, ...skipped_stages.map((x) => ({[x]: 0})));
                let stage_latency_data = Object.assign({},stage_latencies,skipped_stages_latencies);
                
                for(var stage in stage_latency_data){
                    cumulative_latencies[stage] = cumulative_latencies[stage]+stage_latency_data[stage];                }
                pipeline_reporter_latencies.push(stage_latency_data);
                }
          }                    
        }
        for(var stage in cumulative_latencies){
            cumulative_latencies[stage] /= num_complete_pipeline_reporters;
          }          
          //console.log(JSON.stringify(cumulative_latencies));
      }

      return {
        addBreakdownTimes,
      };
    });
</script>