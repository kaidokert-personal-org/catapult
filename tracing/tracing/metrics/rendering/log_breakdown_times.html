<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/base/unit_scale.html">
<link rel="import" href="/tracing/metrics/rendering/cpu_utilization.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/user_model/segment.html">
<link rel="import" href="/tracing/value/diagnostics/generic_set.html">
<link rel="import" href="/tracing/value/diagnostics/related_event_set.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
    'use strict';
    tr.exportTo('tr.metrics.rendering', function() {
      function addBreakdownTimes(histograms, model, segments) {
        const chromeHelper = model.getOrCreateHelper(
            tr.model.helpers.ChromeModelHelper);

        let all_stage_names = ['BeginImplFrameToSendBeginMainFrame','SendBeginMainFrameToCommit','Commit','EndCommitToActivation',
                            'Activation','EndActivateToSubmitCompositorFrame','SubmitCompositorFrameToPresentationCompositorFrame',
                        ]

        for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
          let pipeline_reporters = [];
          let all_slices = [];

          if (rendererHelper.compositorThread === undefined) continue;
          const slices = rendererHelper.compositorThread.asyncSliceGroup.slices;
          for (const slice of slices) {            
            if (slice.title !== 'PipelineReporter') continue;
            pipeline_reporters.push(slice);
          }

          pipeline_reporters.sort(function (a, b) {
            if (a.start == b.start) return (a.duration - b.duration);
            return (a.start - b.start);
          });
        
          let num_complete_pipeline_reporters = 0;
          let total_pipeline_reporters = 0;

          let pipeline_reporters_latency_data = [];          
          
          for (const pr of pipeline_reporters) {
            total_pipeline_reporters += 1;
            let CFR = pr.args.chrome_frame_reporter;
            let stages = [];

            let has_begin_impl_frame_to_send_begin_main_frame = false;
            let has_end_activate_to_submit_compositor_frame = false;
            let has_submit_compositor_frame_to_presentation_compositor_frame = false;
            
            if (pr.subSlices.some(e => e.title === 'BeginImplFrameToSendBeginMainFrame') && 
                pr.subSlices.some(e => e.title === 'EndActivateToSubmitCompositorFrame') &&
                pr.subSlices.some(e => e.title === 'SubmitCompositorFrameToPresentationCompositorFrame')){                
                num_complete_pipeline_reporters += 1;  

                let stage_latencies = Object.assign({}, ...pr.subSlices.map((x) => ({[x.title]: x.duration})));
                let skipped_stages = all_stage_names.filter(f => !(Object.keys(stage_latencies)).includes(f));
                let skipped_stages_latencies = Object.assign({}, ...skipped_stages.map((x) => ({[x]: 0})));
                let stage_latency_data = Object.assign({},stage_latencies,skipped_stages_latencies);
                pipeline_reporters_latency_data.push(stage_latency_data);
                //console.log(JSON.stringify(stage_latency_data));
                }          
          }
          //console.log(num_complete_pipeline_reporters);

        }
      }

      return {
        addBreakdownTimes,
      };
    });
</script>