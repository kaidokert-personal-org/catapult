<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/value/diagnostics/breakdown.html">

<script>
'use strict';

/**
 * @fileoverview This file contains implementations of the following metrics.
 *
 * TODO(crbug.com/872334): document pipeline:* metrics here.
 */
tr.exportTo('tr.metrics.rendering', function() {
  function eventIsValidGraphicsEvent_(event, eventMap) {
    if (event.title !== 'Graphics.Pipeline' || !event.bindId || !event.args ||
        !event.args.step) {
      return false;
    }
    const bindId = event.bindId;
    if (eventMap.has(bindId) && event.args.step in eventMap.get(bindId)) {
      // It is possible for a client to submit multiple compositor frames for
      // one begin-message. So most steps can be present multiple times.
      // However, a begin-frame is issued only once, and received only once. So
      // these steps should not be repeated.
      if (event.args.step === 'IssueBeginFrame' ||
          event.args.step === 'ReceiveBeginFrame') {
        throw new Error('Unexpected duplicate step: ' + event.args.step);
      }
      return false;
    }
    return true;
  }

  function generateBreakdownForCompositorPipelineInClient_(flow) {
    const breakdown = new tr.v.d.Breakdown();
    breakdown.set('time before GenerateRenderPass',
        flow.GenerateRenderPass.start - flow.ReceiveBeginFrame.start);
    breakdown.set('GenerateRenderPass duration',
        flow.GenerateRenderPass.duration);
    breakdown.set('GenerateCompositorFrame duration',
        flow.GenerateCompositorFrame.duration);
    breakdown.set('SubmitCompositorFrame duration',
        flow.SubmitCompositorFrame.duration);
    return breakdown;
  }

  function generateBreakdownForCompositorPipelineInService_(flow) {
    const breakdown = new tr.v.d.Breakdown();
    breakdown.set('Processing CompositorFrame on reception',
        flow.ReceiveCompositorFrame.duration);
    breakdown.set('Delay before SurfaceAggregation',
        flow.SurfaceAggregation.start - flow.ReceiveCompositorFrame.end);
    breakdown.set('SurfaceAggregation duration',
        flow.SurfaceAggregation.duration);
    return breakdown;
  }

  function generateBreakdownForDraw_(drawEvent) {
    const breakdown = new tr.v.d.Breakdown();
    for (const slice of drawEvent.subSlices) {
      breakdown.set(slice.title, slice.duration);
    }
    return breakdown;
  }

  function getDisplayCompositorThread_(model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const gpuHelper = chromeHelper.gpuHelper;
    if (gpuHelper) {
      const thread =
          gpuHelper.process.findAtMostOneThreadNamed('VizCompositorThread');
      if (thread) {
        return thread;
      }
    }
    if (!chromeHelper.browserProcess) return null;
    return chromeHelper.browserProcess.findAtMostOneThreadNamed(
        'CrBrowserMain');
  }

  function getRasterTaskTimes(sourceFrameNumber, model) {
    const modelHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);

    const renderers = modelHelper.telemetryHelper.renderersWithIR;
    if (renderers.length === 0) return;
    const rasterThreads = renderers[0].rasterWorkerThreads;

    let earliestStart = undefined;
    let lastEnd = undefined;
    for (const rasterThread of rasterThreads) {
      for (const slice of [...rasterThread.
          findTopmostSlicesNamed('TaskGraphRunner::RunTask')]) {
        if (slice.args &&
            slice.args.source_frame_number_ &&
            slice.args.source_frame_number_ === sourceFrameNumber) {
          if (earliestStart === undefined || slice.start < earliestStart) {
            earliestStart = slice.start;
          }
          if (lastEnd === undefined || slice.end > lastEnd) {
            lastEnd = slice.end;
          }
        }
      }
    }
    return {start: earliestStart, end: lastEnd};
  }

  function addPipelineHistograms(histograms, model, segments) {
    const ranges = segments.map(s => s.boundsRange);
    const bindEvents = new Map();
    for (const thread of model.getAllThreads()) {
      for (const event of thread.sliceGroup.childEvents()) {
        if (!eventIsValidGraphicsEvent_(event, bindEvents)) continue;
        for (const range of ranges) {
          if (range.containsExplicitRangeInclusive(event.start, event.end)) {
            if (!bindEvents.has(event.bindId)) bindEvents.set(event.bindId, {});
            break;
          }
        }
        if (bindEvents.has(event.bindId)) {
          bindEvents.get(event.bindId)[event.args.step] = event;
        }
      }
    }

    const dcThread = getDisplayCompositorThread_(model);
    const drawEvents = {};
    if (dcThread) {
      const events =
          [...dcThread.findTopmostSlicesNamed('Graphics.Pipeline.DrawAndSwap')];
      for (const segment of segments) {
        const filteredEvents = segment.boundsRange.filterArray(events,
            evt => evt.start);
        for (const event of filteredEvents) {
          if ((event.args && event.args.status === 'canceled') ||
              !event.id.startsWith(':ptr:')) {
            continue;
          }
          const id = parseInt(event.id.substring(5), 16);
          if (id in drawEvents) {
            throw new Error('Duplicate draw events: ' + id);
          }
          drawEvents[id] = event;
        }
      }
    }
  }

  return {
    addPipelineHistograms,
  };
});
</script>
