<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/model/async_slice_group.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

/**
 * @fileoverview This file contains implementations of the following metrics.
 *
 * input_event_latency_tbmv2
 * =========================
 * The distribution of durations between the time when an input event is
 * generated to the time when the GPU service swaps buffers due to the input
 * event. The time when an input is generated is the first of the following
 * three timestamps that we can get:
 *
 * 1. Original kernel timestamp of the input event.
 * 2. Timestamp when the UI event is created.
 * 3. Timestamp when the input event is sent from RenderWidgetHost to the
 *    renderer.
 *
 * main_thread_scroll_latency_tbmv2
 * ================================
 * The distribution of durations between the time when the main thread scroll
 * listener update is begun to the time when the GPU service swaps buffers due
 * to the scroll event.
 */
tr.exportTo('tr.metrics.rendering', function() {
  // LatencyInfo component names that show when the input event first reaches
  // Chrome.
  const BEGIN_COMP_NAME = 'INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT';
  const BEGIN_SCROLL_UPDATE_COMP_NAME =
      'LATENCY_BEGIN_SCROLL_LISTENER_UPDATE_MAIN_COMPONENT';
  const ORIGINAL_COMP_NAME = 'INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT';
  const UI_COMP_NAME = 'INPUT_EVENT_LATENCY_UI_COMPONENT';

  const END_COMP_NAME = 'INPUT_EVENT_GPU_SWAP_BUFFER_COMPONENT';

  function computeLatencies_(processHelpers, eventPrefix, ranges) {
    const latencies = [];
    for (const processHelper of processHelpers) {
      const process = processHelper.process;
      for (const event of process.getDescendantEventsInSortedRanges(
          ranges, container => container instanceof tr.model.AsyncSliceGroup)) {
        if (event.title.startsWith(eventPrefix) && event.args &&
            event.args.data && END_COMP_NAME in event.args.data) {
          const data = event.args.data;
          const endTime = data[END_COMP_NAME].time;
          let startTime;
          if (ORIGINAL_COMP_NAME in data) {
            startTime = data[ORIGINAL_COMP_NAME].time;
          } else if (UI_COMP_NAME in data) {
            startTime = data[UI_COMP_NAME].time;
          } else if (BEGIN_COMP_NAME in data) {
            startTime = data[BEGIN_COMP_NAME].time;
          } else if (BEGIN_SCROLL_UPDATE_COMP_NAME in data) {
            startTime = data[BEGIN_SCROLL_UPDATE_COMP_NAME].time;
          } else {
            throw new Error('LatencyInfo has no begin component');
          }
          latencies.push((endTime - startTime) / 1000);
        }
      }
    }
    return latencies;
  }

  function addLatencyHistograms(histograms, model, segments) {
    const modelHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (!modelHelper) return;

    const ranges = segments.map(s => s.boundsRange);
    const inputEventLatencies = computeLatencies_(
        modelHelper.browserHelpers, 'InputLatency', ranges);
    histograms.createHistogram(
        'input_event_latency_tbmv2',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        inputEventLatencies,
        { binBoundaries: tr.v.HistogramBinBoundaries.createLinear(0, 50, 20),
          description: 'Input event latencies.' });

    const mainThreadScrollLatencies = computeLatencies_(
        Object.values(modelHelper.rendererHelpers), 'Latency::ScrollUpdate',
        ranges);
    histograms.createHistogram(
        'main_thread_scroll_latency_tbmv2',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        mainThreadScrollLatencies,
        { binBoundaries: tr.v.HistogramBinBoundaries.createLinear(0, 50, 50),
          description: 'Main thread scroll latencies.' });
  }

  return {
    addLatencyHistograms,
  };
});
</script>
