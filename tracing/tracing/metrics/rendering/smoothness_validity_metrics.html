<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/base/unit_scale.html">
<link rel="import" href="/tracing/metrics/rendering/cpu_utilization.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/user_model/segment.html">
<link rel="import" href="/tracing/value/diagnostics/generic_set.html">
<link rel="import" href="/tracing/value/diagnostics/related_event_set.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
    'use strict';
    
    tr.exportTo('tr.metrics.rendering', function() {
      function findMainRenderer(chromeHelper) {
        for (const r of Object.values(chromeHelper.rendererHelpers)) {
          if (!r.mainThread) continue;
          if (!r.compositorThread) continue;
          for (const slice of r.mainThread.asyncSliceGroup.slices) {
            if (slice.title === 'first-renderer-thread') return r;
          }
        }
        return undefined;
      }
    
    //   function computeAvgSmoothness(histograms, slices) {
    //     let totalVisibleDuration = 0;
    //     const allDropped = new Set();
    //     for (const slice of slices) {
    //       if (slice.title === 'PipelineReporter') {
    //         if (slice.args && slice.args.chrome_frame_reporter.affects_smoothness) {
    //           allDropped.add(slice.args.chrome_frame_reporter.frame_sequence);
    //         }
    //       } else if (slice.title === 'NeedsBeginFrames') {
    //         totalVisibleDuration += slice.duration;
    //       }
    //     }
    //     const totalDropped = allDropped.size;
    //     const totalVsyncs = totalVisibleDuration / 16.667;
    
    //     histograms.createHistogram('02_smoothness_avg_trace',
    //         tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
    //         (totalDropped * 100 / totalVsyncs),
    //         {description: 'average dropped frames affecting smoothness',
    //           summaryOptions: {}});
    //   }
    
    //   function computeMaxSmoothnessOfWindow(histograms, slices, windowLength) {
    //     const queue = [];
    //     const allDropped = new Set();
    //     let totalDropped = 0;
    //     let canReport = false;
    
    //     for (const slice of slices) {
    //       if (slice.title === 'PipelineReporter' && slice.args) {
    //         if (allDropped.has(slice.args.chrome_frame_reporter.frame_sequence)) {
    //           continue;
    //         }
    //         allDropped.add(slice.args.chrome_frame_reporter.frame_sequence);
    
    //         while (queue.length > 0 &&
    //             queue[0].startTime + windowLength < slice.start) {
    //           if (!canReport) {
    //             canReport = true;
    //             const percentDropped = (totalDropped * 100) / queue.length;
    //             reportSmoothnessRW(histograms, percentDropped, windowLength);
    //           }
    
    //           // Remove one element from the queue
    //           const front = queue.shift();
    //           if (front.dropped === true) {
    //             totalDropped -= 1;
    //           }
    //         }
    
    //         let isDropped = false;
    //         if (slice.args.chrome_frame_reporter.affects_smoothness) {
    //           isDropped = true;
    //           totalDropped += 1;
    //         } else if (
    //           slice.args.chrome_frame_reporter.state !== 'STATE_PRESENTED_ALL') {
    //           continue;
    //         }
    
    //         queue.push({
    //           'dropped': isDropped,
    //           'startTime': slice.start
    //         });
    
    //         if (canReport) {
    //           const percentDropped = (totalDropped * 100) / queue.length;
    //           reportSmoothnessRW(histograms, percentDropped, windowLength);
    //           const name = (windowLength < 1000) ? '01_frames_in_queue_0' :
    //             '01_frames_in_queue_';
    //           histograms.createHistogram(
    //               name + windowLength + '_ms',
    //               tr.b.Unit.byName.unitlessNumber_smallerIsBetter, queue.length,
    //               {description: 'Number frames in the rolling window of length ' +
    //               windowLength + 'ms', summaryOptions: {}});
    //         }
    //       }
    //     }
    //   }
    
    //   function reportSmoothnessRW(histograms, percentDropped, windowLength) {
    //     const name = (windowLength < 1000) ? '00_smoothness_rolling_window_0' :
    //       '00_smoothness_rolling_window_';
    //     histograms.createHistogram(
    //         name + windowLength + '_ms',
    //         tr.b.Unit.byName.unitlessNumber_smallerIsBetter, percentDropped,
    //         {description: 'percentage of dropped frames affecting' +
    //           'smoothness in the window of length ' + windowLength + 'ms',
    //         summaryOptions: {}});
    //   }
    
      function addSmoothnessValidity(histograms, model, segments) {
        const chromeHelper = model.getOrCreateHelper(
            tr.model.helpers.ChromeModelHelper);
        let invalidPipelineReporters = 0;

        const ranges = segments.map((s) => s.boundsRange);
        for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
          if (rendererHelper.compositorThread === undefined) continue;
          const slices = rendererHelper.compositorThread.sliceGroup;
          for (const slice of slices.getDescendantEventsInSortedRanges(ranges)) {
            if (slice.title !== 'FrameSequenceTracker') continue;
            invalidPipelineReporters += 1;
          }
        }
    
        histograms.createHistogram('000_invalid_reporters',
            tr.b.Unit.byName.unitlessNumber_smallerIsBetter,
            invalidPipelineReporters,
            {description: 'Number of reporters which are invalid',
              summaryOptions: {}});
    
        // const main = findMainRenderer(chromeHelper);
        // if (main) {
        //   const slices = main.compositorThread.asyncSliceGroup.slices;
        //   slices.sort(function(a, b) {
        //     const distance = a.start - b.start;
        //     if (distance === 0 && a.title === 'PipelineReporter' && a.args &&
        //       b.args && a.args.chrome_frame_reporter.frame_sequence ===
        //       b.args.chrome_frame_reporter.frame_sequence) {
        //       if (a.args.chrome_frame_reporter.affects_smoothness) {
        //         return -1;
        //       } else if (b.args.chrome_frame_reporter.affects_smoothness) {
        //         return 1;
        //       }
        //     }
        //     return distance;
        //   });
    
        //   computeAvgSmoothness(histograms, slices);
    
        //   const WINDOW_LENGTHS = [100, 300, 500, 1000, 1500, 2000, 3000];
        //   for (const windowLength of WINDOW_LENGTHS) {
        //     computeMaxSmoothnessOfWindow(histograms, slices, windowLength);
        //   }
        // }
      }
    
      return {
        addSmoothnessValidity,
      };
    });
    
    </script>