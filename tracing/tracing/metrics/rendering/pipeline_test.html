<!DOCTYPE html>
<!--
Copyright 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/core/test_utils.html">
<link rel="import" href="/tracing/metrics/rendering/pipeline.html">
<link rel="import" href="/tracing/model/user_model/segment.html">
<link rel="import" href="/tracing/value/histogram_set.html">

<script>
'use strict';

tr.b.unittest.testSuite(function() {
  function addPipelineForOneFrame(compositor, renderer, rasterWorker,
      id, frame, displayTrace) {
    const EVENT_NAME = 'Graphics.Pipeline';
    if (frame.IssueBeginFrame) {
      compositor.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
          { title: EVENT_NAME,
            start: frame.IssueBeginFrame, duration: 1, bindId: id,
            args: {step: 'IssueBeginFrame'}}));
    }
    if (frame.ReceiveBeginFrame) {
      renderer.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
          { title: EVENT_NAME,
            start: frame.ReceiveBeginFrame, duration: 1, bindId: id,
            args: {step: 'ReceiveBeginFrame'}}));
    }
    renderer.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
        { title: EVENT_NAME,
          start: frame.GenerateRenderPass, duration: 1, bindId: id,
          args: {step: 'GenerateRenderPass'}}));
    renderer.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
        { title: EVENT_NAME,
          start: frame.GenerateCompositorFrame, duration: 1, bindId: id,
          args: {step: 'GenerateCompositorFrame'}}));
    renderer.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
        { title: EVENT_NAME,
          start: frame.SubmitCompositorFrame, duration: 1, bindId: id,
          args: {source_frame_number_: id}}));
    renderer.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
        { title: EVENT_NAME,
          start: frame.SubmitCompositorFrame, duration: 1, bindId: id,
          args: {step: 'SubmitCompositorFrame'}}));
    compositor.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
        { title: EVENT_NAME,
          start: frame.ReceiveCompositorFrame, duration: 1, bindId: id,
          args: {step: 'ReceiveCompositorFrame'}}));
    compositor.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
        { title: EVENT_NAME,
          start: frame.SurfaceAggregation, duration: 1, bindId: id,
          args: {step: 'SurfaceAggregation', display_trace: displayTrace}}));
    renderer.sliceGroup.createSubSlices();
    rasterWorker.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx(
        { title: 'TaskGraphRunner::RunTask',
          start: frame.rasterTaskStart, duration: 6, bindId: id,
          args: {source_frame_number_: id}}));
  }

  function addDrawSlice(compositor, displayTrace, start, steps, opt_args) {
    const EVENT_NAME = 'Graphics.Pipeline.DrawAndSwap';
    let totalDuration = 0;
    for (const duration of Object.values(steps)) {
      totalDuration += duration;
    }
    const slice = tr.c.TestUtils.newAsyncSliceNamed(
        EVENT_NAME, start, totalDuration);
    slice.id = ':ptr:' + displayTrace;
    slice.args = opt_args;
    compositor.sliceGroup.pushSlice(slice);
    totalDuration = 0;
    for (const step in steps) {
      slice.subSlices.push(tr.c.TestUtils.newAsyncSliceNamed(
          step, start + totalDuration, steps[step]));
      totalDuration += steps[step];
    }
  }
});
</script>
