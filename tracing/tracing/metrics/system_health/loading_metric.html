<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">
<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html"
<link rel="import" href="/tracing/extras/chrome/time_to_interactive.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/helpers/chrome_thread_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/histogram.html">
<script>
'use strict';
tr.exportTo('tr.metrics.sh', function() {
  const RESPONSIVENESS_THRESHOLD_MS = 50;
  const LONG_TASK_THRESHOLD_MS = 50;
  const INTERACTIVE_WINDOW_SIZE_MS = 5 * 1000;
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const RelatedEventSet = tr.v.d.RelatedEventSet;
  const hasCategoryAndName = tr.metrics.sh.hasCategoryAndName;
  const EventFinderUtils = tr.metrics.sh.EventFinderUtils;
  /**
   * @param  {!tr.model.Process} process
   * @param  {!tr.b.math.Range} range
   * @return {Array.<tr.model.Event>} An array of network events of a process
   * and that are intersecting a range.
   */
  function getNetworkEventsInRange(process, range) {
    const networkEvents = [];
    for (const thread of Object.values(process.threads)) {
      const threadHelper = new tr.model.helpers.ChromeThreadHelper(thread);
      const events = threadHelper.getNetworkEvents();
      for (const event of events) {
        if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
          networkEvents.push(event);
        }
      }
    }
    return networkEvents;
  }
  /**
   * Returns ResourceLoad async slices for a renderer. They are available in the
   * a trace when disabled-by-default-network category is enabled.
   *
   * TODO: Fill in these params
   * @param{rendererHelper}
   * @returns{some async slice group}
   */
  function getResourceLoadEventsForRenderer(rendererHelper) {
    const mainThreadAsyncSlices =
          [...rendererHelper.mainThread.asyncSliceGroup.getDescendantEvents()];
    return mainThreadAsyncSlices.filter(
      slice => slice.title === 'ResourceLoad');
  }
  /**
   * @param {!Object.<string, Object>} breakdownTree
   * @return {tr.v.d.Breakdown} A breakdown with categories and the total time
   * (ms) spent under each category.
   */
  function createBreakdownDiagnostic(breakdownTree) {
    const breakdownDiagnostic = new tr.v.d.Breakdown();
    breakdownDiagnostic.colorScheme =
        tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;
    for (const label in breakdownTree) {
      breakdownDiagnostic.set(label, breakdownTree[label].total);
    }
    return breakdownDiagnostic;
  }
  /**
   * A utility class for finding navigationStart event for given frame and
   * timestamp.
   * @constructor
   */
  function NavigationStartFinder(rendererHelper) {
    this.navigationStartsForFrameId_ = {};
    for (const ev of rendererHelper.mainThread.sliceGroup.childEvents()) {
      if (!hasCategoryAndName(ev, 'blink.user_timing', 'navigationStart')) {
        continue;
      }
      const frameIdRef = ev.args.frame;
      let list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) {
        this.navigationStartsForFrameId_[frameIdRef] = list = [];
      }
      list.unshift(ev);
    }
  }
  NavigationStartFinder.prototype = {
    // Assuming navigationStarts has been sorted in descending order.
    findLastNavigationStartEventForFrameBeforeTimestamp(frameIdRef, ts) {
      const list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) return undefined;
      for (const ev of list) {
        if (ev.start > ts) continue;
        return ev;
      }
      return undefined;
    },
    findNextNavigationStartEventForFrameAfterTimestamp(frameIdRef, ts) {
      const list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) return undefined;
      for (let i = list.length - 1; i >= 0; i--) {
        const ev = list[i];
        if (ev.start > ts) return ev;
      }
      return undefined;
    },
    findAllNavigationStartsForFrame() {
      return this.navigationStartsForFrameId_;
    }
  };
  const FIRST_PAINT_BOUNDARIES = tr.v.HistogramBinBoundaries
    .createLinear(0, 1e3, 20)  // 50ms step to 1s
    .addLinearBins(3e3, 20) // 100ms step to 3s
    .addExponentialBins(20e3, 20);
  function createHistogram(name, description) {
    const histogram = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, FIRST_PAINT_BOUNDARIES);
    histogram.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: true,
      std: true,
      sum: false,
    });
    histogram.description = description;
    return histogram;
  }
  function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
    const objects = rendererHelper.process.objects;
    const frameLoaderInstances = objects.instancesByTypeName_.FrameLoader;
    if (frameLoaderInstances === undefined) return undefined;
    let snapshot;
    for (const instance of frameLoaderInstances) {
      if (!instance.isAliveAt(ts)) continue;
      const maybeSnapshot = instance.getSnapshotAt(ts);
      if (frameIdRef !== maybeSnapshot.args.frame.id_ref) continue;
      snapshot = maybeSnapshot;
    }
    return snapshot;
  }
  function findAllEvents(rendererHelper, category, title) {
    const targetEvents = [];
    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, category, title)) continue;
      targetEvents.push(ev);
    }
    return targetEvents;
  }
  function findFirstMeaningfulPaintCandidates(rendererHelper) {
    const candidatesForFrameId = {};
    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, 'loading', 'firstMeaningfulPaintCandidate')) {
        continue;
      }
      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
      const frameIdRef = ev.args.frame;
      if (frameIdRef === undefined) continue;
      let list = candidatesForFrameId[frameIdRef];
      if (list === undefined) {
        candidatesForFrameId[frameIdRef] = list = [];
      }
      list.push(ev);
    }
    return candidatesForFrameId;
  }
  const URL_BLACKLIST = [
    'about:blank',
    // Chrome on Android creates main frames with the below URL for plugins.
    'data:text/html,pluginplaceholderdata',
    // Special URL used to start a navigation to an unreachable error page.
    'data:text/html,chromewebdata',
    'chrome-error://chromewebdata/'
  ];
  function shouldIgnoreURL(url) {
    return URL_BLACKLIST.includes(url);
  }
  function collectTimeMarkers(
      category, eventName, rendererHelper, navigationStartFinder) {
    const targetEvents = findAllEvents(rendererHelper, category, eventName);
    const markers = [];
    for (const ev of targetEvents) {
      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
      const frameIdRef = ev.args.frame;
      const navigationStart = navigationStartFinder.
        findLastNavigationStartEventForFrameBeforeTimestamp(
          frameIdRef, ev.start);
      // Ignore layout w/o preceding navigationStart, as they are not
      // attributed to any time-to-X metric.
      if (navigationStart === undefined) continue;
      pushUnlessIgnored(markers, ev, rendererHelper, frameIdRef,
          navigationStart, eventName);
    }
    return markers;
  }
  function collectNavigationStartMarkers(rendererHelper,
      navigationStartFinder) {
    const navStartsByFrame =
        navigationStartFinder.findAllNavigationStartsForFrame();
    const markersByFrame = new Map();
    for (const frameIdRef of navStartsByFrame.keys()) {
      const navStarts = navStartsByFrame[frameIdRef];
      const markers = [];
      markersByFrame.set(frameIdRef, markers);
      for (const navStartEvent of navStartsByFrame[frameIdRef]) {
        markers.push({
          eventName: 'nav',
          event: navStartEvent,
          frameIdRef,
        });
      }
    }
    return markersByFrame;
  }
  function pushUnlessIgnored(markers, markerEvent, rendererHelper, frameIdRef,
      navigationStart, eventName) {
    const snapshot = findFrameLoaderSnapshotAt(
        rendererHelper, frameIdRef, markerEvent.start);
    if (!snapshot || !snapshot.args.isLoadingMainFrame) return;
    const url = snapshot.args.documentLoaderURL;
    if (shouldIgnoreURL(url)) return;
    markers.push({
      eventName,
      event: markerEvent,
      navigationStart,
      frameIdRef,
      url
    });
  }
  /**
   * Find the first meaningful paints (FMP) for a renderer represented by
   * |rendererHelper| and returns them as markers indicating the time, frame,
   * url and the corresponding navigation start.
   *
   * First meaningful paint is the paint following the layout with the highest
   * "Layout Significance". The Layout Significance is computed inside Blink,
   * by FirstMeaningfulPaintDetector class. It logs
   * "firstMeaningfulPaintCandidate" event every time the Layout Significance
   * marks a record. TTFMP is the time between NavigationStart and the last
   * firstMeaningfulPaintCandidate event.
   *
   * Design doc: https://goo.gl/vpaxv6
   */
  function findFirstMeaningfulPaintMarkers(rendererHelper,
      navigationStartFinder) {
    const candidatesForFrameId =
        findFirstMeaningfulPaintCandidates(rendererHelper);
    const fmpMarkers = [];
    for (const frameIdRef in candidatesForFrameId) {
      let navigationStart = undefined;
      let lastCandidate = undefined;
      // Iterate over the FMP candidates, remembering the last one.
      // It records all the adjacent (NS,FMP) pairs in situations like:
      // FMP(discard)->NS->FMP(discard)->FMP->NS(ignore)->NS->FMP
      for (const ev of candidatesForFrameId[frameIdRef]) {
        const navigationStartForThisCandidate = navigationStartFinder.
          findLastNavigationStartEventForFrameBeforeTimestamp(
            frameIdRef, ev.start);
        // Ignore candidate w/o preceding navigationStart, as they are not
        // attributed to any TTFMP.
        if (navigationStartForThisCandidate === undefined) continue;
        if (navigationStart !== navigationStartForThisCandidate) {
          // New navigation is found. Compute TTFMP for current navigation,
          // and reset the state variables.
          if (navigationStart !== undefined && lastCandidate !== undefined) {
            pushUnlessIgnored(fmpMarkers, lastCandidate, rendererHelper,
                frameIdRef, navigationStart, 'firstMeaningfulPaint');
          }
          navigationStart = navigationStartForThisCandidate;
        }
        lastCandidate = ev;
      }
      // Compute TTFMP for the last navigation.
      pushUnlessIgnored(fmpMarkers, lastCandidate, rendererHelper, frameIdRef,
          navigationStart, 'firstMeaningfulPaint');
    }
    return fmpMarkers;
  }
  function addTimeToInteractiveMarkers(firstInteractiveMarkers,
      consistentlyInteractiveMarkers, rendererHelper, navigationStart,
      firstMeaningfulPaintTime, url, searchWindowEnd,
      domContentLoadedEnd, frameIdRef) {
    if (shouldIgnoreURL(url)) return;
    const domContentLoadedEndTime = domContentLoadedEnd.start;
    const mainThreadTasks =
        [...rendererHelper.mainThread.findTopmostSlicesNamed(
            'TaskQueueManager::ProcessTaskFromWorkQueue')]
    const longTasks = mainThreadTasks.filter(
        task => task.duration >= LONG_TASK_THRESHOLD_MS);
    const longTasksInWindow = longTasks.filter(
        task => task.range.intersectsExplicitRangeInclusive(
            firstMeaningfulPaintTime, searchWindowEnd));
    const resourceLoadEvents = getResourceLoadEventsForRenderer(rendererHelper);
    const firstInteractiveTime =
          tr.metrics.sh.findFirstInteractiveTimestamp(
            firstMeaningfulPaintTime, searchWindowEnd, domContentLoadedEndTime,
            longTasksInWindow);
    const consistentlyInteractiveTime =
        tr.metrics.sh.findConsistentlyInteractiveTimestamp(
            firstMeaningfulPaintTime, searchWindowEnd, domContentLoadedEndTime,
            longTasksInWindow, resourceLoadEvents);
    firstInteractiveMarkers.push({
      eventName: 'firstInteractive',
      // maxlg: FI is an computed event without cpuStart/end.
      event: {
        start: firstInteractiveTime,
        end: firstInteractiveTime
      },
      navigationStart: navigationStart,
      frameIdRef: frameIdRef,
      url: url,
    });
    consistentlyInteractiveMarkers.push({
      eventName: 'consistentlyInteractive',
      // maxlg: FI is an computed event without cpuStart/end.
      event: {
        start: consistentlyInteractiveTime,
        end: consistentlyInteractiveTime
      },
      navigationStart: navigationStart,
      frameIdRef: frameIdRef,
      url: url,
    });
  }
  /**
   * Find the first interactive(FI) for a renderer represented by
   * |rendererHelper| and returns them as markers indicating the time, frame,
   * url and the corresponding navigation start.
   *
   * TTI is computed as the starting time of the timed window with size
   * INTERACTIVE_WINDOW_SIZE_MS that happens after FMP in which there is no
   * uninterruptable task on the main thread with size more than
   * RESPONSIVENESS_THRESHOLD_MS.
   *
   * Design doc: https://goo.gl/ISWndc
   */
  function findInteractiveMarkers(rendererHelper, fmpMarkers,
      navigationStartFinder, domContentLoadedEndFinder) {
    const firstInteractiveMarkers = [];
    const consistentlyInteractiveMarkers = [];
    for (const fmpMarker of fmpMarkers) {
      const currNavigationStart = fmpMarker.navigationStart;
      const frameIdRef = fmpMarker.frameIdRef;
      const firstMeaningfulPaintTime = fmpMarker.event.start;
      const nextNavigationStart = navigationStartFinder.
          findNextNavigationStartEventForFrameAfterTimestamp(
              frameIdRef, firstMeaningfulPaintTime);
      const searchWindowEnd = nextNavigationStart !== undefined ?
          nextNavigationStart.start :
              // If no next navigationStart, search for quiet windows until
              // the end of trace.
              rendererHelper.modelHelper.chromeBounds.max;
      const dclTsInWindow =
          domContentLoadedEndFinder.findDclEndEventsForFrameInWindow(
              frameIdRef, currNavigationStart.start, searchWindowEnd);
      // Cannot determine TTI if DomContentLoadedEnd was never reached.
      if (dclTsInWindow.length === 0) continue;
      // TODO(catapult:#3796): Ideally a frame should reach
      // DomContentLoadedEnd at most once within two navigationStarts, but
      // sometimes there is a strange DclEnd event immediately following the
      // navigationStart, and then the 'real' dclEnd happens later. For now,
      // if there are multiple DclEnd events in the window, we just pick the
      // last one.
      const domContentLoadedEnd = dclTsInWindow[dclTsInWindow.length - 1];
      addTimeToInteractiveMarkers(firstInteractiveMarkers,
          consistentlyInteractiveMarkers, rendererHelper, currNavigationStart,
          firstMeaningfulPaintTime, fmpMarker.url, searchWindowEnd,
          domContentLoadedEnd, frameIdRef);
    }
    return {firstInteractiveMarkers, consistentlyInteractiveMarkers};
    //   const navigationStartTime = fmpMarker.navigationStart.start;
    //   let firstInteractive = Infinity;
    //   let firstInteractiveCandidate = fmpMarker.event.start;
    //   let lastLongTaskEvent = undefined;
    //   // Find the first interactive point X after firstMeaningfulPaint so that
    //   // range [X, X + INTERACTIVE_WINDOW_SIZE_MS] contains no
    //   // 'TaskQueueManager::ProcessTaskFromWorkQueues' slice which takes more
    //   // than RESPONSIVENESS_THRESHOLD_MS.
    //   // For more details on why TaskQueueManager::ProcessTaskFromWorkQueue is
    //   // chosen as a proxy for all un-interruptable task on renderer thread, see
    //   // https://github.com/GoogleChrome/lighthouse/issues/489
    //   // TODO(nedn): replace this with just "const ev of rendererHelper..." once
    //   // canary binary is updated.
    //   // (https://github.com/catapult-project/catapult/issues/2586)
    //   for (const ev of
    //       [...rendererHelper.mainThread.sliceGroup.childEvents()]) {
    //     if (ev.start < firstInteractiveCandidate) continue;
    //     const interactiveDurationSoFar = ev.start - firstInteractiveCandidate;
    //     if (interactiveDurationSoFar >= INTERACTIVE_WINDOW_SIZE_MS) {
    //       firstInteractive = firstInteractiveCandidate;
    //       break;
    //     }
    //     if (ev.title === 'TaskQueueManager::ProcessTaskFromWorkQueue' &&
    //         ev.duration > RESPONSIVENESS_THRESHOLD_MS) {
    //       firstInteractiveCandidate = ev.end - 50;
    //       lastLongTaskEvent = ev;
    //     }
    //   }
    //   markers.push({
    //     eventName: 'firstInteractive',
    //     // maxlg: FI is an computed event without cpuStart/end.
    //     event: {
    //       start: firstInteractive,
    //       end: firstInteractive
    //     },
    //     navigationStart: fmpMarker.navigationStart,
    //     frameIdRef: fmpMarker.frameIdRef,
    //     url: fmpMarker.url,
    //     // maxlg: special for FI.
    //     lastLongTaskEvent
    //   });
    // }
    // return markers;
  }
  function addTimeToSamples(samples, markers) {
    for (const marker of markers) {
      const timeToEvent = marker.event.start - marker.navigationStart.start;
      samples.push({
        value: timeToEvent,
        diagnostics: {url: new tr.v.d.GenericSet([marker.url])}
      });
    }
  }
  function addBreakdownSamples(samples, rendererHelper, browserHelper,
      startEvent, endEvent, frameIdRef, url) {
    const range = tr.b.math.Range.fromExplicitRange(
        startEvent.start, endEvent.start);
    const networkEvents = getNetworkEventsInRange(
        rendererHelper.process, range);
    const otherNetworkEvents = getNetworkEventsInRange(
        browserHelper.process, range);
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents, otherNetworkEvents, range);
    // const breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    samples.push({
      value: range.duration,
      diagnostics: {
        'Breakdown': createBreakdownDiagnostic(breakdownTree),
        'Start': new RelatedEventSet(startEvent),
        'End': new RelatedEventSet(endEvent),
        'Navigation infos': new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: startEvent.start,
          end: endEvent.start
        }]),
      }
    });
  }
  function addCpuBreakdownSamples(samples, rendererHelper, startEvent, endEvent,
      frameIdRef, url) {
    const range = tr.b.math.Range.fromExplicitRange(
        startEvent.start, endEvent.start);
    // maxlg: change to use natural time
    const breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
        rendererHelper.mainThread, range);
    // dproy: Summing up the breakdown values gives a more accurate value for
    // cpu time in range.
    const mainThreadCpuTime = Object.values(breakdownTree)
        .map(v => v.total)
        .reduce((acc, curr) => acc + curr, 0);
    // const breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    samples.push({
      value: mainThreadCpuTime,
      diagnostics: {
        'Breakdown': createBreakdownDiagnostic(breakdownTree),
        'Start': new RelatedEventSet(startEvent),
        'End': new RelatedEventSet(endEvent),
        'Navigation infos': new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: startEvent.start,
          end: endEvent.start
        }]),
      }
    });
  }
  function getMainThreadCpuTime(rendererHelper, wallClockRangeOfInterest) {
    let mainThreadCpuTime = 0;
    for (const slice of rendererHelper.mainThread.sliceGroup.topLevelSlices) {
      if (!slice.cpuDuration) continue;
      const sliceRange = tr.b.math.Range.fromExplicitRange(slice.start,
          slice.start + slice.duration);
      const intersection =
          wallClockRangeOfInterest.findIntersection(sliceRange);
      mainThreadCpuTime +=
          slice.cpuDuration * intersection.duration / sliceRange.duration;
    }
    // for (const topSlice of rendererHelper.mainThread.sliceGroup.topLevelSlices) {
    //   // Hack to get around never closed content::Start slice that eats up all
    //   // top level slices.
    //   // Add self time, but only if the slice actually finished.
    //   // Validate by asserting that the total is the sum of breakdowns.
    //   if (!topSlice.didNotFinish && topSlice.cpuSelfTime) {
    //     const intersection =
    //           wallClockRangeOfInterest.findIntersection(topSlice.range);
    //     mainThreadCpuTime +=
    //         topSlice.cpuSelfTime * intersection.duration / topSlice.duration;
    //   }
    //   // Add next level, but now use total time.
    //   for (const slice of topSlice.subSlices) {
    //     if (!slice.cpuDuration) continue;
    //     const sliceRange = tr.b.math.Range.fromExplicitRange(slice.start,
    //         slice.start + slice.duration);
    //     const intersection =
    //         wallClockRangeOfInterest.findIntersection(sliceRange);
    //     mainThreadCpuTime +=
    //         slice.cpuDuration * intersection.duration / sliceRange.duration;
    //   }
    // }
    return mainThreadCpuTime;
  }
  function capitalizeFirstLetter(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }
  function organizeMarkersByFrameAndNavStart(markerSet) {
    const result = new Map();
    for (const timeMarkers of markerSet) {
      for (const marker of timeMarkers) {
        if (!result.has(marker.frameIdRef)) {
          result.set(marker.frameIdRef, new Map());
        }
        const markersOfFrame = result.get(marker.frameIdRef);
        if (!markersOfFrame.has(marker.navigationStart.start)) {
          markersOfFrame.set(marker.navigationStart.start, []);
        }
        const markersOfFrameAndNav =
            markersOfFrame.get(marker.navigationStart.start);
        markersOfFrameAndNav.push(marker);
      }
    }
    return result;
  }
  class DomContentLoadedEndFinder {
    constructor(rendererHelper) {
      const dclEventsByFrame = new Map();
      for (const ev of rendererHelper.process.getDescendantEvents()) {
        if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
        if (!hasCategoryAndName(ev,
            'blink.user_timing', 'domContentLoadedEventEnd')) {
          continue;
        }
        var frameIdRef = ev.args['frame'];
        if (frameIdRef === undefined) continue;
        if (!dclEventsByFrame.has(frameIdRef)) {
          dclEventsByFrame.set(frameIdRef, []);
        }
        const dclEvents = dclEventsByFrame.get(frameIdRef);
        dclEvents.push(ev);
      }
      this.dclEventsByFrame_ = dclEventsByFrame;
    }
    /**
     * Returns array of DOMContentLoadedEnd event timestamps for |frameIdRef| in
     * the range [windowStart, windowEnd].
     *
     * @param{string} frameIdRef
     * @param{number} windowStart
     * @param{number} windowEnd
     * @returns{Array<!number>}
     */
    findDclEndEventsForFrameInWindow(frameIdRef, windowStart, windowEnd) {
      const dclEndEventsForFrame = this.dclEventsByFrame_.get(frameIdRef);
      if (dclEndEventsForFrame === undefined) return [];
      return dclEndEventsForFrame.filter(ev =>
          windowStart <= ev.start && ev.start <= windowEnd);
    }
  }
  function collectLoadingMetricsForRenderer(rendererHelper, browserHelper) {
    const navigationStartFinder = new NavigationStartFinder(rendererHelper);
    const domContentLoadedEndFinder =
        new DomContentLoadedEndFinder(rendererHelper);
    // Collect or find event markers.
    const firstContentfulPaintMarkers = collectTimeMarkers(
        'loading', 'firstContentfulPaint',
        rendererHelper, navigationStartFinder);
    const onLoadMarkersFromAllFrames = collectTimeMarkers(
        'blink.user_timing', 'loadEventStart',
        rendererHelper, navigationStartFinder);
    const firstPaintMarkersFromAllFrames = collectTimeMarkers(
        'loading', 'firstPaint',
        rendererHelper, navigationStartFinder);
    const firstMeaningfulPaintMarkers = findFirstMeaningfulPaintMarkers(
        rendererHelper, navigationStartFinder);
    // We're hoping there's a single FMP sample, and we're grabbing its frameId.
    let frameIdOfInterest;
    if (firstMeaningfulPaintMarkers.length === 1) {
      frameIdOfInterest = firstMeaningfulPaintMarkers[0].frameIdRef;
    } else {
      // No point continuing.
      return [];
    }
    const onLoadMarkers = onLoadMarkersFromAllFrames.filter(
        event => event.frameIdRef === frameIdOfInterest);
    const firstPaintMarkers = firstPaintMarkersFromAllFrames.filter(
        event => event.frameIdRef === frameIdOfInterest);
    const {firstInteractiveMarkers, consistentlyInteractiveMarkers} =
        findInteractiveMarkers(rendererHelper, firstMeaningfulPaintMarkers,
            navigationStartFinder, domContentLoadedEndFinder);
    // Pairwise breakdown:
    const markersByFrameAndNavStart = organizeMarkersByFrameAndNavStart([
      firstPaintMarkers,
      firstContentfulPaintMarkers,
      firstMeaningfulPaintMarkers,
      firstInteractiveMarkers,
      consistentlyInteractiveMarkers,
    ]);
    const samplesObjectsArray = [];
    for (const markersByNavStart of markersByFrameAndNavStart.values()) {
      for (const markers of markersByNavStart.values()) {
        addPairwiseBreakdowns(samplesObjectsArray, markers,
            rendererHelper, browserHelper, navigationStartFinder);
      }
    }
    const navToOnLoadSamples = [];
    addTimeToSamples(navToOnLoadSamples, onLoadMarkers);
    samplesObjectsArray.push({
      histogramName: 'navToOnLoad',
      histogramDescription: 'navigation start to onload. ' +
          'This is temporary metric used for PCv1/v2 sanity checking',
      samples: navToOnLoadSamples
    });
    // Per-second breakdown:
    const endTime = getTraceEnd(rendererHelper);
    const navStarts = [];
    if (firstMeaningfulPaintMarkers.length !== 1) return [];
    for (let fmpMarker of firstMeaningfulPaintMarkers) {
      navStarts.push(fmpMarker.navigationStart);
    }
    const perSecondRanges = getPerSecondRanges(navStarts, endTime);
    for (const range of perSecondRanges) {
      const perSecondSamples = [];
      addBreakdownSamples(perSecondSamples, rendererHelper, browserHelper,
          { start: range.absoluteRange.min },
          { start: range.absoluteRange.max }, frameIdOfInterest, null);
      samplesObjectsArray.push({
        histogramName: 'nav' + range.relativeRange.min + 'secTo' +
            range.relativeRange.max + 'secBreakdown',
        histogramDescription: range.relativeRange.min + ' second to ' +
            range.relativeRange.max +
            ' second from navigation start breakdown',
        samples: perSecondSamples
      });
      const perSecondCpuTimeSamples = [];
      addCpuBreakdownSamples(perSecondCpuTimeSamples, rendererHelper,
          { start: range.absoluteRange.min },
          { start: range.absoluteRange.max }, frameIdOfInterest, null);
      samplesObjectsArray.push({
        histogramName: 'nav' + range.relativeRange.min + 'secTo' +
            range.relativeRange.max + 'secBreakdownCpuTime',
        histogramDescription: range.relativeRange.min + ' second to ' +
            range.relativeRange.max +
            ' second from navigation start breakdown in CPU time',
        samples: perSecondCpuTimeSamples
      });
    }
    return samplesObjectsArray;
  }
  function getTraceEnd(rendererHelper) {
    return rendererHelper.modelHelper.model.bounds.max;
  }
  function getPerSecondRanges(navStarts, endTime) {
    const ranges = [];
    for (let i = 0; i < navStarts.length; i++) {
      // navStarts is reversely sorted.
      const endOfNav =
          i == 0 ? endTime : navStarts[i - 1].start;
      for (let ms = 1000; ms < endOfNav - navStarts[i].start; ms += 1000) {
        ranges.push({
          absoluteRange: tr.b.math.Range.fromExplicitRange(
              navStarts[i].start + ms - 1000, navStarts[i].start + ms),
          relativeRange: tr.b.math.Range.fromExplicitRange(
              ms / 1000 - 1, ms / 1000)
        });
      }
    }
    return ranges;
  }
  function addPairwiseBreakdowns(samplesObjectsArray, markers,
      rendererHelper, browserHelper, navigationStartFinder) {
    for (const marker1 of markers) {
      // Add navigation start to X breakdown samples.
      const navToMarkerSamples = [];
      addBreakdownSamples(navToMarkerSamples, rendererHelper, browserHelper,
          marker1.navigationStart, marker1.event, marker1.frameIdRef,
          marker1.url);
      samplesObjectsArray.push({
        histogramName: 'navTo' +
            capitalizeFirstLetter(marker1.eventName) + 'Breakdown',
        histogramDescription: 'navigation start to ' +
            marker1.eventName + ' breakdown',
        samples: navToMarkerSamples
      });
      const navToMarkerCpuTimeSamples = [];
      addCpuBreakdownSamples(navToMarkerCpuTimeSamples,
          rendererHelper, marker1.navigationStart, marker1.event,
          marker1.frameIdRef, marker1.url);
      samplesObjectsArray.push({
        histogramName: 'navTo' +
            capitalizeFirstLetter(marker1.eventName) + 'BreakdownCpuTime',
        histogramDescription: 'navigation start to ' +
            marker1.eventName + ' breakdown in CPU time',
        samples: navToMarkerCpuTimeSamples
      });
      // Add X to next navigation start breakdown samples.
      const nextNavStart =
          navigationStartFinder.
              findNextNavigationStartEventForFrameAfterTimestamp(
              marker1.frameIdRef, marker1.event.start);
      if (nextNavStart) {
        const markerToNavSamples = [];
        addBreakdownSamples(markerToNavSamples, rendererHelper, browserHelper,
            marker1.event, nextNavStart, marker1.frameIdRef,
            marker1.url);
        samplesObjectsArray.push({
          histogramName: marker1.eventName + 'ToNavBreakdown',
          histogramDescription: marker1.eventName +
              ' to navigation start breakdown',
          samples: markerToNavSamples
        });
        const markerToNavCpuTimeSamples = [];
        addCpuBreakdownSamples(markerToNavCpuTimeSamples,
            rendererHelper, marker1.event, nextNavStart,
            marker1.frameIdRef, marker1.url);
        samplesObjectsArray.push({
          histogramName: marker1.eventName + 'ToNavBreakdownCpuTime',
          histogramDescription: marker1.eventName +
              ' to navigation start breakdown in CPU time',
          samples: markerToNavCpuTimeSamples
        });
      }
      // Add X to Y breakdown samples.
      for (const marker2 of markers) {
        if (marker1.eventName === marker2.eventName) continue;
        // dproy: Changing this to less *or equal*. Sometimes, FI, CI, and FMP
        // can all be the same timestamp. We'd like the histograms to be present
        // even if the value is 0 - makes post processing easier.
        if (marker1.event.start <= marker2.event.start) {
          const markerAToBSamples = [];
          addBreakdownSamples(markerAToBSamples,
              rendererHelper, browserHelper, marker1.event, marker2.event,
              marker1.frameIdRef, marker1.url);
          samplesObjectsArray.push({
            histogramName: marker1.eventName + 'To' +
                capitalizeFirstLetter(marker2.eventName) + 'Breakdown',
            histogramDescription: marker1.eventName + ' to ' +
                marker2.eventName + ' breakdown',
            samples: markerAToBSamples
          });
          const markerAToBCpuTimeSamples = [];
          addCpuBreakdownSamples(markerAToBCpuTimeSamples,
              rendererHelper, marker1.event, marker2.event,
              marker1.frameIdRef, marker1.url);
          samplesObjectsArray.push({
            histogramName: marker1.eventName + 'To' +
                capitalizeFirstLetter(marker2.eventName) +
                'BreakdownCpuTime',
            histogramDescription: marker1.eventName + ' to ' +
                marker2.eventName + ' breakdown in CPU time',
            samples: markerAToBCpuTimeSamples
          });
        }
      }
    }
  }
  function addSamplesToHistogram(samples, histogram) {
    for (const sample of samples) {
      histogram.addSample(sample.value, sample.diagnostics);
    }
  }
  function loadingMetric(histograms, model) {
    try {
    const histogramMap = new Map();
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const browserHelper = chromeHelper.browserHelper;
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;
      const samplesObjectArray =
          collectLoadingMetricsForRenderer(rendererHelper, browserHelper);
      for (const samplesObject of samplesObjectArray) {
        let histogram;
        if (histogramMap.has(samplesObject.histogramName)) {
          histogram = histogramMap.get(samplesObject.histogramName);
        } else {
          histogram = createHistogram(
              samplesObject.histogramName, samplesObject.histogramDescription);
          histogramMap.set(samplesObject.histogramName, histogram);
        }
        addSamplesToHistogram(
            samplesObject.samples, histogram);
      }
    }
    function validateBreakdown(histogram) {
      try {
        if (histogram.running.count !== 1) {
          throw new Error("Histogram count = ", histogram.running.count);
        }
        const bin = histogram.allBins.filter(b => b.count === 1)[0];
        const diagnosticsMap = bin.diagnosticMaps[0];
        if (!diagnosticsMap.get("Breakdown")) return;
        const breakdownTree = diagnosticsMap.get("Breakdown").values_;
        let breakdownSum = 0;
        breakdownTree.forEach((v,k)=>breakdownSum+=v)
        const histogramSum = histogram.running.sum;
        if (Math.abs(breakdownSum - histogram.running.sum) > 1e-3) {
          throw new Error(`Breakdown sum is ${breakdownSum} but histogram sum is ${histogram.running.sum}`);
        }
        console.log("Validated histogram: ", histogram.name);
        console.log("idle: ", breakdownTree.get("idle") && breakdownTree.get('idle'));
      } catch (e) {
        console.error("Error validating this histogram: ", histogram);
        console.error(e);
      }
    }
    for (const histogram of histogramMap.values()) {
      // validateBreakdown(histogram);
      histograms.addHistogram(histogram);
    }
    debugger;
    } catch (e) {
      // console.error(e);
      // CTP chokes on console.error
      console.log(e);
    }
  }
  tr.metrics.MetricRegistry.register(loadingMetric);
  return {
    loadingMetric,
    getNetworkEventsInRange,
    collectLoadingMetricsForRenderer,
    RESPONSIVENESS_THRESHOLD_MS,
    LONG_TASK_THRESHOLD_MS,
    INTERACTIVE_WINDOW_SIZE_MS,
  };
});
</script>
