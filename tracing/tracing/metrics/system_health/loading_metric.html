<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html">
<link rel="import" href="/tracing/extras/chrome/time_to_interactive.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/helpers/chrome_thread_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic_map.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const LOADING_METRIC_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createLinear(0, 1e3, 20)  // 50ms step to 1s
      .addLinearBins(3e3, 20) // 100ms step to 3s
      .addExponentialBins(20e3, 20);
  const SUMMARY_OPTIONS = {
    avg: true,
    count: false,
    max: true,
    min: true,
    std: true,
    sum: false,
  };

  function addSamplesToHistogram(samples, histogram, histograms) {
    for (const sample of samples) {
      histogram.addSample(sample.value, sample.diagnostics);
    }
  }

  function loadingMetric(histograms, model) {
    const count_non_trivial_document_histogram = histograms.createHistogram(
        'count_non_trivial_document_histogram', tr.b.Unit.byName.count_smallerIsBetter, [], {
          description: 'count_non_trivial_document_histogram objects',
          summaryOptions: SUMMARY_OPTIONS,
        });

    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    let all_slices = [];
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;

      const samples = [];
      const slices = rendererHelper.mainThread.sliceGroup.slices;
      const textAggregationSlices =
          slices.filter(s=>s.title==="Document::ReportInnerTopLevel");
      textAggregationSlices.forEach(e=>{
        all_slices.push(e);
      });

      // Example:
      // for (let i = 0; i < slices.length && i < 5; i++) {
      //   samples.push({
      //     value: slices[i].start,
      //     diagnostics: {}})
      // }
      // If you add multiple values into a histogram, the result of this
      // histogram will be the avg of these values.
    }

    all_slices = all_slices.filter(e=>e.args.data.isMainFrame);
    all_slices = all_slices.filter(e=>{
      const info_map = e.args.data.info_map;
      const has_html =
        Object.values(info_map).filter(obj=>obj.tag_name==="html").length > 0;
      return has_html;
    })
    all_slices = all_slices.filter(e=>{
      const info_map = e.args.data.info_map;
      const all_tag_names = Object.values(info_map).map(obj=>obj.tag_name);
      if (all_tag_names.length==3) {
        let all_includes = true;
        for (each in ["not-element", "html", "body"]) {
          if (!all_tag_names.includes(each)) {
            all_includes = false;
            break;
          }
        }
        if (all_includes)
          return false;
      }
      return true;
    });
    addSamplesToHistogram([{
      value: all_slices.length,
      diagnostics: {}
    }], count_non_trivial_document_histogram, histograms);
  }

  tr.metrics.MetricRegistry.register(loadingMetric);

  return {
    loadingMetric,
  };
});
</script>
