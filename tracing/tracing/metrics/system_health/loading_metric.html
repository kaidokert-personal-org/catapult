<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html">
<link rel="import" href="/tracing/extras/chrome/time_to_interactive.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/helpers/chrome_thread_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic_map.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const LOADING_METRIC_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createLinear(0, 1e3, 20)  // 50ms step to 1s
      .addLinearBins(3e3, 20) // 100ms step to 3s
      .addExponentialBins(20e3, 20);
  const SUMMARY_OPTIONS = {
    avg: true,
    count: false,
    max: true,
    min: true,
    std: true,
    sum: false,
  };

  function addSamplesToHistogram(samples, histogram, histograms) {
    for (const sample of samples) {
      histogram.addSample(sample.value, sample.diagnostics);
    }
  }

  function loadingMetric(histograms, model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    let all_slices = [];
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;

      const samples = [];
      const slices = rendererHelper.mainThread.sliceGroup.slices;
      const textAggregationSlices =
          slices.filter(s=>s.title==="LargestImagePaint::LargestImageInfo");
      textAggregationSlices.forEach(e=>{
        all_slices.push(e);
      });

      // Example:
      // for (let i = 0; i < slices.length && i < 5; i++) {
      //   samples.push({
      //     value: slices[i].start,
      //     diagnostics: {}})
      // }
      // If you add multiple values into a histogram, the result of this
      // histogram will be the avg of these values.
    }

    all_slices = all_slices.filter(e=>e.args.data.isMainFrame);
    all_slices = all_slices.sort((a, b)=>{
      const data_a = a.args.data;
      const data_b = b.args.data;
      return data_b.visual_size/data_b.viewport_size - data_a.visual_size/data_a.viewport_size;
    }); // [0] is max

    const largest_ratio_data = all_slices[0].args.data;
    const all_values = [
      {
        name: 'visual_size/viewport_size',
        value: largest_ratio_data.visual_size/largest_ratio_data.viewport_size
      },
      {
        name: "visual_size",
        value: largest_ratio_data.visual_size
      },
      {
        name: "viewport_size",
        value: largest_ratio_data.viewport_size
      },
      {
        name: "intrinsic_size",
        value: largest_ratio_data.intrinsic_size
      },
      {
        name: "clipped_intrinsic_size",
        value: largest_ratio_data.clipped_intrinsic_size
      },
      {
        name: "frame",
        value: largest_ratio_data.frame
      },
      {
        name: "isMainFrame",
        value: largest_ratio_data.isMainFrame
      }
    ];

    all_values.forEach(item=>{
      const hist = histograms.createHistogram(
        item.name, tr.b.Unit.byName.unitlessNumber_smallerIsBetter, [], {
          description: item.name,
          summaryOptions: SUMMARY_OPTIONS,
        });
      addSamplesToHistogram([{
        value: item.value,
        diagnostics: {}
      }], hist, histograms);
    });
  }

  tr.metrics.MetricRegistry.register(loadingMetric);

  return {
    loadingMetric,
  };
});
</script>
