<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html">
<link rel="import" href="/tracing/extras/chrome/time_to_interactive.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/helpers/chrome_thread_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic_map.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const LOADING_METRIC_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createLinear(0, 1e3, 20)  // 50ms step to 1s
      .addLinearBins(3e3, 20) // 100ms step to 3s
      .addExponentialBins(20e3, 20);
  const SUMMARY_OPTIONS = {
    avg: true,
    count: false,
    max: true,
    min: true,
    std: true,
    sum: false,
  };

  function addSamplesToHistogram(samples, histogram, histograms) {
    for (const sample of samples) {
      histogram.addSample(sample.value, sample.diagnostics);
    }
  }

  function sortSlicesBySizeRatio(slices) {
    return slices.sort((a, b)=>{
      const data_a = a.args.data;
      const data_b = b.args.data;
      return data_b.visual_size/data_b.viewport_size - data_a.visual_size/data_a.viewport_size;
    }); // [0] is max
  }

  function loadingMetric(histograms, model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    let allSlices = [];
    let textSlices = [];
    let imageSlices = [];
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;

      const samples = [];
      const slices = rendererHelper.mainThread.sliceGroup.slices;
      slices.filter(s=>s.title==="LargestImagePaint::LargestImageInfo"
          && s.args.data.is_main_frame)
          .forEach(e=>{
        allSlices.push(e);
        imageSlices.push(e);
      });
      slices.filter(s=>s.title==="LargestTextPaint::LargestTextInfo"
          && s.args.data.is_main_frame)
          .forEach(e=>{
        allSlices.push(e);
        textSlices.push(e);
      });
    }

    allSlices = sortSlicesBySizeRatio(allSlices);
    textSlices = sortSlicesBySizeRatio(textSlices);
    imageSlices = sortSlicesBySizeRatio(imageSlices);

    if (allSlices.length === 0)
      return;
    [{ name: 'content', slices: allSlices },
     { name: 'image', slices: imageSlices },
     { name: 'text', slices: textSlices }].forEach(entry=>{
      const prefix = entry.name;
      const largestContentEvent = entry.slices[0].args.data;
      const allHistogramValues = [
        {
          name: 'visual_size/viewport_size',
          value: largestContentEvent.visual_size/largestContentEvent.viewport_size
        },
        {
          name: "visual_size",
          value: largestContentEvent.visual_size
        },
        {
          name: "viewport_size",
          value: largestContentEvent.viewport_size
        },
        {
          name: "frame",
          value: largestContentEvent.frame
        },
        {
          name: "is_main_frame",
          value: largestContentEvent.is_main_frame
        },
        {
          name: "url",
          value: largestContentEvent.url
        }
      ];

      allHistogramValues.forEach(item=>{
        const hist = histograms.createHistogram(
          prefix + ":" + item.name, tr.b.Unit.byName.unitlessNumber, [], {
            description: prefix + ":" + item.name,
            summaryOptions: SUMMARY_OPTIONS,
          });
        addSamplesToHistogram([{
          value: item.value,
          diagnostics: {}
        }], hist, histograms);
      });
     })
  }

  tr.metrics.MetricRegistry.register(loadingMetric);

  return {
    loadingMetric,
  };
});
</script>
