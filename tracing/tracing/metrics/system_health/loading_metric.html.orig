<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/extras/chrome/event_finder_utils.html">
<link rel="import" href="/tracing/extras/chrome/time_to_interactive.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/helpers/chrome_thread_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic_map.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const LOADING_METRIC_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createLinear(0, 1e3, 20)  // 50ms step to 1s
      .addLinearBins(3e3, 20) // 100ms step to 3s
      .addExponentialBins(20e3, 20);
  const SUMMARY_OPTIONS = {
    avg: true,
    count: false,
    max: true,
    min: true,
    std: true,
    sum: false,
  };

<<<<<<< HEAD
  function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
    const objects = rendererHelper.process.objects;
    const frameLoaderInstances = objects.instancesByTypeName_.FrameLoader;
    if (frameLoaderInstances === undefined) return undefined;

    let snapshot;
    for (const instance of frameLoaderInstances) {
      if (!instance.isAliveAt(ts)) continue;
      const maybeSnapshot = instance.getSnapshotAt(ts);
      if (frameIdRef !== maybeSnapshot.args.frame.id_ref) continue;
      snapshot = maybeSnapshot;
    }

    return snapshot;
  }

  function findAllEvents(rendererHelper, category, title) {
    const targetEvents = [];

    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, category, title)) continue;
      targetEvents.push(ev);
    }

    return targetEvents;
  }

  function getMostRecentValidEvent(rendererHelper, category, title) {
    const targetEvents = findAllEvents(rendererHelper, category, title);
    // Want to keep the event with the most recent timestamp
    let validEvent;
    for (const targetEvent of targetEvents) {
      if (rendererHelper.isTelemetryInternalEvent(targetEvent)) continue;
      if (validEvent === undefined) {
        validEvent = targetEvent;
      } else {
        // Want to keep the event with the most recent timestamp
        if (validEvent.start < targetEvent.start) {
          validEvent = targetEvent;
        }
      }
    }
    return validEvent;
  }

  function getFirstViewportReadySamples(rendererHelper,
      navIdToNavStartEvents) {
    const samples = [];
    // Want to measure the time from when navigation starts to when the load
    // event fired for all non-ad resources.  This done with the associated
    // navigation start event to the pc mark in the amp code, correlated by
    // navigation id.
    const pcEvent = getMostRecentValidEvent(
        rendererHelper, 'blink.user_timing', 'pc');
    if (pcEvent === undefined) return samples;

    if (rendererHelper.isTelemetryInternalEvent(pcEvent)) return samples;
    const navigationStartEvent = navIdToNavStartEvents.get(
        pcEvent.args.data.navigationId);
    if (navigationStartEvent === undefined) return samples;
    const navStartToEventRange = tr.b.math.Range.fromExplicitRange(
        navigationStartEvent.start, pcEvent.start);
    const networkEvents = EventFinderUtils.getNetworkEventsInRange(
        rendererHelper.process, navStartToEventRange);
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents, navStartToEventRange);
    samples.push({
      value: navStartToEventRange.duration,
      breakdownTree,
      diagnostics: {
        breakdown: createBreakdownDiagnostic(breakdownTree),
        Start: new RelatedEventSet(navigationStartEvent),
        End: new RelatedEventSet(pcEvent)
      }
    });

    return samples;
  }

  function getAboveTheFoldLoadedToVisibleSamples(rendererHelper) {
    const samples = [];
    // Want to measure the time from when the document is visible to the time
    // when the load event fired for all non-ad resources.  This is done with
    // two marks in the amp code: pc and visible.
    const pcEvent = getMostRecentValidEvent(
        rendererHelper, 'blink.user_timing', 'pc');
    const visibleEvent = getMostRecentValidEvent(
        rendererHelper, 'blink.user_timing', 'visible');
    if (pcEvent !== undefined && visibleEvent !== undefined) {
      samples.push({
        value: Math.max(0.0, pcEvent.start - visibleEvent.start),
        diagnostics: {
          Start: new RelatedEventSet(visibleEvent),
          End: new RelatedEventSet(pcEvent)
        }
      });
    }
    return samples;
  }

  function findTimeToXEntries(
      category, eventName, rendererHelper, frameToNavStartEvents,
      navIdToNavStartEvents) {
    const targetEvents = findAllEvents(rendererHelper, category, eventName);
    const entries = [];
    for (const targetEvent of targetEvents) {
      if (rendererHelper.isTelemetryInternalEvent(targetEvent)) continue;
      const frameIdRef = targetEvent.args.frame;
      const snapshot = findFrameLoaderSnapshotAt(
          rendererHelper, frameIdRef, targetEvent.start);
      if (snapshot === undefined || !snapshot.args.isLoadingMainFrame) continue;
      const url = snapshot.args.documentLoaderURL;
      if (tr.e.chrome.CHROME_INTERNAL_URLS.includes(url)) continue;
      let navigationStartEvent;
      if (targetEvent.args.data === undefined ||
          targetEvent.args.data.navigationId === undefined) {
        navigationStartEvent =
            EventFinderUtils.findLastEventStartingOnOrBeforeTimestamp(
                frameToNavStartEvents.get(frameIdRef) || [], targetEvent.start);
      } else {
        navigationStartEvent = navIdToNavStartEvents.get(
            targetEvent.args.data.navigationId);
      }

      // Ignore layout w/o preceding navigationStart, as they are not
      // attributed to any time-to-X metric.
      if (navigationStartEvent === undefined) continue;
      entries.push({
        navigationStartEvent,
        targetEvent,
        url,
      });
    }
    return entries;
  }

  function collectTimeToEvent(rendererHelper, timeToXEntries) {
    const samples = [];
    for (const { targetEvent, navigationStartEvent, url } of timeToXEntries) {
      const navStartToEventRange = tr.b.math.Range.fromExplicitRange(
          navigationStartEvent.start, targetEvent.start);
      const networkEvents = EventFinderUtils.getNetworkEventsInRange(
          rendererHelper.process, navStartToEventRange);
      const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
          rendererHelper.mainThread, networkEvents, navStartToEventRange);
      samples.push({
        value: navStartToEventRange.duration,
        breakdownTree,
        diagnostics: {
          breakdown: createBreakdownDiagnostic(breakdownTree),
          url: new tr.v.d.GenericSet([url]),
          Start: new RelatedEventSet(navigationStartEvent),
          End: new RelatedEventSet(targetEvent)
        }
      });
    }
    return samples;
  }

  function collectTimeToEventInCpuTime(rendererHelper, timeToXEntries) {
    const samples = [];
    for (const { targetEvent, navigationStartEvent, url } of timeToXEntries) {
      const navStartToEventRange = tr.b.math.Range.fromExplicitRange(
          navigationStartEvent.start, targetEvent.start);

      const mainThreadCpuTime =
          rendererHelper.mainThread.getCpuTimeForRange(navStartToEventRange);

      const breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
          rendererHelper.mainThread, navStartToEventRange);
      samples.push({
        value: mainThreadCpuTime,
        breakdownTree,
        diagnostics: {
          breakdown: createBreakdownDiagnostic(breakdownTree),
          start: new RelatedEventSet(navigationStartEvent),
          end: new RelatedEventSet(targetEvent),
          infos: new tr.v.d.GenericSet([{
            pid: rendererHelper.pid,
            start: navigationStartEvent.start,
            event: targetEvent.start,
          }]),
        }
      });
    }
    return samples;
  }

  function addFirstMeaningfulPaintSample(samples, rendererHelper,
      navigationStart, fmpMarkerEvent, url) {
    const navStartToFMPRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.start, fmpMarkerEvent.start);
    const networkEvents = EventFinderUtils.getNetworkEventsInRange(
        rendererHelper.process, navStartToFMPRange);
    const timeToFirstMeaningfulPaint = navStartToFMPRange.duration;
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents, navStartToFMPRange);
    samples.push({
      value: timeToFirstMeaningfulPaint,
      breakdownTree,
      diagnostics: {
        breakdown: createBreakdownDiagnostic(breakdownTree),
        start: new RelatedEventSet(navigationStart),
        end: new RelatedEventSet(fmpMarkerEvent),
        infos: new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start,
        }]),
      }
    });
  }

  function addFirstMeaningfulPaintCpuTimeSample(samples, rendererHelper,
      navigationStart, fmpMarkerEvent, url) {
    const navStartToFMPRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.start, fmpMarkerEvent.start);

    const mainThreadCpuTime =
        rendererHelper.mainThread.getCpuTimeForRange(navStartToFMPRange);

    const breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
        rendererHelper.mainThread, navStartToFMPRange);
    samples.push({
      value: mainThreadCpuTime,
      breakdownTree,
      diagnostics: {
        breakdown: createBreakdownDiagnostic(breakdownTree),
        start: new RelatedEventSet(navigationStart),
        end: new RelatedEventSet(fmpMarkerEvent),
        infos: new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start,
        }]),
      }
    });
  }

  /**
   * Object containing one value and associated diagnostics info for that value
   * for a metric.
   * @typedef {{value: number, diagnostics: !tr.v.d.DiagnosticMap}} MetricSample
   */

  /**
   * Returns a MetricSample for interactivity metrics - First CPU Idle and Time
   * to Interactive.
   *
   * @param {tr.model.helpers.ChromeRendererHelper} rendererHelper
   * @param {?number} eventTimestamp - Timestamp of the event for which the
   *     sample is being generated.
   * @param {tr.model.ThreadSlice} navigationStartEvent
   * @param {number} firstMeaningfulPaintTime
   * @param {number} domContentLoadedEndTime
   * @param {string} url - URL of the current main frame document.
   * @returns {MetricSample|undefined}
   */
  function decorateInteractivitySampleWithDiagnostics_(rendererHelper,
      eventTimestamp, navigationStartEvent, firstMeaningfulPaintTime,
      domContentLoadedEndTime, url) {
    if (eventTimestamp === undefined) return undefined;
    const navigationStartTime = navigationStartEvent.start;
    const navStartToEventTimeRange =
        tr.b.math.Range.fromExplicitRange(
            navigationStartTime, eventTimestamp);
    const networkEvents = EventFinderUtils.getNetworkEventsInRange(
        rendererHelper.process, navStartToEventTimeRange);
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents,
        navStartToEventTimeRange);
    const breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    return {
      value: navStartToEventTimeRange.duration,
      diagnostics: tr.v.d.DiagnosticMap.fromObject({
        'Start': new RelatedEventSet(navigationStartEvent),
        'Navigation infos': new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          navigationStartTime,
          firstMeaningfulPaintTime,
          domContentLoadedEndTime,
          // eventTimestamp can be derived from value and navigationStartEvent,
          // but it's useful to directly see the value in the UI.
          eventTimestamp,
        }]),
        'Breakdown of [navStart, eventTimestamp]': breakdownDiagnostic,
      }),
    };
  }

  function collectLoadingMetricsForRenderer(rendererHelper) {
    const frameToNavStartEvents =
        EventFinderUtils.getSortedMainThreadEventsByFrame(
            rendererHelper, 'navigationStart', 'blink.user_timing');
    const navIdToNavStartEvents =
        EventFinderUtils.getSortedMainThreadEventsByNavId(
            rendererHelper, 'navigationStart', 'blink.user_timing');
    const firstPaintSamples = collectTimeToEvent(rendererHelper,
        findTimeToXEntries('loading', 'firstPaint', rendererHelper,
            frameToNavStartEvents, navIdToNavStartEvents));
    const timeToFCPEntries = findTimeToXEntries('loading',
        'firstContentfulPaint', rendererHelper, frameToNavStartEvents,
        navIdToNavStartEvents);
    const firstContentfulPaintSamples = collectTimeToEvent(rendererHelper,
        timeToFCPEntries);
    const firstContentfulPaintCpuTimeSamples = collectTimeToEventInCpuTime(
        rendererHelper, timeToFCPEntries);
    const onLoadSamples = collectTimeToEvent(rendererHelper, findTimeToXEntries(
        'blink.user_timing', 'loadEventStart', rendererHelper,
        frameToNavStartEvents, navIdToNavStartEvents));
    const aboveTheFoldLoadedToVisibleSamples =
        getAboveTheFoldLoadedToVisibleSamples(rendererHelper);
    const firstViewportReadySamples = getFirstViewportReadySamples(
        rendererHelper, navIdToNavStartEvents);

    return {
      frameToNavStartEvents,
      firstPaintSamples,
      firstContentfulPaintSamples,
      firstContentfulPaintCpuTimeSamples,
      onLoadSamples,
      aboveTheFoldLoadedToVisibleSamples,
      firstViewportReadySamples,
    };
  }

  function collectMetricsFromLoadExpectations(model, chromeHelper) {
    // Add FMP, firstCpuIdle and interactive samples from load UE
    const interactiveSamples = [];
    const firstCpuIdleSamples = [];
    const firstMeaningfulPaintSamples = [];
    const firstMeaningfulPaintCpuTimeSamples = [];
    for (const expectation of model.userModel.expectations) {
      if (!(expectation instanceof tr.model.um.LoadExpectation)) continue;
      if (tr.e.chrome.CHROME_INTERNAL_URLS.includes(expectation.url)) {
        continue;
      }
      const rendererHelper = chromeHelper.rendererHelpers[
          expectation.renderProcess.pid];
      if (expectation.fmpEvent !== undefined) {
        addFirstMeaningfulPaintSample(firstMeaningfulPaintSamples,
            rendererHelper, expectation.navigationStart, expectation.fmpEvent,
            expectation.url);
        addFirstMeaningfulPaintCpuTimeSample(firstMeaningfulPaintCpuTimeSamples,
            rendererHelper, expectation.navigationStart, expectation.fmpEvent,
            expectation.url);
      }
      if (expectation.firstCpuIdleTime !== undefined) {
        firstCpuIdleSamples.push(decorateInteractivitySampleWithDiagnostics_(
            rendererHelper, expectation.firstCpuIdleTime,
            expectation.navigationStart,
            expectation.fmpEvent.start,
            expectation.domContentLoadedEndEvent.start, expectation.url));
      }
      if (expectation.timeToInteractive !== undefined) {
        interactiveSamples.push(decorateInteractivitySampleWithDiagnostics_(
            rendererHelper, expectation.timeToInteractive,
            expectation.navigationStart,
            expectation.fmpEvent.start,
            expectation.domContentLoadedEndEvent.start, expectation.url));
      }
    }

    return {
      firstMeaningfulPaintSamples,
      firstMeaningfulPaintCpuTimeSamples,
      firstCpuIdleSamples,
      interactiveSamples,
    };
  }

||||||| merged common ancestors
  function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
    const objects = rendererHelper.process.objects;
    const frameLoaderInstances = objects.instancesByTypeName_.FrameLoader;
    if (frameLoaderInstances === undefined) return undefined;

    let snapshot;
    for (const instance of frameLoaderInstances) {
      if (!instance.isAliveAt(ts)) continue;
      const maybeSnapshot = instance.getSnapshotAt(ts);
      if (frameIdRef !== maybeSnapshot.args.frame.id_ref) continue;
      snapshot = maybeSnapshot;
    }

    return snapshot;
  }

  function findAllEvents(rendererHelper, category, title) {
    const targetEvents = [];

    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, category, title)) continue;
      targetEvents.push(ev);
    }

    return targetEvents;
  }

  function getMostRecentValidEvent(rendererHelper, category, title) {
    const targetEvents = findAllEvents(rendererHelper, category, title);
    // Want to keep the event with the most recent timestamp
    let validEvent;
    for (const targetEvent of targetEvents) {
      if (rendererHelper.isTelemetryInternalEvent(targetEvent)) continue;
      if (validEvent === undefined) {
        validEvent = targetEvent;
      } else {
        // Want to keep the event with the most recent timestamp
        if (validEvent.start < targetEvent.start) {
          validEvent = targetEvent;
        }
      }
    }
    return validEvent;
  }

  function getAboveTheFoldLoadedToVisibleSamples(rendererHelper,
      navIdToNavStartEvents) {
    const samples = [];
    // Want to measure the time from when navigation starts to when the load
    // event fired for all non-ad resources.  This done with the associated
    // navigation start event to the pc mark in the amp code, correlated by
    // navigation id.
    const pcEvent = getMostRecentValidEvent(
        rendererHelper, 'blink.user_timing', 'pc');
    if (pcEvent === undefined) return samples;

    if (rendererHelper.isTelemetryInternalEvent(pcEvent)) return samples;
    const navigationStartEvent = navIdToNavStartEvents.get(
        pcEvent.args.data.navigationId);
    if (navigationStartEvent === undefined) return samples;
    const navStartToEventRange = tr.b.math.Range.fromExplicitRange(
        navigationStartEvent.start, pcEvent.start);
    const networkEvents = EventFinderUtils.getNetworkEventsInRange(
        rendererHelper.process, navStartToEventRange);
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents, navStartToEventRange);
    samples.push({
      value: navStartToEventRange.duration,
      breakdownTree,
      diagnostics: {
        breakdown: createBreakdownDiagnostic(breakdownTree),
        Start: new RelatedEventSet(navigationStartEvent),
        End: new RelatedEventSet(pcEvent)
      }
    });

    return samples;
  }

  function getFirstViewportReadySamples(rendererHelper) {
    const samples = [];
    // Want to measure the time from when the document is visible to the time
    // when the load event fired for all non-ad resources.  This is done with
    // two marks in the amp code: pc and visible.
    const pcEvent = getMostRecentValidEvent(
        rendererHelper, 'blink.user_timing', 'pc');
    const visibleEvent = getMostRecentValidEvent(
        rendererHelper, 'blink.user_timing', 'visible');
    if (pcEvent !== undefined && visibleEvent !== undefined) {
      samples.push({
        value: pcEvent.start - visibleEvent.start,
        diagnostics: {
          Start: new RelatedEventSet(visibleEvent),
          End: new RelatedEventSet(pcEvent)
        }
      });
    }
    return samples;
  }

  function findTimeToXEntries(
      category, eventName, rendererHelper, frameToNavStartEvents,
      navIdToNavStartEvents) {
    const targetEvents = findAllEvents(rendererHelper, category, eventName);
    const entries = [];
    for (const targetEvent of targetEvents) {
      if (rendererHelper.isTelemetryInternalEvent(targetEvent)) continue;
      const frameIdRef = targetEvent.args.frame;
      const snapshot = findFrameLoaderSnapshotAt(
          rendererHelper, frameIdRef, targetEvent.start);
      if (snapshot === undefined || !snapshot.args.isLoadingMainFrame) continue;
      const url = snapshot.args.documentLoaderURL;
      if (tr.e.chrome.CHROME_INTERNAL_URLS.includes(url)) continue;
      let navigationStartEvent;
      if (targetEvent.args.data === undefined ||
          targetEvent.args.data.navigationId === undefined) {
        navigationStartEvent =
            EventFinderUtils.findLastEventStartingOnOrBeforeTimestamp(
                frameToNavStartEvents.get(frameIdRef) || [], targetEvent.start);
      } else {
        navigationStartEvent = navIdToNavStartEvents.get(
            targetEvent.args.data.navigationId);
      }

      // Ignore layout w/o preceding navigationStart, as they are not
      // attributed to any time-to-X metric.
      if (navigationStartEvent === undefined) continue;
      entries.push({
        navigationStartEvent,
        targetEvent,
        url,
      });
    }
    return entries;
  }

  function collectTimeToEvent(rendererHelper, timeToXEntries) {
    const samples = [];
    for (const { targetEvent, navigationStartEvent, url } of timeToXEntries) {
      const navStartToEventRange = tr.b.math.Range.fromExplicitRange(
          navigationStartEvent.start, targetEvent.start);
      const networkEvents = EventFinderUtils.getNetworkEventsInRange(
          rendererHelper.process, navStartToEventRange);
      const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
          rendererHelper.mainThread, networkEvents, navStartToEventRange);
      samples.push({
        value: navStartToEventRange.duration,
        breakdownTree,
        diagnostics: {
          breakdown: createBreakdownDiagnostic(breakdownTree),
          url: new tr.v.d.GenericSet([url]),
          Start: new RelatedEventSet(navigationStartEvent),
          End: new RelatedEventSet(targetEvent)
        }
      });
    }
    return samples;
  }

  function collectTimeToEventInCpuTime(rendererHelper, timeToXEntries) {
    const samples = [];
    for (const { targetEvent, navigationStartEvent, url } of timeToXEntries) {
      const navStartToEventRange = tr.b.math.Range.fromExplicitRange(
          navigationStartEvent.start, targetEvent.start);

      const mainThreadCpuTime =
          rendererHelper.mainThread.getCpuTimeForRange(navStartToEventRange);

      const breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
          rendererHelper.mainThread, navStartToEventRange);
      samples.push({
        value: mainThreadCpuTime,
        breakdownTree,
        diagnostics: {
          breakdown: createBreakdownDiagnostic(breakdownTree),
          start: new RelatedEventSet(navigationStartEvent),
          end: new RelatedEventSet(targetEvent),
          infos: new tr.v.d.GenericSet([{
            pid: rendererHelper.pid,
            start: navigationStartEvent.start,
            event: targetEvent.start,
          }]),
        }
      });
    }
    return samples;
  }

  function addFirstMeaningfulPaintSample(samples, rendererHelper,
      navigationStart, fmpMarkerEvent, url) {
    const navStartToFMPRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.start, fmpMarkerEvent.start);
    const networkEvents = EventFinderUtils.getNetworkEventsInRange(
        rendererHelper.process, navStartToFMPRange);
    const timeToFirstMeaningfulPaint = navStartToFMPRange.duration;
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents, navStartToFMPRange);
    samples.push({
      value: timeToFirstMeaningfulPaint,
      breakdownTree,
      diagnostics: {
        breakdown: createBreakdownDiagnostic(breakdownTree),
        start: new RelatedEventSet(navigationStart),
        end: new RelatedEventSet(fmpMarkerEvent),
        infos: new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start,
        }]),
      }
    });
  }

  function addFirstMeaningfulPaintCpuTimeSample(samples, rendererHelper,
      navigationStart, fmpMarkerEvent, url) {
    const navStartToFMPRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.start, fmpMarkerEvent.start);

    const mainThreadCpuTime =
        rendererHelper.mainThread.getCpuTimeForRange(navStartToFMPRange);

    const breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
        rendererHelper.mainThread, navStartToFMPRange);
    samples.push({
      value: mainThreadCpuTime,
      breakdownTree,
      diagnostics: {
        breakdown: createBreakdownDiagnostic(breakdownTree),
        start: new RelatedEventSet(navigationStart),
        end: new RelatedEventSet(fmpMarkerEvent),
        infos: new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start,
        }]),
      }
    });
  }

  /**
   * Object containing one value and associated diagnostics info for that value
   * for a metric.
   * @typedef {{value: number, diagnostics: !tr.v.d.DiagnosticMap}} MetricSample
   */

  /**
   * Returns a MetricSample for interactivity metrics - First CPU Idle and Time
   * to Interactive.
   *
   * @param {tr.model.helpers.ChromeRendererHelper} rendererHelper
   * @param {?number} eventTimestamp - Timestamp of the event for which the
   *     sample is being generated.
   * @param {tr.model.ThreadSlice} navigationStartEvent
   * @param {number} firstMeaningfulPaintTime
   * @param {number} domContentLoadedEndTime
   * @param {string} url - URL of the current main frame document.
   * @returns {MetricSample|undefined}
   */
  function decorateInteractivitySampleWithDiagnostics_(rendererHelper,
      eventTimestamp, navigationStartEvent, firstMeaningfulPaintTime,
      domContentLoadedEndTime, url) {
    if (eventTimestamp === undefined) return undefined;
    const navigationStartTime = navigationStartEvent.start;
    const navStartToEventTimeRange =
        tr.b.math.Range.fromExplicitRange(
            navigationStartTime, eventTimestamp);
    const networkEvents = EventFinderUtils.getNetworkEventsInRange(
        rendererHelper.process, navStartToEventTimeRange);
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents,
        navStartToEventTimeRange);
    const breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    return {
      value: navStartToEventTimeRange.duration,
      diagnostics: tr.v.d.DiagnosticMap.fromObject({
        'Start': new RelatedEventSet(navigationStartEvent),
        'Navigation infos': new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          navigationStartTime,
          firstMeaningfulPaintTime,
          domContentLoadedEndTime,
          // eventTimestamp can be derived from value and navigationStartEvent,
          // but it's useful to directly see the value in the UI.
          eventTimestamp,
        }]),
        'Breakdown of [navStart, eventTimestamp]': breakdownDiagnostic,
      }),
    };
  }

  function collectLoadingMetricsForRenderer(rendererHelper) {
    const frameToNavStartEvents =
        EventFinderUtils.getSortedMainThreadEventsByFrame(
            rendererHelper, 'navigationStart', 'blink.user_timing');
    const navIdToNavStartEvents =
        EventFinderUtils.getSortedMainThreadEventsByNavId(
            rendererHelper, 'navigationStart', 'blink.user_timing');
    const firstPaintSamples = collectTimeToEvent(rendererHelper,
        findTimeToXEntries('loading', 'firstPaint', rendererHelper,
            frameToNavStartEvents, navIdToNavStartEvents));
    const timeToFCPEntries = findTimeToXEntries('loading',
        'firstContentfulPaint', rendererHelper, frameToNavStartEvents,
        navIdToNavStartEvents);
    const firstContentfulPaintSamples = collectTimeToEvent(rendererHelper,
        timeToFCPEntries);
    const firstContentfulPaintCpuTimeSamples = collectTimeToEventInCpuTime(
        rendererHelper, timeToFCPEntries);
    const onLoadSamples = collectTimeToEvent(rendererHelper, findTimeToXEntries(
        'blink.user_timing', 'loadEventStart', rendererHelper,
        frameToNavStartEvents, navIdToNavStartEvents));
    const aboveTheFoldLoadedToVisibleSamples =
        getAboveTheFoldLoadedToVisibleSamples(
            rendererHelper, navIdToNavStartEvents);
    const firstViewportReadySamples = getFirstViewportReadySamples(
        rendererHelper);

    return {
      frameToNavStartEvents,
      firstPaintSamples,
      firstContentfulPaintSamples,
      firstContentfulPaintCpuTimeSamples,
      onLoadSamples,
      aboveTheFoldLoadedToVisibleSamples,
      firstViewportReadySamples,
    };
  }

  function collectMetricsFromLoadExpectations(model, chromeHelper) {
    // Add FMP, firstCpuIdle and interactive samples from load UE
    const interactiveSamples = [];
    const firstCpuIdleSamples = [];
    const firstMeaningfulPaintSamples = [];
    const firstMeaningfulPaintCpuTimeSamples = [];
    for (const expectation of model.userModel.expectations) {
      if (!(expectation instanceof tr.model.um.LoadExpectation)) continue;
      if (tr.e.chrome.CHROME_INTERNAL_URLS.includes(expectation.url)) {
        continue;
      }
      const rendererHelper = chromeHelper.rendererHelpers[
          expectation.renderProcess.pid];
      if (expectation.fmpEvent !== undefined) {
        addFirstMeaningfulPaintSample(firstMeaningfulPaintSamples,
            rendererHelper, expectation.navigationStart, expectation.fmpEvent,
            expectation.url);
        addFirstMeaningfulPaintCpuTimeSample(firstMeaningfulPaintCpuTimeSamples,
            rendererHelper, expectation.navigationStart, expectation.fmpEvent,
            expectation.url);
      }
      if (expectation.firstCpuIdleTime !== undefined) {
        firstCpuIdleSamples.push(decorateInteractivitySampleWithDiagnostics_(
            rendererHelper, expectation.firstCpuIdleTime,
            expectation.navigationStart,
            expectation.fmpEvent.start,
            expectation.domContentLoadedEndEvent.start, expectation.url));
      }
      if (expectation.timeToInteractive !== undefined) {
        interactiveSamples.push(decorateInteractivitySampleWithDiagnostics_(
            rendererHelper, expectation.timeToInteractive,
            expectation.navigationStart,
            expectation.fmpEvent.start,
            expectation.domContentLoadedEndEvent.start, expectation.url));
      }
    }

    return {
      firstMeaningfulPaintSamples,
      firstMeaningfulPaintCpuTimeSamples,
      firstCpuIdleSamples,
      interactiveSamples,
    };
  }

=======
>>>>>>> cut down loading metrics
  function addSamplesToHistogram(samples, histogram, histograms) {
    for (const sample of samples) {
      histogram.addSample(sample.value, sample.diagnostics);
    }
  }

  function loadingMetric(histograms, model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    let all_slices = [];
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;

      const samples = [];
      const slices = rendererHelper.mainThread.sliceGroup.slices;
      const textAggregationSlices =
          slices.filter(s=>s.title==="LargestImagePaint::LargestImageInfo");
      textAggregationSlices.forEach(e=>{
        all_slices.push(e);
      });

      // Example:
      // for (let i = 0; i < slices.length && i < 5; i++) {
      //   samples.push({
      //     value: slices[i].start,
      //     diagnostics: {}})
      // }
      // If you add multiple values into a histogram, the result of this
      // histogram will be the avg of these values.
    }

    all_slices = all_slices.filter(e=>e.args.data.isMainFrame);
    all_slices = all_slices.sort((a, b)=>{
      const data_a = a.args.data;
      const data_b = b.args.data;
      return data_b.visual_size/data_b.viewport_size - data_a.visual_size/data_a.viewport_size;
    }); // [0] is max

    if (all_slices.length === 0)
      return;
    const largest_ratio_data = all_slices[0].args.data;
    const all_values = [
      {
        name: 'visual_size/viewport_size',
        value: largest_ratio_data.visual_size/largest_ratio_data.viewport_size
      },
      {
        name: "visual_size",
        value: largest_ratio_data.visual_size
      },
      {
        name: "viewport_size",
        value: largest_ratio_data.viewport_size
      },
      {
        name: "intrinsic_size",
        value: largest_ratio_data.intrinsic_size
      },
      {
        name: "clipped_intrinsic_size",
        value: largest_ratio_data.clipped_intrinsic_size
      },
      {
        name: "frame",
        value: largest_ratio_data.frame
      },
      {
        name: "isMainFrame",
        value: largest_ratio_data.isMainFrame
      }
    ];

    all_values.forEach(item=>{
      const hist = histograms.createHistogram(
        item.name, tr.b.Unit.byName.unitlessNumber_smallerIsBetter, [], {
          description: item.name,
          summaryOptions: SUMMARY_OPTIONS,
        });
      addSamplesToHistogram([{
        value: item.value,
        diagnostics: {}
      }], hist, histograms);
    });
  }

  tr.metrics.MetricRegistry.register(loadingMetric);

  return {
    loadingMetric,
  };
});
</script>
