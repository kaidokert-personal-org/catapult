<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/chrome/chrome_user_friendly_category_driver.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const LONG_TASK_MS = 50;

  // Anything longer than this should be so rare that its length beyond this is
  // uninteresting.
  const LONGEST_TASK_MS = 1000;

  /**
   * This yields the top-level tasks on the given thread in the given range
   * whose duration is longer than LONG_TASK_MS.
   *
   * @param {tr.model.Thread} thread
   * @param {tr.b.math.Range=} opt_range
   */
  function* iterateLongTopLevelTasksOnThreadInRange(thread, opt_range) {
    for (const slice of thread.sliceGroup.topLevelSlices) {
      if (opt_range &&
          !opt_range.intersectsExplicitRangeInclusive(slice.start, slice.end)) {
        continue;
      }

      if (slice.duration < LONG_TASK_MS) continue;

      yield slice;
    }
  }

  /**
   * This yields the main renderer threads in the model.
   *
   * @param {tr.model.Model} model The model.
   */
  function* iterateRendererMainThreads(model) {
    const modelHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (modelHelper === undefined) return;
    for (const rendererHelper of Object.values(modelHelper.rendererHelpers)) {
      if (!rendererHelper.mainThread) continue;
      yield rendererHelper.mainThread;
    }
  }

  const BIN_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(
      LONG_TASK_MS, LONGEST_TASK_MS, 40);

  /**
   * This metric directly measures long tasks on renderer main threads.
   * This metric requires only the 'toplevel' tracing category.
   *
   * @param {!tr.v.HistogramSet} histograms
   * @param {!tr.model.Model} model
   * @param {!Object=} opt_options
   */
  function longTasksMetric(histograms, model, opt_options) {
    const rangeOfInterest = opt_options ? opt_options.rangeOfInterest :
      undefined;
    const longTaskHist = histograms.createHistogram(
        'longTasks', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, [], {
          description: 'wall durations of long tasks',
          binBoundaries: tr.v.HistogramBinBoundaries.createLinear(
              LONG_TASK_MS, LONGEST_TASK_MS, 40),
        });

    const relatedHistograms = new Map();
    const relatedNames = new tr.v.d.RelatedNameMap();
    longTaskHist.diagnostics.set('breakdown', relatedNames);
    const binBoundaries = tr.v.HistogramBinBoundaries.createExponential(
        1, LONGEST_TASK_MS, 40);

    for (const thread of iterateRendererMainThreads(model)) {
      for (const task of iterateLongTopLevelTasksOnThreadInRange(
          thread, rangeOfInterest)) {
        const breakdown = new tr.v.d.Breakdown();
        breakdown.colorScheme =
          tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;
        for (const slice of task.descendentSlices) {
          const category = model.getUserFriendlyCategoryFromEvent(slice) ||
            'unknown';
          const relatedName = `longTasks:${category}`;
          let relatedHist = relatedHistograms.get(category);
          if (!relatedHist) {
            relatedHist = histograms.createHistogram(
                relatedName, longTaskHist.unit, [], {
                  binBoundaries,
                });
            relatedHistograms.set(category, relatedHist);
            relatedNames.set(category, relatedName);
          }
          const sample = slice.cpuSelfTime;
          breakdown.set(category, breakdown.get(category) + sample);
          relatedHist.addSample(sample, {
            event: new tr.v.d.RelatedEventSet(slice),
          });
        }

        longTaskHist.addSample(task.duration, {
          breakdown,
          task: new tr.v.d.RelatedEventSet(task),
        });
      }
    }
  }

  tr.metrics.MetricRegistry.register(longTasksMetric, {
    supportsRangeOfInterest: true,
    requiredCategories: ['toplevel'],
  });

  return {
    longTasksMetric,
  };
});
</script>
