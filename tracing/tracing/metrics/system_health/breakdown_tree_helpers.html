<!DOCTYPE html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/category_util.html">
<link rel="import" href="/tracing/base/math/statistics.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/metrics/system_health/utils.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/timed_event.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {

  function getSelfTimeRanges(event) {
    const selfTimeRanges = [event.range];
    for (const subSlice of event.subSlices) {
      if (selfTimeRanges.length === 0) return [];
      const lastRange = selfTimeRanges.pop();
      selfTimeRanges.push.apply(selfTimeRanges,
        tr.b.math.Range.findDifference(lastRange, subSlice.range));
    }
    return selfTimeRanges;
  }

  /**
  * @callback getEventAttributeCallback
  * @param {!tr.b.Event} event The event to read an attribute from.
  * @return {number} The value of the attribute.
  */

  /**
  * Generate a breakdown tree from all slices of |mainThread| in
  * |rangeOfInterest|. The callback functions |getEventSelfTime| specify how to
  * get selftime from a given event.
  *
  * @param  {!tr.model.Thread} mainThread
  * @param  {!tr.b.math.Range} rangeOfInterest
  * @callback {getEventAttributeCallback} getEventSelfTime
  * @return {Object.<string, Object>} A time breakdown object whose keys are
  * Chrome userfriendly title & values are an object that show the total spent
  * in |rangeOfInterest|, and the list of event labels of the
  * group and their total time in |rangeOfInterest|.
  *
  * Example:
  *   {
  *     layout: {
  *         total: 100,
  *         events: {'FrameView::performPreLayoutTasks': 20,..}},
  *     v8_runtime: {
  *         total: 500,
  *         events: {'String::NewExternalTwoByte': 0.5,..}},
  *     ...
  *   }
  */
  function generateTimeBreakdownTree(mainThread, rangeOfInterest,
      getEventSelfTime) {
    if (mainThread === null) return;
    const breakdownTree = {};
    for (const title of
        tr.e.chrome.ChromeUserFriendlyCategoryDriver.ALL_TITLES) {
      breakdownTree[title] = {total: 0, events: {}};
    }
    for (const event of mainThread.getDescendantEvents()) {
      // We use wall-clock-time start and end of events to determine the
      // intersection ratio for both wall-clock-time and cpu-time breakdown.
      const eventStart = event.start;
      const eventDuration = event.duration;
      const eventSelfTime = getEventSelfTime(event);
      const eventEnd = eventStart + eventDuration;
      if (!rangeOfInterest.intersectsExplicitRangeExclusive(
          eventStart, eventEnd)) {
        continue;
      }
      if (eventSelfTime === undefined) continue;
      const title =
          tr.e.chrome.ChromeUserFriendlyCategoryDriver.fromEvent(event);
      // let timeIntersectionRatio = 0;
      // if (eventDuration > 0) {
      //   timeIntersectionRatio =
      //       rangeOfInterest.findExplicitIntersectionDuration(
      //           eventStart, eventEnd) / eventDuration;
      // }

      const v8Runtime = event.args['runtime-call-stat'];
      if (v8Runtime !== undefined) {
        const v8RuntimeObject = JSON.parse(v8Runtime);
        for (const runtimeCall in v8RuntimeObject) {
          // When the V8 Runtime Object contains 2 values, the 2nd value
          // always represents the V8 Runtime duration.
          if (v8RuntimeObject[runtimeCall].length === 2) {
            if (breakdownTree.v8_runtime.events[runtimeCall] === undefined) {
              breakdownTree.v8_runtime.events[runtimeCall] = 0;
            }
            const runtimeTime = tr.b.Unit.timestampFromUs(
                v8RuntimeObject[runtimeCall][1] * timeIntersectionRatio);
            breakdownTree.v8_runtime.total += runtimeTime;
            breakdownTree.v8_runtime.events[runtimeCall] += runtimeTime;
          }
        }
      }
      //        [     Slice 1       ]   [      Slice  2   ]   [    Slice 3   ]
      //            [  Slice 4    ]                             [ Slice 5 ]
      //              [ Slice 6 ]                                  |
      //                 |                                         |
      //                 |                                         |
      //                 v                                         v
      //                start                                     end
      //
      // For the case where the |start| or |end| overlapped with some existing
      // slice (see above diagram), we approximate the overlapped self-time
      // by multiplying the ratio of overlapped wall time to the self-time.
      // There should be way to compute the exact number, but in practice,
      // this should rarely happen, and when it does, the overlapped range
      // is relative small so that using approximation here should be good
      // enough.
      // Parts of the event that is not
      const selfTimeRanges  = getSelfTimeRanges(event);
      // TODO: Add a non-explicit version of findIntersectionDuration
      const selfTimesInRangeOfInterest = selfTimeRanges.map(
          range => rangeOfInterest.findExplicitIntersectionDuration(range.min, range.max));
      const selfTimeContribution =
          tr.b.math.Statistics.sum(selfTimesInRangeOfInterest);
      breakdownTree[title].total += selfTimeContribution
      if (breakdownTree[title].events[event.title] === undefined) {
        breakdownTree[title].events[event.title] = 0;
      }
      breakdownTree[title].events[event.title] +=
          selfTimeContribution;
    }
    return breakdownTree;
  }

  function findRemainingRanges(rangeOfInterest, eventRanges) {
    let idleRanges = [rangeOfInterest];
    eventRanges.sort((a, b) => a.min - b.min);
    for (const eventRange of eventRanges) {
      if (!eventRange || eventRange.isEmpty ||
          eventRange.duration < 0) {
        throw new Error('Range is invalid');
      }
      // Every eventRange does not intersect with any idleRanges prior to the
      // last freeRange, because:
      //
      // freeRange[last-1].max <= eventRange[i-1].min <= eventRange[i].min
      //             (due to subtraction)      (due to sorting)
      //
      // where 'i' is the current index of eventRange.
      const newLastIdleRanges =
          tr.b.math.Range.findDifference(
              idleRanges[idleRanges.length - 1], eventRange);
      idleRanges.pop();
      idleRanges = idleRanges.concat(newLastIdleRanges);
      if (idleRanges.length === 0) break;
    }
    return idleRanges;
  }

  function findEventsOnRange(events, range) {
    const results = [];
    for (const event of events) {
      if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
        results.push(event);
      }
    }
    return results;
  }

  function simplifyRanges(rangeOfInterest, ranges) {
    return findRemainingRanges(rangeOfInterest,
        findRemainingRanges(rangeOfInterest, ranges));
  }

  /**
   * Adds 'blocked_on_network' and 'idle' to the |breakdownTree| that has been
   * generated by |generateTimeBreakdownTree|. Taking into account the
   * |networkEvents|, this function is able to distinguish between these two
   * types of cpu idle time during the range |rangeOfInterest| not used by
   * events of the main thread |mainThreadEvents|.
   *
   * @param {!Object.<string, Object>} breakdownTree The breakdownTree that has
   * been generated by |generateTimeBreakdownTree|.
   * @param {!tr.b.Event} mainThreadEvents The top level events of the main
   * thread.
   * @param {!tr.b.Event} networkEvents The network events in the renderer.
   * @param {!tr.b.math.Range} rangeOfInterest The range for which
   * |breakdownTree| is calculated.
   */
  function addIdleAndBlockByNetworkBreakdown_(breakdownTree, mainThreadEvents,
      networkEvents, otherNetworkEvents, rangeOfInterest) {
    // console.log("addIdleAndBlockByNetworkBreakdown_ start");
    // console.log("rangeOfInterest: "+rangeOfInterest.min_ +", "+rangeOfInterest.max_);

    const mainThreadEventRanges = simplifyRanges(rangeOfInterest,
        tr.b.math.convertEventsToRanges(mainThreadEvents));
    // for (const event of mainThreadEventRanges) {
    //   console.log("mainThreadRange: "+event.min_ +", "+event.max_);
    // }
    const networkEventRanges = simplifyRanges(rangeOfInterest,
        tr.b.math.convertEventsToRanges(networkEvents));
    // for (const event of networkEventRanges) {
    //   console.log("networkRange: "+event.min_ +", "+event.max_);
    // }
    const otherNetworkEventRanges = simplifyRanges(rangeOfInterest,
        tr.b.math.convertEventsToRanges(otherNetworkEvents));
    // for (const event of otherNetworkEventRanges) {
    //   console.log("otherNetworkEventRanges: "+event.min_ +", "+event.max_);
    // }

    // Add breakdownTree.idle
    const onlyIdleRanges = findRemainingRanges(
        rangeOfInterest,
        mainThreadEventRanges.concat(networkEventRanges).concat(
            otherNetworkEventRanges));
    // for (const event of onlyIdleRanges) {
    //   console.log("idleRange: "+event.min_ +", "+event.max_);
    // }
    const totalOnlyIdleDuration = tr.b.math.Statistics.sum(onlyIdleRanges,
        range => range.duration);
    breakdownTree.idle = {total: totalOnlyIdleDuration, events: {}};

    // Add breakdownTree.otherNetworkActivities
    const onlyOtherNetworkRanges = findRemainingRanges(
        rangeOfInterest,
        mainThreadEventRanges.concat(networkEventRanges).concat(
            onlyIdleRanges));
    const totalOtherNetworkDuration = tr.b.math.Statistics.sum(
        onlyOtherNetworkRanges, range => range.duration);
    breakdownTree.otherNetworkActivities =
        {total: totalOtherNetworkDuration, events: {}};
    // for (const event of onlyOtherNetworkRanges) {
    //   console.log("onlyOtherNetworkRanges: " + event.min_ + ", " + event.max_);
    // }

    // Add breakdownTree["blocked_on_network_" + resourceType]
    const blockedOnNetworkRanges = findRemainingRanges(
        rangeOfInterest,
        mainThreadEventRanges.concat(onlyIdleRanges).concat(
            onlyOtherNetworkRanges));
    const totalBlockedDuration = tr.b.math.Statistics.sum(
        blockedOnNetworkRanges, range => range.duration);

    // for (const event of blockedOnNetworkRanges) {
    //   console.log("blockedOnNetworkRanges: " + event.min_ + ", " + event.max_);
    // }
    const blockedHist = {};
    let normalizingFactor = 0;
    for (const blockedRange of blockedOnNetworkRanges) {
      const events = findEventsOnRange(networkEvents, blockedRange);
      for (const event of events) {
        if (!("resourceType" in event.args)) continue;
        const st = event.args.resourceType.resourceType;
        var resourceType = st.replace(" ", "_");
        if (!(resourceType in blockedHist)) {
          blockedHist[resourceType] = 0;
        }
        const networkRange = tr.b.math.Range.fromExplicitRange(
            event.start, event.end);
        const duration = networkRange.findIntersection(blockedRange).duration;
        blockedHist[resourceType] += duration;
        normalizingFactor += duration;
      }
    }

    for (const resourceType in blockedHist) {
      breakdownTree["blocked_on_network_" + resourceType] = {
        total: blockedHist[resourceType] / normalizingFactor *
            totalBlockedDuration,
        events: {}
      };
    }

    // console.log("rangeOfInterest.duration: "+rangeOfInterest.duration)
    // console.log("addIdleAndBlockByNetworkBreakdown_ end");
  }

  /**
  * Generate a breakdown that attributes where wall clock time goes in
  * |rangeOfInterest| on the renderer thread.
  *
  * @param {!tr.model.Thread} mainThread
  * @param {!tr.b.math.Range} rangeOfInterest
  * @return {Object.<string, Object>} A time breakdown object whose keys are
  * Chrome userfriendly titles & values are an object that shows the total
  * wall clock time spent in |rangeOfInterest|, and the list of event
  * labels of the group and their total wall clock time in |rangeOfInterest|.
  *
  * Example:
  *   {
  *     layout: {
  *         total: 100,
  *         events: {'FrameView::performPreLayoutTasks': 20,..}},
  *     v8_runtime: {
  *         total: 500,
  *         events: {'String::NewExternalTwoByte': 0.5,..}},
  *     ...
  *   }
  */
  function generateWallClockTimeBreakdownTree(
      mainThread, networkEvents, otherNetworkEvents, rangeOfInterest) {
    function getEventSelfTime(e) { return e.selfTime; }
    const breakdownTree = generateTimeBreakdownTree(
        mainThread, rangeOfInterest, getEventSelfTime);
    const mainThreadEventsInRange = tr.model.helpers.getSlicesIntersectingRange(
        rangeOfInterest, mainThread.sliceGroup.topLevelSlices);
    addIdleAndBlockByNetworkBreakdown_(
        breakdownTree, mainThreadEventsInRange, networkEvents,
        otherNetworkEvents, rangeOfInterest);
    return breakdownTree;
  }

  /**
  * Generate a breakdown that attributes where CPU time goes in
  * |rangeOfInterestCpuTime| on the renderer thread.
  *
  * @param {!tr.model.Thread} mainThread
  * @param {!tr.b.math.Range} rangeOfInterestCpuTime
  * @return {Object.<string, Object>} A time breakdown object whose keys are
  * Chrome userfriendly titles & values are an object that shows the total
  * CPU time spent in |rangeOfInterestCpuTime|, and the list of event labels
  * of the group and their total durations in |rangeOfInterestCpuTime|.
  *
  * Example:
  *   {
  *     layout: {
  *         total: 100,
  *         events: {'FrameView::performPreLayoutTasks': 20,..}},
  *     v8_runtime: {
  *         total: 500,
  *         events: {'String::NewExternalTwoByte': 0.5,..}},
  *     ...
  *   }
  */
  function generateCpuTimeBreakdownTree(mainThread, rangeOfInterest) {
    function getEventSelfTime(e) { return e.cpuSelfTime; }
    return generateTimeBreakdownTree(
        mainThread, rangeOfInterest, getEventSelfTime);
  }

  return {
    generateTimeBreakdownTree,
    generateWallClockTimeBreakdownTree,
    generateCpuTimeBreakdownTree,
  };
});
</script>
