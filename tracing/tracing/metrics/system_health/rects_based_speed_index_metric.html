<!DOCTYPE html>
<!--
Copyright 2019 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/chrome/speed_index_utils.html">
<link rel="import" href="/tracing/metrics/system_health/breakdown_tree_helpers.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const SpeedIndex = tr.e.chrome.SpeedIndex;
  const EventFinderUtils = tr.e.chrome.EventFinderUtils;

  const LOADING_METRIC_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createLinear(0, 1e3, 20)  // 50ms step to 1s
      .addLinearBins(3e3, 20) // 100ms step to 3s
      .addExponentialBins(20e3, 20);


  const SUMMARY_OPTIONS = {
    avg: true,
    count: false,
    max: true,
    min: true,
    std: true,
    sum: false,
  };

  /**
   * Adds a speed index sample.
   *
   * @param {tr.model.helpers.ChromeBrowserrHelper} browserHelper
   * @param {number[]} samples
   * @param {tr.model.ThreadSlice} navigationStart
   */
  function addRectsBasedSpeedIndexSample(samples, rendererHelper,
      navigationStart, loadDuration, frameID) {
    let viewport;
    for (const event of EventFinderUtils.getMainThreadEvents(rendererHelper,
        'viewport', 'loading')) {
      if (event.args.data.frameID === frameID &&
        event.start < (navigationStart + loadDuration)) {
        viewport = event.args.data;
        break;
      }
    }
    if (!viewport) return;
    const timestampedPaintRects = [];
    for (const event of EventFinderUtils.getMainThreadEvents(rendererHelper,
        'PaintTracker::LayoutObjectPainted', 'loading')) {
      if (event.start >= navigationStart &&
        event.start < navigationStart + loadDuration) {
        timestampedPaintRects.push({
          rect: SpeedIndex.quadToRect(event.args.data.visible_new_visual_rect),
          ts: event.start});
      }
    }
    const numberOfRects = timestampedPaintRects.length;
    if (numberOfRects === 0) return;
    const areaAddedAtTimestamp = new Array(numberOfRects);
    const rects = [];
    let previousAreaOfUnion = 0;
    let totalAreaOfUnion = 0;
    for (let i = numberOfRects - 1; i >= 0; i--) {
      rects.push(timestampedPaintRects[i].rect);
      const currentAreaOfUnion = SpeedIndex.lineSweep(rects, viewport);
      areaAddedAtTimestamp[numberOfRects - i - 1] =
          {value: currentAreaOfUnion - previousAreaOfUnion,
            ts: timestampedPaintRects[i].ts};
      totalAreaOfUnion +=
          areaAddedAtTimestamp[numberOfRects - i - 1].value;
      previousAreaOfUnion = currentAreaOfUnion;
    }
    // Paint progress at a timestamp is the total area of the viewport that has
    // reached its final state before that timestamp over the total area
    // painted by the end of loading.
    const paintProgressAtTimestamp = new Array(numberOfRects);
    let lastProgressRecorded = 0;
    for (let i = 0; i < numberOfRects; i++) {
      paintProgressAtTimestamp[i] = {
        value: areaAddedAtTimestamp[i].value / totalAreaOfUnion +
            lastProgressRecorded,
        ts: areaAddedAtTimestamp[i].ts};
      lastProgressRecorded = paintProgressAtTimestamp[i].value;
    }
    samples.push({
      value: SpeedIndex.calculateRectsBasedSpeedIndex(paintProgressAtTimestamp)
    });
  }

  function collectRectsBasedSpeedIndexSamplesFromLoadExpectations(model,
      chromeHelper) {
    const rectsBasedSpeedIndexSamples = [];
    for (const expectation of model.userModel.expectations) {
      if (!(expectation instanceof tr.model.um.LoadExpectation)) continue;
      if (tr.e.chrome.CHROME_INTERNAL_URLS.includes(expectation.url)) {
        continue;
      }
      const rendererHelper = chromeHelper.rendererHelpers[
          expectation.renderProcess.pid];
      addRectsBasedSpeedIndexSample(rectsBasedSpeedIndexSamples, rendererHelper,
          expectation.navigationStart.start, expectation.duration,
          expectation.navigationStart.args.frame);
    }
    return rectsBasedSpeedIndexSamples;
  }

  function rectsBasedSpeedIndexMetric(histograms, model) {
    const rectsBasedSpeedIndexHistogram = histograms.createHistogram(
        'rectsBasedSpeedIndex', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: LOADING_METRIC_BOUNDARIES,
          description: ' the average time at which visible parts of the' +
          ' page are displayed (in ms).',
          summaryOptions: SUMMARY_OPTIONS,
        });

    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);

    const samples = collectRectsBasedSpeedIndexSamplesFromLoadExpectations(
        model, chromeHelper);
    for (const sample of samples) {
      rectsBasedSpeedIndexHistogram.addSample(sample.value);
    }
  }

  tr.metrics.MetricRegistry.register(rectsBasedSpeedIndexMetric);

  return {
    rectsBasedSpeedIndexMetric
  };
});
</script>