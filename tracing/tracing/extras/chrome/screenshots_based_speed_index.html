<!DOCTYPE html>
<!--
Copyright 2019 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/math/earth_movers_distance.html">

<script>
'use strict';

tr.exportTo('tr.e.chrome', function() {
  /**
    * Object containing a value representing how similar the current snapshot
    * is to the last snapshot and the time when the snapshot was taken.
    * @typedef {{value: number, ts: number}} snapshotProgress
    *
    */
  /**
    * @param {[number[]]} screenshotsPixelValues
    * @param {number[]} timeStamps - It is assumed that the timestamps array
    * is in ascending order.
    * @return {snapshotProgress[]}
    */
  function getSnapshotsProgress(screenshotsPixelValues, timeStamps) {
    const numberOfScreenshots = screenshotsPixelValues.length;
    const firstHistogram = createColorHistogram(screenshotsPixelValues[0]);
    const lastHistogram =
        createColorHistogram(screenshotsPixelValues[numberOfScreenshots - 1]);
    const totalDistance =
        tr.b.math.earthMoversDistance(firstHistogram[0], lastHistogram[0]) +
        tr.b.math.earthMoversDistance(firstHistogram[1], lastHistogram[1]) +
        tr.b.math.earthMoversDistance(firstHistogram[2], lastHistogram[2]);
    if (totalDistance === 0) return [];
    const snapshotsProgress = new Array(numberOfScreenshots);
    for (let i = 0; i < numberOfScreenshots; i++) {
      const imagePixelValues = screenshotsPixelValues[i];
      const histogram = createColorHistogram(imagePixelValues);
      const distance =
        tr.b.math.earthMoversDistance(histogram[0], lastHistogram[0]) +
        tr.b.math.earthMoversDistance(histogram[1], lastHistogram[1]) +
        tr.b.math.earthMoversDistance(histogram[2], lastHistogram[2]);
      const moved = Math.max(totalDistance - distance, 0);
      snapshotsProgress[i] =
            {value: (moved / totalDistance), ts: timeStamps[i]};
    }
    return snapshotsProgress;
  }

  /**
    * Calculates the speed index given an array of snapshotProgress objects.
    *
    * Speed Index documentation:
    * https://sites.google.com/a/webpagetest.org/
    * docs/using-webpagetest/metrics/speed-index
    *
    * @param {snapshotProgress[]} snapshotsProgress - an array containing
    * snapshotProgress objects
    * @return {number} - speed index
    */
  function calculateSpeedIndex(snapshotsProgress) {
    let prevSnapshotTimeTaken = 0;
    let prevSnapshotProgress = 0;
    let speedIndex = 0;
    const numberOfScreenshots = snapshotsProgress.length;
    for (let i = 0; i < numberOfScreenshots; i++) {
      const elapsed = snapshotsProgress[i].ts - prevSnapshotTimeTaken;
      speedIndex += elapsed * (1.0 - prevSnapshotProgress);
      prevSnapshotTimeTaken = snapshotsProgress[i].ts;
      prevSnapshotProgress = snapshotsProgress[i].value;
    }
    return Math.round(speedIndex);
  }


  /** Extracts a color histogram from a flat array
    * containing rgba values for each pixel.
    * The resulting histogram has 3 channels (RGB),
    * each channel has 256 buckets. Counts the number
    * of pixels with the given color.
    *
    * @param {number[]} imagePixelValues - flat array of rgba
    * pixel values.
    * @return {histogram}
    */
  function createColorHistogram(imagePixelValues) {
    const n = imagePixelValues.length;
    const histogram = new Array(3);
    for (let j = 0; j < 3; j++) {
      histogram[j] = new Array(256).fill(0);
    }
    for (let i = 0; i < n; i += 4) {
      const r = imagePixelValues[i];
      const g = imagePixelValues[i + 1];
      const b = imagePixelValues[i + 2];
      histogram[0][r]++;
      histogram[1][g]++;
      histogram[2][b]++;
    }
    return histogram;
  }

  return {
    getSnapshotsProgress,
    calculateSpeedIndex,
    createColorHistogram
  };
});
</script>
