<!DOCTYPE html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">
<script>
'use strict';

/**
 * @fileoverview Base class for linux perf event parsers.
 *
 * The linux perf trace event importer depends on subclasses of
 * Parser to parse event data.  Each subclass corresponds
 * to a group of trace events; e.g. SchedParser implements
 * parsing of sched:* kernel trace events.  Parser subclasses must
 * call Parser.register to arrange to be instantiated
 * and their constructor must register their event handlers with the
 * importer.  For example,
 *
 * var Parser = tr.e.importer.linux_perf.Parser;
 *
 * function WorkqueueParser(importer) {
 *   Parser.call(this, importer);
 *
 *   importer.registerEventHandler('workqueue_execute_start',
 *       WorkqueueParser.prototype.executeStartEvent.bind(this));
 *   importer.registerEventHandler('workqueue_execute_end',
 *       WorkqueueParser.prototype.executeEndEvent.bind(this));
 * }
 *
 * Parser.register(WorkqueueParser);
 *
 * When a registered event name is found in the data stream the associated
 * event handler is invoked:
 *
 *   executeStartEvent: function(eventName, cpuNumber, ts, eventBase)
 *
 * If the routine returns false the caller will generate an import error
 * saying there was a problem parsing it.  Handlers can also emit import
 * messages using this.importer.model.importWarning.  If this is done in lieu of
 * the generic import error it may be desirable for the handler to return
 * true.
 *
 * Trace events generated by writing to the trace_marker file are expected
 * to have a leading text marker followed by a ':'; e.g. the trace clock
 * synchronization event is:
 *
 *  tracing_mark_write: trace_event_clock_sync: parent_ts=0
 *
 * To register an event handler for these events, prepend the marker with
 * 'tracing_mark_write:'; e.g.
 *
 *    this.registerEventHandler('tracing_mark_write:trace_event_clock_sync',
 *
 * All subclasses should depend on importer.linux_perf.parser, e.g.
 *
 * tr.defineModule('importer.linux_perf.workqueue_parser')
 *   .dependsOn('importer.linux_perf.parser')
 *   .exportsTo('tracing', function()
 *
 * and be listed in the dependsOn of FTraceImporter.  Beware that after adding a
 * new subclass you must run build/generate_about_tracing_contents.py to
 * regenerate tr.ui.e.about_tracing.*.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses v4l2 events.
   * @constructor
   */
  function V4l2Parser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('vb2_v4l2_qbuf',
        V4l2Parser.prototype.printEvent.bind(this));
    importer.registerEventHandler('vb2_v4l2_dqbuf',
        V4l2Parser.prototype.printEvent.bind(this));
    importer.registerEventHandler('vb2_v4l2_buf_queue',
        V4l2Parser.prototype.printEvent.bind(this));
    importer.registerEventHandler('vb2_v4l2_buf_done',
        V4l2Parser.prototype.printEvent.bind(this));
    importer.registerEventHandler('v4l2_qbuf',
        V4l2Parser.prototype.printEvent.bind(this));
    importer.registerEventHandler('v4l2_dqbuf',
        V4l2Parser.prototype.printEvent.bind(this));

    this.model_ = importer.model_;
  }

  V4l2Parser.prototype = {
    __proto__: Parser.prototype,

    printEvent(eventName, cpuNumber, pid, ts, eventBase) {
      // console.log(eventName, cpuNumber, pid, ts, eventBase.details);

      // begin
      const thread = this.model_.getOrCreateProcess(123)
          .getOrCreateThread(pid);
      thread.name = eventBase.threadName;
      thread.sliceGroup.beginSlice('v4l2 test category', 'v4l2 test title',
          ts, {detail: eventBase.details});

      // end
      const slice = thread.sliceGroup.endSlice(ts);
    }
  };

  Parser.register(V4l2Parser);

  return {
    V4l2Parser
  };
});
</script>
