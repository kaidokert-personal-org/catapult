<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/fixed_color_scheme.html">
<link rel="import" href="/tracing/extras/chrome/chrome_user_friendly_category_driver.html">
<link rel="import" href="/tracing/metrics/all_fixed_color_schemes.html">
<link rel="import" href="/tracing/ui/base/column_chart.html">
<link rel="import" href="/tracing/ui/base/dom_helpers.html">
<link rel="import" href="/tracing/ui/base/table.html">
<link rel="import" href="/tracing/value/ui/diagnostic_span_behavior.html">

<dom-module id="tr-v-ui-breakdown-span">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #table_container {
      display: flex;
      flex: 0 0 auto;
    }
    #table {
      max-height: 150px;
      overflow-y: auto;
    }
    </style>

    <div id="empty">(empty)</div>
    <div id="table_container">
      <div id="container"></div>
      <span>
        <tr-ui-b-table id="table"></tr-ui-b-table>
      </span>
    </div>
  </template>
</dom-module>

<script>
'use strict';
tr.exportTo('tr.v.ui', function() {
  const DEFAULT_COLOR_SCHEME = new tr.b.SinebowColorGenerator();

  function getHistogramName(histogram, diagnosticName, key) {
    if (histogram === undefined) return undefined;
    const nameMap = histogram.diagnostics.get(diagnosticName);
    if (nameMap === undefined) return undefined;
    return nameMap.get(key);
  }

  function getColorScheme(colorSchemeName) {
    if (colorSchemeName ===
        tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER) {
      return name => {
        let cat = name.split(' ');
        cat = cat[cat.length - 1];
        return tr.e.chrome.ChromeUserFriendlyCategoryDriver.getColor(cat);
      };
    }

    if (colorSchemeName !== undefined) {
      return name => tr.b.FixedColorSchemeRegistry.lookUp(
          colorSchemeName).getColor(name);
    }

    return name => DEFAULT_COLOR_SCHEME.colorForKey(name);
  }

  function getUnit(name, histograms) {
    const candidates = histograms.getHistogramsNamed(name);
    if (candidates.length === 0) return undefined;
    return candidates[0].unit;
  }

  class BreakdownTableSummaryRow {
    constructor(valueSpan, histogramNames) {
      this.valueSpan_ = valueSpan;
      this.histogramNames_ = histogramNames;
      this.keySpan_ = undefined;
    }

    get sanitizedValue() {
      // Prevent this row from appearing in the ColumnChart.
      return undefined;
    }

    get keySpan() {
      if (this.keySpan_ === undefined) {
        if (this.histogramNames_.length) {
          this.keySpan_ = document.createElement('tr-ui-a-analysis-link');
          this.keySpan_.setSelectionAndContent(
              this.histogramNames_, 'Select All');
        } else {
          this.keySpan_ = 'Sum';
        }
      }
      return this.keySpan_;
    }

    get name() {
      return 'Sum';
    }

    get valueSpan() {
      return this.valueSpan_;
    }

    get percentString() {
      return '100%';
    }
  }

  class BreakdownTableRow {
    constructor(name, value, histogramName, unit, color) {
      this.name_ = name;
      this.value_ = value;
      this.histogramName_ = histogramName;
      this.unit_ = unit;

      if (typeof value !== 'number') {
        throw new Error('unsupported value ' + value);
      }

      this.tableSum_ = undefined;
      this.keySpan_ = undefined;

      this.color_ = color;
      const hsl = this.color.toHSL();
      hsl.l *= 0.85;
      this.highlightedColor_ = tr.b.Color.fromHSL(hsl);

      if (this.sanitizedValue !== undefined && this.unit_) {
        this.valueSpan_ = tr.v.ui.createScalarSpan(this.sanitizedValue, {
          unit: this.unit_,
        });
      } else {
        this.valueSpan_ = tr.ui.b.createSpan({
          textContent: this.stringValue,
        });
      }
    }

    get name() {
      return this.name_;
    }

    get unit() {
      return this.unit_;
    }

    /**
     * @return {number|undefined}
     */
    get sanitizedValue() {
      if (isNaN(this.value_) ||
          this.value_ === Infinity ||
          this.value_ === -Infinity ||
          this.value_ < 0) {
        return undefined;
      }
      return this.value_;
    }

    get color() {
      return this.color_;
    }

    get highlightedColor() {
      return this.highlightedColor_;
    }

    get keySpan() {
      if (this.keySpan_ === undefined) {
        if (this.histogramName_) {
          this.keySpan_ = document.createElement('tr-ui-a-analysis-link');
          this.keySpan_.setSelectionAndContent(
              [this.histogramName_], this.name);
          this.keySpan_.color = this.color;
          this.keySpan_.title = this.histogramName_;
        } else {
          this.keySpan_ = tr.ui.b.createSpan({
            textContent: this.name,
            color: this.color,
          });
        }
      }
      return this.keySpan_;
    }

    get stringValue() {
      if (this.unit !== undefined) return this.unit.format(this.value_);
      return this.value_.toString();
    }

    set tableSum(s) {
      this.tableSum_ = s;
    }

    get percentString() {
      if (this.tableSum_ === undefined) return '';
      const num = this.sanitizedValue;
      if (num === undefined) return '';
      return Math.floor(num * 100.0 / this.tableSum_) + '%';
    }

    get valueSpan() {
      return this.valueSpan_;
    }

    compare(other) {
      if (this.sanitizedValue === undefined) {
        if (other.sanitizedValue === undefined) {
          return this.name.localeCompare(other.name);
        }
        return 1;
      }
      if (other.sanitizedValue === undefined) {
        return -1;
      }
      if (this.sanitizedValue === other.sanitizedValue) {
        return this.name.localeCompare(other.name);
      }
      return other.sanitizedValue - this.sanitizedValue;
    }
  }

  Polymer({
    is: 'tr-v-ui-breakdown-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    created() {
      this.chart_ = new tr.ui.b.ColumnChart();
      this.chart_.graphHeight = 130;
      this.chart_.isStacked = true;
      this.chart_.hideXAxis = true;
      this.chart_.hideLegend = true;
      this.chart_.enableHoverBox = false;
      this.chart_.addEventListener('rect-mouseenter',
          event => this.onRectMouseEnter_(event));
      this.chart_.addEventListener('rect-mouseleave',
          event => this.onRectMouseLeave_(event));
    },

    onRectMouseEnter_(event) {
      for (const row of this.$.table.tableRows) {
        if (row.name === event.rect.key) {
          row.valueSpan.style.background = event.rect.color;
          row.keySpan.scrollIntoViewIfNeeded();
        } else {
          row.valueSpan.style.background = '';
        }
      }
    },

    onRectMouseLeave_(event) {
      for (const row of this.$.table.tableRows) {
        row.valueSpan.style.background = '';
      }
    },

    ready() {
      Polymer.dom(this.$.container).appendChild(this.chart_);

      this.$.table.zebra = true;
      this.$.table.showHeader = false;
      this.$.table.tableColumns = [
        {
          value: row => row.keySpan,
        },
        {
          value: row => row.valueSpan,
          align: tr.ui.b.TableFormat.ColumnAlignment.RIGHT,
        },
        {
          value: row => row.percentString,
          align: tr.ui.b.TableFormat.ColumnAlignment.RIGHT,
        },
      ];
    },

    updateContents_() {
      this.$.container.style.display = 'none';
      this.$.table.style.display = 'none';
      this.$.empty.style.display = 'block';

      if (!this.diagnostic_ || this.diagnostic_.size === 0) {
        this.chart_.data = [];
        return;
      }

      const colorScheme = getColorScheme(this.diagnostic.colorScheme);
      const tableRows = [];
      const histogramNames = new Set();
      let tableSum = 0;
      const histogramNames = [];
      for (const [key, value] of this.diagnostic) {
        const histogramName = getHistogramName(
            this.histogram_, this.name_, key);
        const unit = getUnit(histogramName, this.histograms_);
        const row = new BreakdownTableRow(
            key, value, histogramName, unit, colorScheme(key));
        tableRows.push(row);
        if (row.sanitizedValue !== undefined) tableSum += row.sanitizedValue;
        if (histogramName) {
          histogramNames.push(histogramName);
        }
      }
      tableRows.sort((x, y) => x.compare(y));

      let unit = tableRows[0].unit;
      for (const row of tableRows.slice(1)) {
        if (row.unit !== unit) {
          unit = undefined;
          break;
        }
      }
      this.chart_.unit = unit;

      if (tableRows.length > 1) {
        let summaryDisplayElement = tableSum;
        if (this.chart_.unit !== undefined) {
          summaryDisplayElement = this.chart_.unit.format(tableSum);
        }
        summaryDisplayElement = tr.ui.b.createSpan({
          textContent: summaryDisplayElement,
        });
        tableRows.unshift(new BreakdownTableSummaryRow(
            summaryDisplayElement, histogramNames));
      }

      const chartData = {x: 0};
      for (const row of tableRows) {
        if (row.sanitizedValue === undefined) continue;

        if (tableRows.length > 1) {
          // Let the row compute its percentage.
          row.tableSum = tableSum;
        }

        // Add it to the chart.
        chartData[row.name] = row.sanitizedValue;

        // Configure the colors.
        const dataSeries = this.chart_.getDataSeries(row.name);
        dataSeries.color = row.color;
        dataSeries.highlightedColor = row.highlightedColor;
      }

      if (tableRows.length > 0) {
        this.$.table.style.display = 'block';
        this.$.empty.style.display = 'none';
        this.$.table.tableRows = tableRows;
        this.$.table.rebuild();
      }

      if (Object.keys(chartData).length > 2) {
        this.$.container.style.display = 'block';
        this.$.empty.style.display = 'none';
        this.chart_.data = [chartData];
      }
    }
  });

  return {};
});
</script>
