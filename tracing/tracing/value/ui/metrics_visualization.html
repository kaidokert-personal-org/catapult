<!DOCTYPE html>
<!--
Copyright (c) 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/math/math.html">
<link rel="import" href="/tracing/base/math/running_statistics.html">
<link rel="import" href="/tracing/ui/base/name_bar_chart.html">
<link rel="import" href="/tracing/ui/base/name_column_chart.html">
<dom-module id='tr-v-ui-metrics-visualization'>
  <template>
    <style>
      button {
        padding: 5px;
        font-size: 14px;
      }

      .text_input {
        width: 50px;
        padding: 4px;
        font-size: 14px;
      }
      .error {
        color: red;
        display: none;
      }

      .child_container {
        position: relative;
        display: inline-block;
      }

      #title {
        font-size: 20px;
        font-weight: bold;
        padding-bottom: 5px;
      }

      #selectors {
        display: none;
        padding-bottom: 10px;
        display: none;
      }

      #search_page {
        width: 200px;
        margin-left: 30px;
      }

      #close {
        display: none;
        vertical-align: top;
      }

      #close svg{
        height: 1em;
      }

      #close svg line {
        stroke-width: 18;
        stroke: black;
      }

      #close:hover svg {
        background: black;
      }

      #close:hover svg line {
        stroke: white;
      }
    </style>
    <div id="title">Metrics Visualization</div>
    <div id="data_error" class="error">Invalid data provided.</div>
    <div id="selectors">
      <div id="percentile_label">Percentile Range:</div>
      <input id="start" class="text_input" placeholder="0">
      <input id="end" class="text_input" placeholder="100">
      <button id="filter" on-tap="filterByPercentile_">Filter</button>
      <input id="search_page" class="text_input" placeholder="Page Name">
      <button id="search" on-tap="searchByPage_">Search</button>
      <div id="search_error" class="error">Sorry, could not find that page!</div>
    </div>
    <div id="container">
    </div>
    <div id="children">
    </div>
    <span id="close">
      <svg viewbox="0 0 128 128">
        <line x1="28" y1="28" x2="100" y2="100"/>
        <line x1="28" y1="100" x2="100" y2="28"/>
      </svg>
    </span>
  </template>
</dom-module>
<script>
'use strict';

const COLORS = [
  ['#FFD740', '#FFC400', '#FFAB00', '#E29800'],
  ['#FF6E40', '#FF3D00', '#DD2C00', '#A32000'],
  ['#40C4FF', '#00B0FF', '#0091EA', '#006DAF'],
  ['#89C641', '#54B503', '#4AA510', '#377A0D'],
  ['#B388FF', '#7C4DFF', '#651FFF', '#6200EA'],
  ['#FF80AB', '#FF4081', '#F50057', '#C51162'],
  ['#FFAB40', '#FF9100', '#FF6D00', '#D65C02'],
  ['#8C9EFF', '#536DFE', '#3D5AFE', '#304FFE']];

const METRICS = new Map([
  ['Pipeline', [
    'pipeline:begin_frame_transport',
    'pipeline:begin_frame_to_frame_submission',
    'pipeline:frame_submission_to_display',
    'pipeline:draw']],
  ['Thread', [
    'thread_browser_cpu_time_per_frame',
    'thread_display_compositor_cpu_time_per_frame',
    'thread_GPU_cpu_time_per_frame',
    'thread_IO_cpu_time_per_frame',
    'thread_other_cpu_time_per_frame',
    'thread_raster_cpu_time_per_frame',
    'thread_renderer_compositor_cpu_time_per_frame',
    'thread_renderer_main_cpu_time_per_frame']],
  ['Thread_tbmv2', [
    'thread_browser_cpu_time_per_frame_tbmv2',
    'thread_display_compositor_cpu_time_per_frame_tbmv2',
    'thread_gpu_cpu_time_per_frame_tbmv2',
    'thread_io_cpu_time_per_frame_tbmv2',
    'thread_other_cpu_time_per_frame_tbmv2',
    'thread_raster_cpu_time_per_frame_tbmv2',
    'thread_renderer_compositor_cpu_time_per_frame_tbmv2',
    'thread_renderer_main_cpu_time_per_frame_tbmv2']]]);

// Used to access the running statistic of a metric
const STATISTIC_KEY = 'statistic';
const DELAY_KEY = 'Delay';

Polymer({
  is: 'tr-v-ui-metrics-visualization',

  created() {
    this.sortedPageNames_ = new Map();
    this.sortedBenchmarkTimes_ = new Map();
    this.groupedPageData_ = new Map();
    this.charts_ = new Map();
    this.subMetricNames_ = new Map();
  },

  build(leafHistograms, histograms) {
    if (!leafHistograms || leafHistograms.length < 1 ||
        !histograms || histograms.length < 1) {
      this.$.data_error.style.display = 'block';
      return;
    }

    this.histograms = histograms;

    for (const key of METRICS.keys()) {
      const newAggregateChart = this.initializeColumnChart(key);
      Polymer.dom(this.$.container).appendChild(newAggregateChart);
      this.populateChart_(leafHistograms, key, newAggregateChart, true);
      newAggregateChart.toolTipCallBack = () =>
        this.openMetricsChart_(key);
    }

    if (this.groupedPageData_.size < 1) {
      this.$.data_error.style.display = 'block';
      return;
    }
  },

  populateChart_(histograms, metricName, chart, aggregate) {
    const storiesGrouping = tr.v.HistogramGrouping.BY_KEY.get(
        tr.v.d.RESERVED_NAMES.STORIES);
    const benchmarkStartGrouping = tr.v.HistogramGrouping.BY_KEY.get(
        tr.v.d.RESERVED_NAMES.BENCHMARK_START);

    const benchmarkTimes = new Map();
    const groupedPageData = new Map();

    for (const metric of METRICS.get(metricName)) {
      const metricHistograms = histograms.getHistogramsNamed(metric);
      for (const histogram of metricHistograms) {
        const benchmarkStart = benchmarkStartGrouping.callback(histogram);
        const page = storiesGrouping.callback(histogram);
        const benchmarkTime = tr.v.HistogramGrouping.
            DISPLAY_LABEL.callback(histogram);
        const average = histogram.average === undefined ? 0 :
          histogram.average;

        benchmarkTimes.set(benchmarkTime, Date.parse(benchmarkStart));

        let pageMap = new Map();
        let benchmarkTimeMap = new Map();

        if (groupedPageData.get(page) === undefined) {
          groupedPageData.set(page, pageMap);
          pageMap.set(benchmarkTime, benchmarkTimeMap);
        } else {
          pageMap = groupedPageData.get(page);
          if (pageMap.get(benchmarkTime) === undefined) {
            pageMap.set(benchmarkTime, benchmarkTimeMap);
          } else {
            benchmarkTimeMap = pageMap.get(benchmarkTime);
          }
        }

        let metricMap = new Map();
        let statistic = new tr.b.math.RunningStatistics();
        if (benchmarkTimeMap.has(metric)) { // Check for repeated page sets
          metricMap = benchmarkTimeMap.get(metric);
          statistic = metricMap.get(STATISTIC_KEY);
        }
        statistic.add(average);
        metricMap.set(STATISTIC_KEY, statistic);
        benchmarkTimeMap.set(metric, metricMap);

        const merged = new tr.v.d.DiagnosticMap();
        for (const bin of histogram.allBins) {
          for (const map of bin.diagnosticMaps) {
            merged.addDiagnostics(map);
          }
        }

        const subMetrics = [];
        if (merged.get('breakdown') === undefined) {
          metricMap.set(metric, statistic);
          subMetrics.push(metric);
        } else {
          for (const [subMetric, total] of merged.get('breakdown')) {
            let subStatistic = new tr.b.math.RunningStatistics();
            if (metricMap.has(subMetric)) { // Check for repeated page sets
              subStatistic = metricMap.get(subMetric);
            }
            subStatistic.add(total);
            metricMap.set(subMetric, subStatistic);
            subMetrics.push(subMetric);
          }
        }
        const prevSubMetrics = this.subMetricNames_.get(metric);
        if (!prevSubMetrics || subMetrics.length > prevSubMetrics.length) {
          this.subMetricNames_.set(metric, subMetrics);
        }
      }
    }

    const sortedBenchmarkTimes = this.getSortedBenchmarkTimes_(benchmarkTimes);
    const sortedPageNames = [...groupedPageData.keys()].sort((a, b) =>
      this.sortgroupedPageData_(a, b, groupedPageData,
          sortedBenchmarkTimes, METRICS.get(metricName)));

    this.setChartColors_(METRICS.get(metricName), sortedBenchmarkTimes, chart);
    this.setChartSize_(groupedPageData.size,
        sortedBenchmarkTimes.length, chart);
    this.setChartData_(groupedPageData, sortedPageNames,
        sortedBenchmarkTimes, chart);

    // so that there isn't two map entries with the same key
    let mapName = metricName;
    if (aggregate) {
      mapName = 'Aggregate ' + mapName;
    }

    this.groupedPageData_.set(mapName, groupedPageData);
    this.sortedBenchmarkTimes_.set(mapName, sortedBenchmarkTimes);
    this.sortedPageNames_.set(mapName, sortedPageNames);
  },

  getSortedBenchmarkTimes_(benchmarkTimes) {
    return Array.from(benchmarkTimes.keys()).sort((a, b) =>
      benchmarkTimes.get(a) - benchmarkTimes.get(b));
  },

  sortGroups_(a, b, groupedPageData, sortedBenchmarkTimes, mainMetricNames) {
    let aValue = 0;
    const aMap = groupedPageData.get(a);
    if (aMap.get(sortedBenchmarkTimes[0]) !== undefined) {
      for (const metricName of mainMetricNames) {
        const aMetricMap = aMap.get(sortedBenchmarkTimes[0]).get(metricName);
        aValue += aMetricMap.get(STATISTIC_KEY).mean;
      }
    }
    let bValue = 0;
    const bMap = groupedPageData.get(b);
    if (bMap.get(sortedBenchmarkTimes[0]) !== undefined) {
      for (const metricName of mainMetricNames) {
        const bMetricMap = bMap.get(sortedBenchmarkTimes[0]).get(metricName);
        bValue += bMetricMap.get(STATISTIC_KEY).mean;
      }
    }
    if (aValue === bValue) return 0;
    return (aValue < bValue) ? -1 : 1;
  },

  setChartData_(groupedPageData, sortedPageNames, sortedBenchmarkTimes, chart) {
    const chartData = [];
    for (const page of sortedPageNames) {
      const pageMap = groupedPageData.get(page);
      for (const benchmarkTime of sortedBenchmarkTimes) {
        const data = {x: benchmarkTime, group: page};
        if (!pageMap.has(benchmarkTime)) continue;
        const benchmarkTimeMap = pageMap.get(benchmarkTime);
        for (const [metric, metricMap] of benchmarkTimeMap) {
          const key = this.getSeriesKey_(metric, benchmarkTime);
          const mean = metricMap.get(STATISTIC_KEY).mean;
          data[key] = Math.round(mean * 100) / 100;
          if (benchmarkTime === sortedBenchmarkTimes[0]) {
            chart.getDataSeries(key).title = metric;
          } else {
            chart.getDataSeries(key).title = '';
          }
        }
        chartData.push(data);
      }
      chartData.push({});
    }
    chart.data = chartData;
  },

  setChartSize_(pageCount, benchmarkTimeCount, chart) {
    chart.graphHeight = tr.b.math.clamp(pageCount * benchmarkTimeCount * 20,
        300, 600);
    chart.graphWidth = tr.b.math.clamp(pageCount * benchmarkTimeCount * 25,
        500, 1000);
  },

  // Assign color gradient to series in chart
  setChartColors_(mainMetricNames, sortedBenchmarkTimes, chart) {
    for (let i = 0; i < mainMetricNames.length; ++i) {
      const mainMetric = mainMetricNames[i];
      for (let j = 0; j < sortedBenchmarkTimes.length; ++j) {
        const mainColorIndex = i % COLORS.length;
        const subColorIndex = j % COLORS[mainColorIndex].length;
        const color = COLORS[mainColorIndex][subColorIndex];
        const benchmarkTime = sortedBenchmarkTimes[j];
        const series = this.getSeriesKey_(mainMetric, benchmarkTime);
        chart.getDataSeries(series).color = color;
      }
    }
  },

  setTransparentColors_(transparentBlocks, sortedBenchmarkTimes, chart) {
    for (const transparent of transparentBlocks) {
      for (const benchmarkTime of sortedBenchmarkTimes) {
        chart.getDataSeries(this.getSeriesKey_(transparent,
            benchmarkTime)).color = 'transparent';
      }
    }
  },

  getSeriesKey_(metricName, benchmarkTime) {
    return metricName + '-' + benchmarkTime;
  },

  // Element creation
  initializeColumnChart(title) {
    const newChart = new tr.ui.b.NameColumnChart();
    newChart.isStacked = true;
    newChart.yAxisLabel = 'ms';
    newChart.hideXAxis = true;
    newChart.displayXInHover = true;
    newChart.isGrouped = true;
    newChart.showTitleInLegend = true;
    newChart.chartTitle = title;
    newChart.titleHeight = '14pt';
    return newChart;
  },

  initializeChildChart_(title, height, width) {
    const childChart = new tr.ui.b.NameBarChart();
    childChart.xAxisLabel = 'ms';
    childChart.chartTitle = title;
    childChart.graphHeight = height;
    childChart.graphWidth = width;
    childChart.titleHeight = '14pt';
    childChart.isStacked = true;
    childChart.hideLegend = true;
    childChart.isGrouped = true;
    childChart.isWaterfall = true;
    return childChart;
  },

  initializeCloseButton_(div, parent) {
    const button = this.$.close.cloneNode(true);
    button.style.display = 'inline-block';
    button.addEventListener ('click', () => {
      Polymer.dom(parent).removeChild(div);
    });
    return button;
  },

  initializeSelectors_(mainStep, parent) {
    const select = Polymer.dom(parent).queruSelector('.selector')
        .cloneNode(true);
    select.style.display = 'block';

    Polymer.dom(select).querySelector('.start')
        .addEventListener ('keydown', (e) => {
          if (e.key === 'Enter') this.filterByPercentile_(select, mainStep);
        });

    Polymer.dom(select).querySelector('.end')
        .addEventListener ('keydown', (e) => {
          if (e.key === 'Enter') this.filterByPercentile_(select, mainStep);
        });

    Polymer.dom(select).querySelector('.filter')
        .addEventListener ('click', () => {
          this.filterByPercentile_(select, mainStep);
        });

    Polymer.dom(select).querySelector('.search_page')
        .addEventListener ('keydown', (e) => {
          if (e.key === 'Enter') this.searchByPage_(select, mainStep);
        });

    Polymer.dom(select).querySelector('.search')
        .addEventListener ('click', () => {
          this.searchByPage_(select, mainStep);
        });
    if (mainStep === 'Thread_tbmv2') {
      Polymer.dom(select).querySelector('.timing')
          .addEventListener ('click', () => {
            this.openTimingChart_(mainStep);
          });
    } else {
      Polymer.dom(select).querySelector('.timing').style.display = 'none';
    }

    return select;
  },

  openTimingChart_(mainStep) {
    const div = document.createElement('div');
    div.classList.add('child_container');
    Polymer.dom(this.$.container).appendChild(div);

    const childChart = this.initializeColumnChart(mainStep + ' Timing');
    //  childChart.toolTipCallBack = (rect) =>
    //    this.openChildChart_(rect, mainStep);
    div.appendChild(childChart);

    const button = this.initializeCloseButton_(div, this.$.container);
    div.appendChild(button);

    this.setTransparentColors_(['hide1', 'hide2'],
        this.sortedBenchmarkTimes_.get(mainStep), childChart);
    this.setChartColors_(METRICS.get(mainStep),
        this.sortedBenchmarkTimes_.get(mainStep), childChart);
    this.setChartSize_(this.groupedPageData_.get(mainStep).size * 2,
        this.sortedBenchmarkTimes_.get(mainStep).length, childChart);
    this.setChartTimingData_(this.groupedPageData_.get(mainStep),
        this.sortedPageNames_.get(mainStep),
        this.sortedBenchmarkTimes_.get(mainStep), childChart);
  },

  setChartTimingData_(groupedPageData, sortedPageNames,
      sortedBenchmarkTimes, chart) {
    const chartData = [];
    for (const page of sortedPageNames) {
      const pageMap = groupedPageData.get(page);
      for (const benchmarkTime of sortedBenchmarkTimes) {
        const data1 = {x: benchmarkTime, group: page};
        const data2 = {x: benchmarkTime, group: page};
        data1['hide1-' + benchmarkTime] = 0;
        data2['hide2-' + benchmarkTime] = 0;
        if (!pageMap.has(benchmarkTime)) continue;
        const benchmarkTimeMap = pageMap.get(benchmarkTime);
        for (const [metric, metricMap] of benchmarkTimeMap) {
          const key = this.getSeriesKey_(metric, benchmarkTime);
          let mean = metricMap.get(STATISTIC_KEY).mean;
          mean = Math.round(mean * 100) / 100;
          if (metric.includes('raster')) {
            data2[key] = mean;
            let delay = metricMap.get(DELAY_KEY).mean;
            delay = Math.round(delay * 100) / 100;
            if (delay) {
              if (delay < 0) {
                data1['hide1-' + benchmarkTime] = delay * -1;
              } else {
                data2['hide2-' + benchmarkTime] = delay;
              }
            }
          } else {
            data1[key] = mean;
          }
          if (benchmarkTime === sortedBenchmarkTimes[0]) {
            chart.getDataSeries(key).title = metric;
          } else {
            chart.getDataSeries(key).title = '';
          }
        }
        chartData.push(data1);
        chartData.push(data2);
      }
      chartData.push({});
    }
    chart.data = chartData;
  },

  // Page action functions

  // Create new metrics chart with selectors and a close button
  openMetricsChart_(mainStep) {
    const div = document.createElement('div');
    div.classList.add('child_container');
    Polymer.dom(this.$.container).appendChild(div);

    const selectors = this.initializeSelectors_(mainStep);
    div.appendChild(selectors);

    const childChart = this.initializeColumnChart(mainStep + ' Breakdown');
    childChart.enableToolTip = true;
    childChart.toolTipCallBack = (rect) =>
      this.openChildChart_(rect, mainStep);
    div.appendChild(childChart);

    const button = this.initializeCloseButton_(div, this.$.container);
    div.appendChild(button);
    this.populateChart_(this.histograms, mainStep, childChart, false);
    this.charts_.set(mainStep, childChart);
  },

  // Create child chart and populate it
  openChildChart_(rect, metricName) {
    // Find main metric and corresponding sub-metrics
    let mainStep;
    let mainStepIndex;
    for (let i = 0; i < METRICS.get(metricName).length; ++i) {
      if (rect.key.startsWith(METRICS.get(metricName)[i])) {
        mainStep = METRICS.get(metricName)[i];
        mainStepIndex = i;
        break;
      }
    }

    // Create child chart
    const subSteps = this.subMetricNames_.get(mainStep);
    const width = tr.b.math.clamp(subSteps.length * 150, 300, 700);
    const height = tr.b.math.clamp(subSteps.length *
        this.sortedBenchmarkTimes_.get(metricName).length * 50, 300, 700);

    const pageName = rect.datum.group;
    const title = mainStep + ': ' + pageName;

    const div = document.createElement('div');
    div.classList.add('child_container');
    Polymer.dom(this.$.children).insertBefore(div, this.$.children.firstChild);

    const childChart = this.initializeChildChart_(title, height, width);
    div.appendChild(childChart);

    const button = this.initializeCloseButton_(div, this.$.children);
    div.appendChild(button);


    // Get breakdown data for main step
    const pageData = this.groupedPageData_.get(metricName).get(pageName);
    const subStepData = this.processSubStepData(childChart,
        mainStepIndex, mainStep, pageData, pageName, 0);
    childChart.data = subStepData.childData;
  },
  setChartTimingData_(groups, sortedPageNames, sortedBenchmarkTimes, chart) {
    const chartData = [];
    for (const page of sortedPageNames) {
      const pageMap = groups.get(page);
      for (const benchmarkTime of sortedBenchmarkTimes) {
        const data1 = {x: benchmarkTime, group: page};
        const data2 = {x: benchmarkTime, group: page};
        data1['hide1-' + benchmarkTime] = 0;
        data2['hide2-' + benchmarkTime] = 0;
        if (!pageMap.has(benchmarkTime)) continue;
        const benchmarkTimeMap = pageMap.get(benchmarkTime);
        for (const [metric, metricMap] of benchmarkTimeMap) {
          const key = this.getSeriesKey_(metric, benchmarkTime);
          let mean = metricMap.get(STATISTIC_KEY).mean;
          mean = Math.round(mean * 100) / 100;
          if (metric.includes('raster')) {
            data2[key] = mean;
            let delay = metricMap.get(DELAY_KEY).mean;
            delay = Math.round(delay * 100) / 100;
            if (delay) {
              if (delay < 0) {
                data1['hide1-' + benchmarkTime] = delay * -1;
              } else {
                data2['hide2-' + benchmarkTime] = delay;
              }
            }
          } else {
            data1[key] = mean;
          }
          if (benchmarkTime === sortedBenchmarkTimes[0]) {
            chart.getDataSeries(key).title = metric;
          } else {
            chart.getDataSeries(key).title = '';
          }
        }
        chartData.push(data1);
        chartData.push(data2);
      }
      chartData.push({});
    }
    chart.data = chartData;
  },

  // Get data for breakdown of a main step
  processSubStepData(childChart, mainStepIndex, mainStep,
      pageData, pageName, total) {
    const childData = [];
    const subSteps = this.subMetricNames_.get(mainStep);

    if (subSteps === undefined) return {childData, total};

    for (const subStep of subSteps) {
      const currentTotal = total; // Used to align bars for each step
      let j = 0;
      for (const [benchmarkTime, benchmarkTimeMap] of pageData) {
        const data = {x: subStep, hide: currentTotal, group: benchmarkTime};

        const metricMap = benchmarkTimeMap.get(mainStep);
        const series = this.getSeriesKey_(subStep, benchmarkTime);
        if (!metricMap.get(subStep)) continue;
        const mean = metricMap.get(subStep).mean;
        const roundedMean = Math.round(mean * 100) / 100;

        data[series] = roundedMean === undefined ? 0 : roundedMean;
        childData.push(data);

        // Align bars with first value
        if (j === 0) total += data[series];
        else data.x = '.';

        // Get same color as main chart
        const subColorIndex = j % COLORS[mainStepIndex].length;
        const color = COLORS[mainStepIndex][subColorIndex];
        childChart.getDataSeries(series).color = color;
        j++;
      }
      childData.push({x: '.'});
    }
    return {childData, total};
  },

  // Handle filtering by start and end percentiles
  filterByPercentile_(select, metricName) {
    const startPercentile = Polymer.dom(select).querySelector('.start').value;
    const endPercentile = Polymer.dom(select).querySelector('.end').value;

    if (startPercentile === '' || endPercentile === '') return;

    const length = this.sortedPageNames_.get(metricName).length;
    const startIndex = this.getPercentileIndex_(startPercentile, length);
    const endIndex = this.getPercentileIndex_(endPercentile, length);

    const slicedPages = this.sortedPageNames_.get(metricName)
        .slice(startIndex, endIndex);

    this.setChartData_(this.groupedPageData_.get(metricName), slicedPages,
        this.sortedBenchmarkTimes_.get(metricName),
        this.charts_.get(metricName));
  },

  // Get index of x percentile value
  getPercentileIndex_(percentile, arrayLength) {
    const index = Math.ceil(arrayLength * (percentile / 100.0));
    if (index === -1) return 0;
    if (index >= arrayLength) return arrayLength;
    return index;
  },

  // Handle searching by page name
  searchByPage_(select, metricName) {
    const criteria = Polymer.dom(select).querySelector('#search_page').value;
    if (criteria === '') return;

    const query = new RegExp(criteria);
    const filteredGroupedPageData = [...this.groupedPageData_.get(metricName)]
        .filter(group => group[0].match(query));

    if (filteredGroupedPageData.length < 1) {
      Polymer.dom(select).querySelector('#search_error')
          .style.display = 'block';
      return;
    }

    // Create child chart with breakdown data
    const matchedPageName = filteredGroupedPageData[0][0];
    const match = this.groupedPageData_.get(metricName).get(matchedPageName);
    const title = metricName + ' Breakdown: ' + matchedPageName;

    let totalSteps = 0;
    for (const [mainStep, subSteps] of this.subMetricNames_) {
      totalSteps += subSteps.length;
    }
    const width = tr.b.math.clamp(totalSteps * 150, 300, 700);
    const height = tr.b.math.clamp(totalSteps *
        this.sortedBenchmarkTimes_.get(metricName).length * 30, 300, 700);

    const childChart = this.initializeChild_(title, height, width);

    const childData = [];
    let total = 0;
    for (let i = 0; i < METRICS.get(metricName).length; ++i) {
      const stepData = this.processSubStepData(childChart, i,
          METRICS.get(metricName)[i], match, matchedPageName, total);
      childData.push(...stepData.childData);

      total = stepData.total;
    }
    childChart.data = childData;
  },

});
</script>
