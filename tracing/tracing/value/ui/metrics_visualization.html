<!DOCTYPE html>
<!--
Copyright (c) 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/ui/base/name_bar_chart.html">
<link rel="import" href="/tracing/ui/base/name_column_chart.html">
<dom-module id='tr-v-ui-metrics-visualization'>
  <template>
    <style>
      button {
        padding: 5px;
        font-size: 14px;
      }

      .text_input {
        width: 50px;
        padding: 4px;
        font-size: 14px;
      }

      #selectors {
        padding-bottom: 10px;
        display: none;
      }

      #search_page {
        width: 200px;
        margin-left: 30px;
      }

      #search_error {
        color: red;
      }
    </style>
    <h5 id="error">
    </h5>
    <div id="selectors">
      <h3> Metrics Visualization</h3>
      <input id="start" class="text_input" placeholder="0">
      <input id="end" class="text_input" placeholder="100">
      <button id="filter" on-tap="filterByPercentile_">Filter</button>
      <input id="search_page" class="text_input" placeholder="Page Name">
      <button id="search" on-tap="searchByPage_">Search</button>
      <p id="search_error"></p>
    </div>
    <div id="container">
    </div>
    <div id="children">
    </div>
  </template>
</dom-module>
<script>
'use strict';

const COLORS = [
  ['#FF6E40', '#FF3D00', '#DD2C00', '#A32000'],
  ['#FFD740', '#FFC400', '#FFAB00', '#E29800'],
  ['#40C4FF', '#00B0FF', '#0091EA', '#006DAF'],
  ['#B2FF59', '#76FF03', '#64DD17', '#4CA812'],
  ['#B388FF', '#7C4DFF', '#651FFF', '#6200EA'],
  ['#FF80AB', '#FF4081', '#F50057', '#C51162'],
  ['#FFAB40', '#FF9100', '#FF6D00', '#D65C02'],
  ['#8C9EFF', '#536DFE', '#3D5AFE', '#304FFE']];

const VALUE_KEY = 'average';

Polymer({
  is: 'tr-v-ui-metrics-visualization',

  created() {
    this.chart_ = new tr.ui.b.NameColumnChart();
    this.chart_.isStacked = true;
    this.chart_.graphHeight = 400;
    this.chart_.graphWidth = 600;
    this.chart_.yAxisLabel = 'ms';
    this.chart_.hideXAxis = true;
    this.chart_.displayXInHover = true;
    this.chart_.isGrouped = true;
    this.chart_.enableToolTip = true;
    this.chart_.showTitleInLegend = true;
    this.chart_.toolTipCallBack = (rect) => this.openChildChart_(rect);

    this.sortedGroups_ = undefined;
    this.displayLabels_ = undefined;

    this.mainMetricNames_ = undefined;
    this.subMetricNames_ = new Map();
  },

  ready() {
    this.$.start.addEventListener('keydown', (e) => {
      if (e.keyCode === 13) this.filterByPercentile_();
    }, false);

    this.$.end.addEventListener('keydown', (e) => {
      if (e.keyCode === 13) this.filterByPercentile_();
    }, false);

    this.$.search_page.addEventListener('keydown', (e) => {
      if (e.keyCode === 13) this.searchByPage_();
    }, false);
  },

  build(histograms, mainMetricNames) {
    if (!histograms || !mainMetricNames) {
      this.$.error.innerHTML = 'Invalid data provided.';
      return;
    }

    this.mainMetricNames_ = mainMetricNames;
    Polymer.dom(this.$.container).appendChild(this.chart_);
    this.populateChart_(histograms, this.mainMetricNames_, this.chart_);
    this.$.selectors.style.display = 'block';
  },

  populateChart_(histograms, mainMetricNames, chart) {
    const storiesGrouping = tr.v.HistogramGrouping.BY_KEY.get(
        tr.v.d.RESERVED_NAMES.STORIES);
    const benchmarkStartGrouping = tr.v.HistogramGrouping.BY_KEY.get(
        tr.v.d.RESERVED_NAMES.BENCHMARK_START);

    const labels = new Map();
    const groups = new Map();

    for (const metric of mainMetricNames) {
      const metricHistograms = histograms.getHistogramsNamed(metric);
      for (const histogram of metricHistograms) {
        const benchmarkStart = benchmarkStartGrouping.callback(histogram);
        const page = storiesGrouping.callback(histogram);
        const displayLabel = tr.v.HistogramGrouping.
            DISPLAY_LABEL.callback(histogram);
        const average = histogram.average === undefined ? 0 : histogram.average;
        const roundedAverage = Number(average.toFixed(2));
        labels.set(displayLabel, Date.parse(benchmarkStart));

        let pageMap = new Map();
        let labelMap = new Map();
        if (groups.get(page) === undefined) {
          groups.set(page, pageMap);
          pageMap.set(displayLabel, labelMap);
        } else {
          pageMap = groups.get(page);
          if (pageMap.get(displayLabel) === undefined) {
            pageMap.set(displayLabel, labelMap);
          } else {
            labelMap = pageMap.get(displayLabel);
          }
        }

        const metricMap = new Map();
        labelMap.set(metric, metricMap);
        metricMap.set(VALUE_KEY, roundedAverage);

        const merged = new tr.v.d.DiagnosticMap();
        for (const bin of histogram.allBins) {
          for (const map of bin.diagnosticMaps) {
            merged.addDiagnostics(map);
          }
        }

        const subMetrics = [];
        if (merged.get('breakdown') === undefined) {
          metricMap.set(metric, roundedAverage);
          subMetrics.push(metric);
        } else {
          for (const [k, v] of merged.get('breakdown')) {
            metricMap.set(k, v);
            subMetrics.push(k);
          }
        }
        this.subMetricNames_.set(metric, subMetrics);
      }
    }

    this.displayLabels_ = this.getSortedDisplayLabels_(labels);
    this.sortedGroups_ = new Map([...groups.entries()].sort((a, b) =>
      this.sortGroups(a[1], b[1], this.displayLabels_, mainMetricNames)));

    this.setChartColors_(mainMetricNames, this.displayLabels_, chart);
    this.setChartData_(this.sortedGroups_, this.displayLabels_,
        mainMetricNames, chart);
  },

  getSortedDisplayLabels_(labels) {
    return Array.from(labels.keys()).sort((a, b) =>
      labels.get(a) - labels.get(b));
  },

  sortGroups(a, b, displayLabels, mainMetricNames) {
    let aValue = 0;
    if (a.get(displayLabels[0]) !== undefined) {
      for (const metricName of mainMetricNames) {
        aValue += a.get(displayLabels[0]).get(metricName).get(VALUE_KEY);
      }
    }
    let bValue = 0;
    if (b.get(displayLabels[0]) !== undefined) {
      for (const metricName of mainMetricNames) {
        bValue += b.get(displayLabels[0]).get(metricName).get(VALUE_KEY);
      }
    }
    if (aValue === bValue) return 0;
    return (aValue < bValue) ? -1 : 1;
  },

  setChartData_(groups, displayLabels, mainMetricNames, chart) {
    const chartData = [];
    for (const [page, pageMap] of groups) {
      for (const label of displayLabels) {
        const data = {x: label, group: page};
        const labelMap = pageMap.get(label);
        for (const [metric, metricMap] of labelMap) {
          const key = this.getSeriesKey_(metric, label);
          data[key] = metricMap.get(VALUE_KEY);
          if (label === displayLabels[0]) {
            chart.getDataSeries(key).title = metric;
          } else {
            chart.getDataSeries(key).title = '';
          }
        }
        chartData.push(data);
      }
      chartData.push({});
    }
    chart.data = chartData;
  },

  // Assign color gradient to series in chart
  setChartColors_(mainMetricNames, displayLabels, chart) {
    for (let i = 0; i < mainMetricNames.length; ++i) {
      const mainMetric = mainMetricNames[i];
      for (let j = 0; j < displayLabels.length; ++j) {
        const mainColorIndex = i % COLORS.length;
        const subColorIndex = j % COLORS[mainColorIndex].length;
        const color = COLORS[mainColorIndex][subColorIndex];

        const displayLabel = displayLabels[j];
        const series = this.getSeriesKey_(mainMetric, displayLabel);
        chart.getDataSeries(series).color = color;
      }
    }
  },

  getSeriesKey_(metricName, displayLabel) {
    return metricName + '-' + displayLabel;
  },

  initializeChildDiv_() {
    const div = document.createElement('div');
    div.style.position = 'relative';
    div.style.display = 'inline-block';
    return div;
  },

  initializeChildChart_(title, height, width) {
    const childChart = new tr.ui.b.NameBarChart();
    childChart.xAxisLabel = 'ms';
    childChart.chartTitle = title;
    childChart.graphHeight = height;
    childChart.graphWidth = width;
    childChart.isStacked = true;
    childChart.hideLegend = true;
    childChart.isGrouped = true;
    childChart.isWaterfall = true;
    return childChart;
  },

  initializeCloseButton_(div) {
    const button = document.createElement('button');
    button.innerHTML = 'X';
    button.addEventListener ('click', () => {
      Polymer.dom(this.$.children).removeChild(div);
    });
    button.style.position = 'absolute';
    button.style.top = 0;
    button.style.right = 400;
    return button;
  },

  // Adds new child chart with close button
  initializeChild_(title, height, width) {
    const div = this.initializeChildDiv_();
    Polymer.dom(this.$.children).insertBefore(div, this.$.children.firstChild);

    const childChart = this.initializeChildChart_(title, height, width);
    div.appendChild(childChart);

    const button = this.initializeCloseButton_(div);
    div.appendChild(button);

    return childChart;
  },

  // Create child chart and populate it
  openChildChart_(rect) {
    // Find main metric and corresponding sub-metrics
    let mainStepIndex;
    for (let i = 0; i < this.mainMetricNames_.length; ++i) {
      if (rect.key.startsWith(this.mainMetricNames_[i])) {
        mainStepIndex = i;
        break;
      }
    }

    // Create child chart
    const mainStep = this.mainMetricNames_[mainStepIndex];
    const pageName = rect.datum.group;
    const title = mainStep + ': ' + pageName;
    const childChart = this.initializeChild_(title, 400, 600);

    // Get breakdown data for main step
    const pageData = this.sortedGroups_.get(pageName);
    const subStepData = this.processSubStepData(childChart,
        mainStepIndex, mainStep, pageData, pageName, 0);
    childChart.data = subStepData.childData;
  },

  // Get data for breakdown of a main step
  processSubStepData(childChart, mainStepIndex, mainStep,
      pageData, pageName, total) {
    const childData = [];
    const subSteps = this.subMetricNames_.get(mainStep);

    if (subSteps === undefined) return {childData, total};

    for (let i = 0; i < subSteps.length; ++i) {
      const currentTotal = total; // Used to align bars for each step
      let j = 0;
      for (const [displayLabel, labelMap] of pageData) {
        const data = {x: subSteps[i], hide: currentTotal, group: displayLabel};

        const metricMap = labelMap.get(mainStep);
        const series = this.getSeriesKey_(subSteps[i], displayLabel);
        const value = metricMap.get(subSteps[i]);

        data[series] = value === undefined ? 0 : value;
        childData.push(data);

        // Align bars with first value
        if (j === 0) total += data[series];
        else data.x = '.';

        // Get same color as main chart
        const subColorIndex = j % COLORS[mainStepIndex].length;
        const color = COLORS[mainStepIndex][subColorIndex];
        childChart.getDataSeries(series).color = color;
        j++;
      }
      childData.push({x: '.'});
    }
    return {childData, total};
  },

  // Handle filtering by start and end percentiles
  filterByPercentile_() {
    const startPercentile = this.$.start.value;
    const endPercentile = this.$.end.value;

    if (startPercentile === '' || endPercentile === '') return;

    const length = this.sortedGroups_.size;
    const startIndex = this.getPercentileIndex_(startPercentile, length);
    const endIndex = this.getPercentileIndex_(endPercentile, length);

    const slicedGroups = new Map();
    let i = 0;
    for (const [page, pageMap] of this.sortedGroups_) {
      if (i >= startIndex && i < endIndex) {
        slicedGroups.set(page, pageMap);
      }
      i++;
    }

    this.setChartData_(slicedGroups, this.displayLabels_,
        this.mainMetricNames_, this.chart_);
  },

  // Get index of x percentile value
  getPercentileIndex_(percentile, arrayLength) {
    const index = Math.ceil(arrayLength * (percentile / 100.0));
    if (index === -1) return 0;
    if (index >= arrayLength) return arrayLength;
    return index;
  },

  // Handle searching by page name
  searchByPage_() {
    const criteria = this.$.search_page.value;
    if (criteria === '') return;

    // Look for matching page name
    let matchedPageName;
    for (const [page, pageMap] of this.sortedGroups_) {
      if (page === criteria) {
        matchedPageName = page;
        break;
      }
    }

    if (matchedPageName === undefined) {
      this.$.search_error.innerHTML = 'Sorry, could not find that page!';
      return;
    }
    this.$.search_error.innerHTML = '';

    // Create child chart with breakdown data
    const match = this.sortedGroups_.get(matchedPageName);
    const title = 'Breakdown: ' + matchedPageName;
    const childChart = this.initializeChild_(title, 600, 900);

    const childData = [];
    let total = 0;
    for (let i = 0; i < this.mainMetricNames_.length; ++i) {
      const stepData = this.processSubStepData(childChart, i,
          this.mainMetricNames_[i], match, matchedPageName, total);
      childData.push(...stepData.childData);

      total = stepData.total;
    }
    childChart.data = childData;
  },

});
</script>
