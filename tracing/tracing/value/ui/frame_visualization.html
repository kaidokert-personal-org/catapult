<!DOCTYPE html>
<!--
Copyright (c) 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<meta charset="utf-8">
<dom-module id='tr-v-ui-frame-visualization'>
  <template>
    <style>
    </style>
    <div id="aggregateContainer">
    </div>
    <div id="pageByPageContainer">
    </div>
  </template>
</dom-module>
<script>
'use strict';

Polymer({
  is: 'tr-v-ui-frame-visualization',

  created() {
    this.charts_ = new Map();
  },

  build(chartData) {
    this.data_ = chartData.data;
    this.benchmarkCount_ = chartData.benchmarkCount;
    const aggregateChart = this.createChart_();
    this.charts_.set('aggregate', aggregateChart);
    Polymer.dom(this.$.aggregateContainer).appendChild(aggregateChart);
    this.setChartColors_('aggregate');
    this.setChartSize_('aggregate');
    this.setChartData_('aggregate');
  },

  setChartData_(page) {
    this.charts_.get(page).data = this.data_.get(page);
  },

  setChartSize_(page) {
    const chart = this.charts_.get(page);
    const pageCount = this.data_.get(page).length;
    chart.graphHeight = tr.b.math.clamp(pageCount * this.benchmarkCount_ * 10,
        175, 600);
    chart.graphWidth = tr.b.math.clamp(this.benchmarkCount_ * 25,
        500, 1000);
  },

  setChartColors_(page) {
    const metrics = new Map();
    let count = 0;
    for (const bar of FRAME) {
      for (const metric of bar.keys()) {
        metrics.set(metric, count);
        count++;
      }
    }
    const chart = this.charts_.get(page);
    const data = this.data_.get(page);
    for (let i = 0; i < this.benchmarkCount_; ++i) {
      for (let j = 0; j < FRAME.length; ++j) {
        for (const metric of FRAME[j].keys()) {
          let color = 'transparent';
          if (FRAME[j].get(metric)) {
            const mainColorIndex = metrics.get(metric) % COLORS.length;
            const subColorIndex = i % COLORS[mainColorIndex].length;
            color = COLORS[mainColorIndex][subColorIndex];
          }
          const series = metric + '-' + data[i * 2].x;
          chart.getDataSeries(series).color = color;
          chart.getDataSeries(series).title = !i ? metric : '';
        }
      }
    }
  },

  createChart_() {
    const newChart = new tr.ui.b.NameBarChart();
    newChart.xAxisLabel = 'ms';
    newChart.showTitleInLegend = true;
    newChart.hideYAxis = true;
    newChart.isStacked = true;
    newChart.displayXInHover = true;
    newChart.isGrouped = true;
    return newChart;
  }

});


</script>
