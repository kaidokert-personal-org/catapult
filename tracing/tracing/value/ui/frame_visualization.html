<!DOCTYPE html>
<!--
Copyright (c) 2018 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<meta charset="utf-8">
<dom-module id='tr-v-ui-frame-visualization'>
  <template>
    <style>
      button {
        padding: 5px;
        font-size: 14px;
      }
      .error {
        color: red;
        display: none;
      }

      .text_input {
        width: 50px;
        padding: 4px;
        font-size: 14px;
      }

      #pageSelector {
        display: block;
        font-size: 12pt;
      }

      #close {
        display: none;
        vertical-align: top;
      }

      #close svg{
        height: 1em;
      }

      #close svg line {
        stroke-width: 18;
        stroke: black;
      }

      #close:hover svg {
        background: black;
      }

      #close:hover svg line {
        stroke: white;
      }
    </style>
    <div id="aggregateContainer">
      <select id="pageSelector">
        <option value="">Select a page</option>
      </select>
    </div>
    <div id="pageContainer">
      <span id="close">
          <svg viewbox="0 0 128 128">
            <line x1="28" y1="28" x2="100" y2="100"/>
            <line x1="28" y1="100" x2="100" y2="28"/>
          </svg>
        </span>
    </div>
  </template>
</dom-module>
<script>
'use strict';

Polymer({
  is: 'tr-v-ui-frame-visualization',

  ready() {
    this.$.pageSelector.addEventListener ('click', () => {
      this.selectPage_();
    });
  },


  build(chartData) {
    this.data_ = chartData;
    const aggregateChart = this.createChart_('Aggregate');
    Polymer.dom(this.$.aggregateContainer).appendChild(aggregateChart);
    aggregateChart.enableToolTip = true;
    aggregateChart.toolTipCallBack = (rect) =>
      this.openBenchmarkChart_(rect);
    this.setChartColors_(aggregateChart, this.data_.get('aggregate'));
    this.setChartSize_(aggregateChart, this.data_.get('aggregate').length);
    aggregateChart.data = this.data_.get('aggregate');

    for (const page of this.data_.keys()) {
      if (page === 'aggregate') continue;
      const option = document.createElement('option');
      option.textContent = page;
      option.value = page;
      this.$.pageSelector.appendChild(option);
    }
  },

  setChartSize_(chart, pageCount, dataLength) {
    chart.graphHeight = tr.b.math.clamp(pageCount * 25, 175, 600);
    chart.graphWidth = tr.b.math.clamp(Math.floor(pageCount / FRAME.length) *
        25, 500, 1000);
  },

  setChartColors_(chart, data) {
    const metrics = new Map();
    let count = 0;
    for (const thread of FRAME.values()) {
      for (const metric of thread.keys()) {
        metrics.set(metric, count);
        count++;
      }
    }
    for (let i = 0; i < Math.floor(data.length / FRAME.length); ++i) {
      let j = 0;
      for (const thread of FRAME.values()) {
        for (const metric of thread.keys()) {
          let color = 'transparent';
          if (thread.get(metric)) {
            const mainColorIndex = metrics.get(metric) % COLORS.length;
            const subColorIndex = i % COLORS[mainColorIndex].length;
            color = COLORS[mainColorIndex][subColorIndex];
          }
          const series = metric + '-' + data[i * 2 + j].x;
          chart.getDataSeries(series).color = color;
          chart.getDataSeries(series).title = !i ? metric : '';
        }
        j++;
      }
    }
  },

  createChart_(title) {
    const newChart = new tr.ui.b.NameBarChart();
    newChart.chartTitle = title;
    newChart.xAxisLabel = 'ms';
    newChart.showTitleInLegend = true;
    newChart.hideYAxis = true;
    newChart.isStacked = true;
    newChart.displayXInHover = true;
    newChart.isGrouped = true;
    newChart.isWaterfall = true;
    return newChart;
  },

  openBenchmarkChart_(rect) {
    // Find main metric and corresponding sub-metrics
    const benchmarkIndex = Math.floor(rect.index / FRAME.length);
    const title = rect.datum.x.split('-')[0];

    // Create child chart with breakdown data
    const div = document.createElement('div');
    div.classList.add('child_container');
    Polymer.dom(this.$.pageContainer).
        insertBefore(div, this.$.pageContainer.firstChild);

    const chart = this.createChart_(title);

    div.appendChild(chart);
    const button = this.initializeCloseButton_(div, this.$.pageContainer);
    div.appendChild(button);

    const newDataSet = [];

    for (const page of this.data_.keys()) {
      if (page === 'aggregate') continue;
      for (let i = 0; i < FRAME.length; i++) {
        newDataSet.push(this.data_
            .get(page)[benchmarkIndex * FRAME.length + i]);
      }
    }

    this.setChartColors_(chart, newDataSet);
    this.setChartSize_(chart, newDataSet.length);
    chart.data = newDataSet;
  },

  selectPage_() {
    // Create child chart with breakdown data
    const div = document.createElement('div');
    div.classList.add('child_container');
    const page = this.$.pageSelector.value;
    if (page === '') return;
    Polymer.dom(this.$.pageContainer).
        insertBefore(div, this.$.pageContainer.firstChild);

    const pageChart = this.createChart_(page);

    div.appendChild(pageChart);
    const button = this.initializeCloseButton_(div, this.$.pageContainer);
    div.appendChild(button);

    this.setChartColors_(pageChart, this.data_.get(page));
    this.setChartSize_(pageChart, this.data_.get(page).length);
    pageChart.data = this.data_.get(page);
  },

  initializeCloseButton_(div, parent) {
    const button = this.$.close.cloneNode(true);
    button.style.display = 'inline-block';
    button.addEventListener ('click', () => {
      Polymer.dom(parent).removeChild(div);
    });
    return button;
  },

});


</script>
