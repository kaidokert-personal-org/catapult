<!DOCTYPE html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/timing.html">
<link rel="import" href="/tracing/ui/base/dom_helpers.html">
<link rel="import" href="/tracing/value/ui/dropdown.html">
<link rel="import" href="/tracing/value/ui/histogram_set_controls_compare.html">
<link rel="import" href="/tracing/value/ui/histogram_set_controls_export.html">
<link rel="import" href="/tracing/value/ui/histogram_set_controls_overviews.html">
<link rel="import" href="/tracing/value/ui/histogram_set_controls_pivot.html">
<link rel="import" href="/tracing/value/ui/histogram_set_controls_statistics.html">
<link rel="import" href="/tracing/value/ui/histogram_set_view_state.html">

<dom-module id="tr-v-ui-histogram-set-controls">
  <template>
    <style>
    #search {
      max-width: 20em;
      margin-right: 1em;
    }

    #help, #feedback {
      display: none;
      margin-left: 1em;
    }

    menu {
      white-space: nowrap;
      margin: 0;
      padding: 0;
      background-color: #dddddd;
    }

    tr-v-ui-dropdown {
      margin-left: 1em;
      --dropdown-button: {
        -webkit-appearance: none;
        border: 0;
        cursor: pointer;
        font-size: initial;
        padding: 0;
      };
      --dropdown-button-open: {
        border-bottom: 2px solid black;
      }
    }
    </style>

    <menu>
      <input id="search" placeholder="Find Histogram name">

      <input type="checkbox" id="show_all" title="When unchecked, less important histograms are hidden.">
      <label for="show_all" title="When unchecked, less important histograms are hidden.">Show all</label>

      <tr-v-ui-dropdown label="Pivot">
        <tr-v-ui-histogram-set-controls-overviews class="build">
        </tr-v-ui-histogram-set-controls-overviews>
        <tr-v-ui-histogram-set-controls-pivot class="build">
        </tr-v-ui-histogram-set-controls-pivot>
      </tr-v-ui-dropdown>

      <tr-v-ui-dropdown label="Compare">
        <tr-v-ui-histogram-set-controls-compare class="build">
        </tr-v-ui-histogram-set-controls-compare>
      </tr-v-ui-dropdown>

      <tr-v-ui-dropdown label="Statistics">
        <tr-v-ui-histogram-set-controls-statistics class="build">
        </tr-v-ui-histogram-set-controls-statistics>
      </tr-v-ui-dropdown>

      <tr-v-ui-dropdown label="Export">
        <tr-v-ui-histogram-set-controls-export>
        </tr-v-ui-histogram-set-controls-export>
      </tr-v-ui-dropdown>

      <a id="help">Help</a>
      <a id="feedback">Feedback</a>
    </menu>
  </template>
</dom-module>

<script>
'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-histogram-set-controls',

    /**
     * @param {!tr.v.ui.HistogramSetViewState} viewState
     * @param {!tr.v.HistogramParameters} parameters
     * @param {!Object=} opt_options
     * @param {string} opt_options.helpHref
     * @param {string} opt_options.feedbackHref
     */
    build(viewState, parameters, opt_options) {
      const options = opt_options || {};

      if (this.viewState_) {
        throw new Error('viewState must be set exactly once.');
      }
      this.viewState_ = viewState;
      this.viewState.addUpdateListener(this.onViewStateUpdate_.bind(this));
      // It would be arduous to construct a delta and call viewStateListener_
      // here in case viewState contains non-default values, so callers must set
      // viewState first and then update it.

      for (const build of this.querySelectorAll('.build')) {
        build.build(viewState, parameters, options);
      }
    },

    get viewState() {
      return this.viewState_;
    },

    async onUserChange_() {
      if (!this.viewState) return;
      if (this.isInOnViewStateUpdate_) return;

      const marks = [];
      if (this.searchQuery !== this.viewState.searchQuery) {
        marks.push(tr.b.Timing.mark('histogram-set-controls', 'search'));
      }
      if (this.showAll !== this.viewState.showAll) {
        marks.push(tr.b.Timing.mark('histogram-set-controls', 'showAll'));
      }
      if (this.referenceDisplayLabel !== this.viewState.referenceDisplayLabel) {
        marks.push(tr.b.Timing.mark(
            'histogram-set-controls', 'referenceColumn'));
      }
      if (this.displayStatisticName !== this.viewState.displayStatisticName) {
        marks.push(tr.b.Timing.mark('histogram-set-controls', 'statistic'));
      }
      if (parseInt(this.alphaIndex) !== this.getAlphaIndexFromViewState_()) {
        marks.push(tr.b.Timing.mark('histogram-set-controls', 'alpha'));
      }

      let displayStatisticName = this.displayStatisticName;
      if (this.viewState.referenceDisplayLabel === '' &&
          this.referenceDisplayLabel !== '' &&
          this.baseStatisticNames.length) {
        // The user selected a reference display label.
        displayStatisticName = `%${tr.v.DELTA}${this.displayStatisticName}`;
        // Can't set this.displayStatisticName before updating viewState -- that
        // would cause an infinite loop of onUserChange_().
      }
      if (this.referenceDisplayLabel === '' &&
          this.viewState.referenceDisplayLabel !== '' &&
          this.baseStatisticNames.length) {
        // The user unset the reference display label.
        // Ensure that displayStatisticName is not a delta statistic.
        const deltaIndex = displayStatisticName.indexOf(tr.v.DELTA);
        if (deltaIndex >= 0) {
          displayStatisticName = displayStatisticName.slice(deltaIndex + 1);
        } else if (!this.baseStatisticNames.includes(displayStatisticName)) {
          displayStatisticName = 'avg';
        }
      }

      // Propagate updates from the user to the view state.
      await this.viewState.update({
        searchQuery: this.searchQuery,
        showAll: this.showAll,
        referenceDisplayLabel: this.referenceDisplayLabel,
        displayStatisticName,
        alpha: ALPHA_OPTIONS[this.alphaIndex],
      });

      if (this.referenceDisplayLabel &&
          this.statisticNames.length === this.baseStatisticNames.length) {
        // When a reference column is selected, delta statistics should be
        // available.
        this.statisticNames = this.baseStatisticNames.concat(
            tr.v.Histogram.getDeltaStatisticsNames(this.baseStatisticNames));
      } else if (!this.referenceDisplayLabel &&
          this.statisticNames.length > this.baseStatisticNames.length) {
        // When a reference column is not selected, delta statistics should not
        // be available.
        this.statisticNames = this.baseStatisticNames;
      }

      for (const mark of marks) mark.end();
    },

    onViewStateUpdate_(event) {
      this.isInOnViewStateUpdate_ = true;

      if (event.delta.searchQuery) {
        this.searchQuery = this.viewState.searchQuery;
      }

      if (event.delta.showAll) this.showAll = this.viewState.showAll;

      if (event.delta.displayStatisticName) {
        this.displayStatisticName = this.viewState.displayStatisticName;
      }

      if (event.delta.referenceDisplayLabel) {
        this.referenceDisplayLabel = this.viewState.referenceDisplayLabel;
        this.$.alpha.style.display = this.referenceDisplayLabel ? 'inline' : '';
      }

      if (event.delta.groupings) {
        this.$.picker.currentGroupKeys = this.viewState.groupings.map(
            g => g.key);
      }

      if (event.delta.tableRowStates) {
        for (const row of tr.v.ui.HistogramSetTableRowState.walkAll(
            this.viewState.tableRowStates.values())) {
          row.addUpdateListener(this.rowListener_);
        }

        const anyShowing = this.anyOverviewCharts_;
        this.$.hide_overview.style.display = anyShowing ? 'inline' : 'none';
        this.$.show_overview.style.display = anyShowing ? 'none' : 'inline';
      }

      if (event.delta.alpha) {
        this.alphaIndex = this.getAlphaIndexFromViewState_();
      }

      this.isInOnViewStateUpdate_ = false;
      this.onUserChange_();
    },

    onRowViewStateUpdate_(event) {
      if (event.delta.isOverviewed) {
        const anyShowing = event.delta.isOverviewed.current ||
            this.anyOverviewCharts_;
        this.$.hide_overview.style.display = anyShowing ? 'inline' : 'none';
        this.$.show_overview.style.display = anyShowing ? 'none' : 'inline';
      }

      if (event.delta.subRows) {
        for (const subRow of event.delta.subRows.previous) {
          subRow.removeUpdateListener(this.rowListener_);
        }
        for (const subRow of event.delta.subRows.current) {
          subRow.addUpdateListener(this.rowListener_);
        }
      }
    },

    onGroupsChanged_() {
      if (this.$.picker.currentGroups.length === 0 &&
          this.$.picker.possibleGroups.length > 0) {
        // If the current groupings are now empty but there are possible
        // groupings, then force there to be at least one grouping.
        // The histogram-set-table requires there to be at least one grouping.
        this.$.picker.currentGroupKeys = [this.$.picker.possibleGroups[0].key];
      }
      this.viewState.groupings = this.$.picker.currentGroups;
    },

    set showAllEnabled(enable) {
      if (!enable) this.$.show_all.checked = true;
      this.$.show_all.disabled = !enable;
    },

    set possibleGroupings(groupings) {
      this.$.picker.possibleGroups = groupings;
      this.$.picker.style.display = (groupings.length < 2) ? 'none' : 'block';
      this.onGroupsChanged_();
    },

    set displayLabels(labels) {
      this.$.reference_display_label.style.display =
          (labels.length < 2) ? 'none' : 'inline';

      while (this.$.reference_display_label.children.length > 1) {
        this.$.reference_display_label.removeChild(
            this.$.reference_display_label.lastChild);
      }

      for (const displayLabel of labels) {
        const option = document.createElement('option');
        option.textContent = displayLabel;
        option.value = displayLabel;
        this.$.reference_display_label.appendChild(option);
      }

      if (labels.includes(this.viewState.referenceDisplayLabel)) {
        this.referenceDisplayLabel = this.viewState.referenceDisplayLabel;
      } else {
        this.viewState.referenceDisplayLabel = '';
      }
    },

    get baseStatisticNames() {
      return this.baseStatisticNames_;
    },

    set baseStatisticNames(names) {
      this.baseStatisticNames_ = names;
      this.statisticNames = names;
    },

    get statisticNames() {
      return Array.from(this.$.statistic.options).map(o => o.value);
    },

    set statisticNames(names) {
      this.$.statistic.style.display = (names.length < 2) ? 'none' : 'inline';

      while (this.$.statistic.children.length) {
        this.$.statistic.removeChild(this.$.statistic.lastChild);
      }

      for (const name of names) {
        const option = document.createElement('option');
        option.textContent = name;
        this.$.statistic.appendChild(option);
      }

      if (names.includes(this.viewState.displayStatisticName)) {
        this.displayStatisticName = this.viewState.displayStatisticName;
        // Polymer doesn't reset the value when the options change, so do that
        // manually.
        this.$.statistic.value = this.displayStatisticName;
      } else {
        this.viewState.displayStatisticName = names[0] || '';
      }
    },

    get anyOverviewCharts_() {
      for (const row of tr.v.ui.HistogramSetTableRowState.walkAll(
          this.viewState.tableRowStates.values())) {
        if (row.isOverviewed) return true;
      }
      return false;
    },

    async toggleOverviewLineCharts_() {
      const showOverviews = !this.anyOverviewCharts_;
      const mark = tr.b.Timing.mark('histogram-set-controls',
          (showOverviews ? 'show' : 'hide') + 'OverviewCharts');

      for (const row of tr.v.ui.HistogramSetTableRowState.walkAll(
          this.viewState.tableRowStates.values())) {
        await row.update({isOverviewed: showOverviews});
      }

      this.$.hide_overview.style.display = showOverviews ? 'inline' : 'none';
      this.$.show_overview.style.display = showOverviews ? 'none' : 'inline';

      await tr.b.animationFrame();
      mark.end();
    },

    set helpHref(href) {
      this.$.help.href = href;
      this.$.help.style.display = 'inline';
    },

    set feedbackHref(href) {
      this.$.feedback.href = href;
      this.$.feedback.style.display = 'inline';
    },

    showExportMenu_() {
      this.$.export_menu.style.visibility = 'visible';
      const rect = this.$.export.getBoundingClientRect();
      this.$.export_menu.style.left = rect.left + 'px';
      this.$.export_menu.focus();
    },

    hideExportMenu_() {
      this.$.export_menu.style.visibility = 'hidden';
    },

    toggleExportMenu_() {
      if (this.$.export_menu.style.visibility === 'visible') {
        this.hideExportMenu_();
      } else {
        this.showExportMenu_();
      }
    },

    getAlphaString_(alphaIndex) {
      // (9 * 1e-3).toString() is "0.009000000000000001", so truncate.
      return ('' + ALPHA_OPTIONS[alphaIndex]).substr(0, 5);
    },

    openAlphaSlider_() {
      const alphaButtonRect = this.$.alpha.getBoundingClientRect();
      this.$.alpha_slider_container.style.display = 'flex';
      this.$.alpha_slider_container.style.top = alphaButtonRect.bottom + 'px';
      this.$.alpha_slider_container.style.left = alphaButtonRect.left + 'px';
      this.$.alpha_slider.focus();
    },

    closeAlphaSlider_() {
      this.$.alpha_slider_container.style.display = '';
    },

    updateAlpha_() {
      this.alphaIndex = this.$.alpha_slider.value;
    },

    getAlphaIndexFromViewState_() {
      for (let i = 0; i < ALPHA_OPTIONS.length; ++i) {
        if (ALPHA_OPTIONS[i] >= this.viewState.alpha) return i;
      }
      return ALPHA_OPTIONS.length - 1;
    },
  });

  return {
  };
});
</script>
