<!DOCTYPE html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/timing.html">
<link rel="import" href="/tracing/value/histogram_grouping.html">
<link rel="import" href="/tracing/value/histogram_set.html">

<script>
'use strict';
tr.exportTo('tr.v', function() {
  const getDisplayLabel =
    tr.v.HistogramGrouping.DISPLAY_LABEL.callback;

  const DEFAULT_POSSIBLE_GROUPS = [];

  // Override HISTOGRAM_NAME so that we can display shortName.
  DEFAULT_POSSIBLE_GROUPS.push(new tr.v.HistogramGrouping(
      tr.v.HistogramGrouping.HISTOGRAM_NAME.key,
      h => h.shortName || h.name));

  const EXCLUDED_GROUPING_KEYS = [
    tr.v.HistogramGrouping.HISTOGRAM_NAME.key,
    tr.v.HistogramGrouping.DISPLAY_LABEL.key,
  ];
  // HISTOGRAM_NAME is overridden.
  // DISPLAY_LABEL is used to define the columns, so don't allow grouping rows
  // by it.
  for (const group of tr.v.HistogramGrouping.BY_KEY.values()) {
    if (EXCLUDED_GROUPING_KEYS.includes(group.key)) continue;
    DEFAULT_POSSIBLE_GROUPS.push(group);
  }

  // This Processor collects various parameters from a set of Histograms such as
  // their statistics, displayLabels, and grouping keys in a single pass.
  class HistogramSetSynopsis {
    constructor(histograms) {
      // Map from string HistogramGrouping key to array of values, sorted by
      // BENCHMARK_START in the case of displayLabel, alphabetically otherwise.
      this.groupValues_ = new Map();
      this.possibleGroupings_ = [];
      this.statisticNames_ = new Set(['avg']);

      const labelsToStartTimes = new Map();

      // Map from string HistogramGrouping key to HistogramGrouping.
      const keysToGroupings = new Map(DEFAULT_POSSIBLE_GROUPS.map(
          g => [g.key, g]));

      // Map from string HistogramGrouping keys to Sets of return values from
      // the HistogramGroupings' callbacks.
      const keysToValueSets = new Map(DEFAULT_POSSIBLE_GROUPS.map(
          g => [g.key, new Set()]));

      const allStoryTags = new Set();
      let maxSampleCount = 0;
      for (const hist of histograms) {
        maxSampleCount = Math.max(maxSampleCount, hist.numValues);

        for (const statName of hist.statisticsNames) {
          this.statisticNames_.add(statName);
        }

        let startTime = hist.diagnostics.get(
            tr.v.d.RESERVED_NAMES.BENCHMARK_START);
        if (startTime !== undefined) startTime = startTime.minDate.getTime();

        const displayLabel = getDisplayLabel(hist);

        if (labelsToStartTimes.has(displayLabel)) {
          startTime = Math.min(startTime,
              labelsToStartTimes.get(displayLabel));
        }
        labelsToStartTimes.set(displayLabel, startTime);

        for (const [groupingKey, values] of keysToValueSets) {
          const grouping = keysToGroupings.get(groupingKey);
          const value = grouping.callback(hist);
          if (!value) continue;
          values.add(value);
        }

        const storyTags = hist.diagnostics.get(
            tr.v.d.RESERVED_NAMES.STORY_TAGS);
        for (const tag of (storyTags || [])) {
          allStoryTags.add(tag);
        }
      }
      tr.b.Timing.instant(
          'HistogramParameterCollector', 'maxSampleCount', maxSampleCount);

      for (const tagGrouping of tr.v.HistogramGrouping.buildFromTags(
          allStoryTags, tr.v.d.RESERVED_NAMES.STORY_TAGS)) {
        const values = new Set();
        for (const hist of histograms) {
          values.add(tagGrouping.callback(hist));
        }
        if (values.size > 1) {
          keysToGroupings.set(tagGrouping.key, tagGrouping);
          keysToValueSets.set(tagGrouping.key, values);
        }
      }

      /*
      const displayLabels = Array.from(labelsToStartTimes.keys());
      displayLabels.sort((x, y) =>
          labelsToStartTimes.get(x) - labelsToStartTimes.get(y));

      return Array.from(keysToGroupings.values());
      */

      this.possibleGroupings_.sort();
    }

    get possibleGroupings() {
      return this.possibleGroupings_;
    }

    getGroupValues(groupingKey) {
      return this.groupValues_.get(groupingKey);
    }

    get statisticNames() {
      return Array.from(this.statisticNames_);
    }
  }

  return {
    HistogramSetSynopsis,
  };
});
</script>
