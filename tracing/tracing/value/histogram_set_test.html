<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/math/range.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/value/diagnostics/diagnostic_map.html">
<link rel="import" href="/tracing/value/diagnostics/generic_set.html">
<link rel="import" href="/tracing/value/histogram.html">
<link rel="import" href="/tracing/value/histogram_set.html">

<script>
'use strict';
tr.b.unittest.testSuite(function() {
  // TODO(#3812) Test groupHistogramsRecursively.

  test('importDicts', function() {
    const n = new tr.v.Histogram('foo', tr.b.Unit.byName.unitlessNumber);
    const histograms = new tr.v.HistogramSet([n]);
    const histograms2 = new tr.v.HistogramSet();
    histograms2.importDicts(histograms.asDict());
    assert.isDefined(histograms2.getHistogramNamed('foo'));
  });

  test('importDictsWithSampleDiagnostic', function() {
    const n = new tr.v.Histogram('foo', tr.b.Unit.byName.count);
    n.addSample(10, {bar: new tr.v.d.GenericSet(['baz'])});

    const histograms = new tr.v.HistogramSet([n]);
    const histograms2 = new tr.v.HistogramSet();
    histograms2.importDicts(histograms.asDict());
    assert.isDefined(histograms2.getHistogramNamed('foo'));
    const v = histograms2.getHistogramNamed('foo');
    assert.lengthOf(v.getBinForValue(10).diagnosticMaps, 1);
    const dm = v.getBinForValue(10).diagnosticMaps[0];
    assert.strictEqual(dm.size, 1);
    assert.instanceOf(dm.get('bar'), tr.v.d.GenericSet);
    assert.strictEqual(tr.b.getOnlyElement(dm.get('bar')), 'baz');
  });

  test('relatedHistogramMapDiagnostic', function() {
    const unit = tr.b.Unit.byName.unitlessNumber;
    const a = new tr.v.Histogram('a', unit);
    const b = new tr.v.Histogram('b', unit);
    const c = new tr.v.Histogram('c', unit);
    const rvm = new tr.v.d.RelatedHistogramMap();
    rvm.set('y', b);
    rvm.set('z', c);
    a.diagnostics.set('rvm', rvm);

    // Don't serialize c just yet.
    const histograms = new tr.v.HistogramSet([a, b]);

    const sourceHistograms = histograms.sourceHistograms;
    assert.strictEqual(tr.b.getOnlyElement(sourceHistograms), a);

    const histograms2 = new tr.v.HistogramSet();
    histograms2.importDicts(histograms.asDict());
    histograms2.resolveRelatedHistograms();

    const a2 = histograms2.getHistogramNamed('a');
    assert.isDefined(a2);
    assert.strictEqual(a2.guid, a.guid);
    assert.instanceOf(a2, tr.v.Histogram);
    assert.notStrictEqual(a2, a);

    const b2 = histograms2.getHistogramNamed('b');
    assert.isDefined(b2);
    assert.strictEqual(b2.guid, b.guid);
    assert.instanceOf(b2, tr.v.Histogram);
    assert.notStrictEqual(b2, b);

    const rvm2 = a2.diagnostics.get('rvm');
    assert.instanceOf(rvm2, tr.v.d.RelatedHistogramMap);
    assert.lengthOf(rvm2, 2);

    // Assert that b and c are in a2's RelatedHistogramMap.
    // |c| should still be a HistogramRef since it wasn't in histograms2.
    assert.strictEqual(rvm2.get('y'), b2);
    assert.instanceOf(rvm2.get('z'), tr.v.d.HistogramRef);

    // Now serialize c and add it to histograms2.
    // Related Histogram resolution is idempotent.
    // Old histograms can refer to new histograms.
    histograms2.importDicts(new tr.v.HistogramSet([c]).asDict());
    histograms2.resolveRelatedHistograms();

    const c2 = histograms2.getHistogramNamed('c');
    assert.isDefined(c2);
    assert.strictEqual(c2.guid, c.guid);
    assert.instanceOf(c2, tr.v.Histogram);
    assert.notStrictEqual(c2, c);

    // b2 should still be in a2's RelatedHistogramMap.
    assert.strictEqual(rvm2.get('y'), b2);

    // Now a real c2 Histogram should be in a2's RelatedHistogramMap.
    assert.strictEqual(rvm2.get('z'), c2);
  });

  test('sourceHistogramsWithSampleDiagnostic', function() {
    const unit = tr.b.Unit.byName.unitlessNumber;
    const aHist = new tr.v.Histogram('a', unit);
    aHist.addSample(1);

    const bHist = new tr.v.Histogram('b', tr.b.Unit.byName.unitlessNumber);
    const related = new tr.v.d.RelatedHistogramMap();
    related.set('0', aHist);
    bHist.addSample(1, {related});

    const histograms = new tr.v.HistogramSet([aHist, bHist]);
    assert.strictEqual(tr.b.getOnlyElement(histograms.sourceHistograms), bHist);
  });

  test('sourceHistogramsWithNameMap', function() {
    const unit = tr.b.Unit.byName.unitlessNumber;
    const histograms = new tr.v.HistogramSet();
    histograms.createHistogram('A', unit, []);
    const bHist = histograms.createHistogram('B', unit, [], {diagnostics: {
      related: tr.v.d.RelatedNameMap.fromEntries([['a', 'A']]),
    }});
    assert.strictEqual(tr.b.getOnlyElement(histograms.sourceHistograms), bHist);
  });

  test('getHistogramNamed_noHistogramFound', function() {
    const aHist = new tr.v.Histogram('aHist', tr.b.Unit.byName.count);
    const histograms = new tr.v.HistogramSet([aHist]);

    assert.isUndefined(histograms.getHistogramNamed('bHist'));
  });

  test('getHistogramNamed_oneHistogramFound', function() {
    const aHist = new tr.v.Histogram('aHist', tr.b.Unit.byName.count);
    const histograms = new tr.v.HistogramSet([aHist]);

    assert.strictEqual(histograms.getHistogramNamed('aHist'), aHist);
  });

  test('getHistogramNamed_multipleHistogramsFound', function() {
    const aHist1 = new tr.v.Histogram('aHist', tr.b.Unit.byName.count);
    const aHist2 = new tr.v.Histogram('aHist', tr.b.Unit.byName.count);
    const histograms = new tr.v.HistogramSet([aHist1, aHist2]);

    assert.throws(() => histograms.getHistogramNamed('aHist'),
        Error, 'Unexpectedly found multiple histograms named "aHist"');
  });

  test('buildGroupingsFromTags', function() {
    const histograms = new tr.v.HistogramSet();
    const aHist = histograms.createHistogram('', tr.b.Unit.byName.count, [], {
      diagnostics: new Map([
        [tr.v.d.RESERVED_NAMES.STORY_TAGS, new tr.v.d.GenericSet(['a'])],
      ]),
    });
    const bHist = histograms.createHistogram('', tr.b.Unit.byName.count, [], {
      diagnostics: new Map([
        [tr.v.d.RESERVED_NAMES.STORY_TAGS, new tr.v.d.GenericSet(['b'])],
      ]),
    });
    const groupings = histograms.buildGroupingsFromTags([
      tr.v.d.RESERVED_NAMES.STORY_TAGS]);
    assert.lengthOf(groupings, 2);
    assert.strictEqual(groupings[0].callback(aHist), 'a');
    assert.strictEqual(groupings[0].callback(bHist), '~a');
    assert.strictEqual(groupings[1].callback(aHist), '~b');
    assert.strictEqual(groupings[1].callback(bHist), 'b');
  });
});
</script>
