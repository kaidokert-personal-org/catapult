<!DOCTYPE html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/value/diagnostics/diagnostic.html">

<script>
'use strict';

tr.exportTo('tr.v.d', function() {
  class UnmergeableDiagnosticSet extends tr.v.d.Diagnostic {
    /**
     * @param {!Array.<!tr.v.d.Diagnostic>} diagnostics
     */
    constructor(diagnostics) {
      super();
      this.diagnostics_ = diagnostics;
    }

    clone() {
      const clone = new tr.v.d.UnmergeableDiagnosticSet();
      clone.addDiagnostic(this);
      return clone;
    }

    equals(other) {
      if (this.length !== other.length) return false;
      for (const d of this) {
        if (!other.diagnostics_.includes(d)) return false;
      }
      return true;
    }

    canAddDiagnostic(otherDiagnostic) {
      return true;
    }

    /**
     * If |otherDiagnostic| is an UnmergeableDiagnosticSet, then add clones of
     * its diagnostics to |this|. Otherwise, try to add |otherDiagnostic| to one
     * of the diagnostics already in this set. If that fails, add a clone of
     * |otherDiagnostic| to this set.
     *
     * @param {!tr.v.d.Diagnostic} otherDiagnostic
     * @return {!tr.v.d.UnmergeableDiagnostic} this
     */
    addDiagnostic(otherDiagnostic) {
      if (otherDiagnostic instanceof UnmergeableDiagnosticSet) {
        for (const subOtherDiagnostic of otherDiagnostic) {
          const clone = subOtherDiagnostic.clone();
          this.addDiagnostic(clone);
        }
        return;
      }

      for (let i = 0; i < this.diagnostics_.length; ++i) {
        if (this.diagnostics_[i].canAddDiagnostic(otherDiagnostic)) {
          this.diagnostics_[i].addDiagnostic(otherDiagnostic);
          return;
        }
      }

      const clone = otherDiagnostic.clone();
      this.diagnostics_.push(clone);
    }

    mergeRelationships(otherDiagnostic, parentHist, otherParentHist) {
      if (otherDiagnostic instanceof UnmergeableDiagnosticSet) {
        for (const subDiagnostic of otherDiagnostic) {
          this.mergeRelationships(subDiagnostic, parentHist, otherParentHist);
        }
        return;
      }
      for (const subDiagnostic of this) {
        if (!(subDiagnostic instanceof tr.v.d.RelatedHistogramMap) &&
            !(subDiagnostic instanceof tr.v.d.RelatedHistogramBreakdown)) {
          continue;
        }
        subDiagnostic.mergeRelationships(
            otherDiagnostic, parentHist, otherParentHist);
      }
    }

    get length() {
      return this.diagnostics_.length;
    }

    * [Symbol.iterator]() {
      for (const diagnostic of this.diagnostics_) yield diagnostic;
    }

    asDict(serializer) {
      return this.diagnostics_.map(d => serializer.getDiagnosticId('', d));
    }

    static fromDict(d, deserializer) {
      if (deserializer) {
        return new UnmergeableDiagnosticSet(d.map(i =>
          deserializer.getDiagnosticById(i).diagnostic));
      }
      return new UnmergeableDiagnosticSet(d.diagnostics.map(
          d => ((typeof d === 'string') ?
            new tr.v.d.DiagnosticRef(d) : tr.v.d.Diagnostic.fromDict(d))));
    }
  }

  tr.v.d.Diagnostic.register(UnmergeableDiagnosticSet, {
    elementName: 'tr-v-ui-unmergeable-diagnostic-set-span'
  });

  return {
    UnmergeableDiagnosticSet,
  };
});
</script>
