import httplib2
import json
import logging
import oauth2client.client
import oauth2client.file
from oauth2client import service_account  # pylint: disable=no-name-in-module
import oauth2client.tools
import os
import time
import urllib


class PerfDashboardCommunicator(object):

  REQUEST_URL = 'https://chromeperf.appspot.com/api/'
  OAUTH_CLIENT_ID = (
      '62121018386-h08uiaftreu4dr3c4alh3l7mogskvb7i.apps.googleusercontent.com')
  OAUTH_CLIENT_SECRET = 'vc1fZfV1cZC6mgDSHV-KSPOz'
  SCOPES = ['https://www.googleapis.com/auth/userinfo.email']

  def __init__(self, flags):
    self._credentials = None
    if flags.service_account_json:
      self._AuthorizeAccountServiceAccount(flags.service_account_json)
    else:
      self._AuthorizeAccountUserAccount(flags)

  @property
  def has_credentials(self):
    return self._credentials and not self._credentials.invalid

  def _AuthorizeAccountServiceAccount(self, json_keyfile):
    """Used to create service account credentials for the dashboard.

    Args:
      json_keyfile: Path to json file that contains credentials.
    """
    self._credentials = (
        service_account.ServiceAccountCredentials.from_json_keyfile_name(
            json_keyfile, self.SCOPES))

  def _AuthorizeAccountUserAccount(self, flags):
    """Used to create user account credentials for the performance dashboard.

    Args:
      flags: An argparse.Namespace as returned by argparser.parse_args; in
        addition to oauth2client.tools.argparser flags should also have set a
        user_credentials_json flag.
    """
    store = oauth2client.file.Storage(flags.user_credentials_json)
    if os.path.exists(flags.user_credentials_json):
      self._credentials = store.locked_get()
    if not self.has_credentials:
      flow = oauth2client.client.OAuth2WebServerFlow(
          self.OAUTH_CLIENT_ID, self.OAUTH_CLIENT_SECRET, self.SCOPES,
          prompt='consent')
      self._credentials = oauth2client.tools.run_flow(flow, store, flags)

  def _MakeApiRequest(self, request, retry=3, delay=3):
    """Used to communicate with perf dashboard.

    args:
      credentials: Set of credentials generated by
      request: String that contains POST request to dashboard.
    returns:
      Contents of the response from the dashboard.
    """
    assert self.has_credentials
    logging.info('Making API request: %s', request)
    connection = self._credentials.authorize(httplib2.Http())
    resp, content = connection.request(
        self.REQUEST_URL + request,
        method="POST",
        headers={'Content-length': 0})
    if resp['status'] != '200':
      print ('Response: %s\nContent: %s\nError detected while making api '
             'request. Returned: %s' % (resp, content, resp['status']))
      if retry:
        print ('Retrying command after %s seconds. %s retries left...'
               % (delay, retry - 1))
        time.sleep(delay)
        return self._MakeApiRequest(request, retry=retry-1, delay=delay*2)
    return  json.loads(content)

  def ListTestPaths(self, benchmark, sheriff=False):
    """Lists test paths for the given benchmark.

    args:
      benchmark: Benchmark to get paths for.
      sheriff:
          Filters test paths to only ones monitored by the given sheriff
          rotation.
    returns:
      A list of test paths. Ex. ['TestPath1', 'TestPath2']
    """
    r = 'list_timeseries/%s' % benchmark
    if sheriff:
      r += '?sheriff=%s' % sheriff
    return self._MakeApiRequest(r)

  def GetTimeseries(self, test_path, days=30):
    """Get timeseries for the given test path.

    args:
      test_path: test path to get timeseries for.
      days: Number of days to get data points for.
    returns:
      A dict in the format:
      {'revision_logs':{
          r_commit_pos: {... data ...},
          r_chromium_rev: {... data ...},
          ...},
       'timeseries': [
           [revision, value, timestamp, r_commit_pos, r_webkit_rev],
           ...
           ],
       'test_path': test_path}
    """
    options = urllib.urlencode({'num_days': days})
    r = 'timeseries/%s?%s' % (urllib.quote_plus(test_path), options)
    return self._MakeApiRequest(r)

  def GetBugData(self, bug_id):
    """Returns data on the given bug."""
    return self._MakeApiRequest('bugs/%d' % bug_id)

  def GetAlertData(self, benchmark, days=30):
    """Returns alerts for the given benchmark."""
    options = urllib.urlencode({'benchmark': benchmark})
    return self._MakeApiRequest('alerts/history/%d?%s' % (days, options))

  def GetAllTimeseriesForBenchmark(self, benchmark, days=30, filters=None):
    """ Generator function returning timeseries entries for a benchmark.

    args:
      benchmark: benchmark you want data for.
      days: number of days to return data for.
      filter: A list of strings. The metric must contain all of the strings

    yields:
      Timeseries data point.
    """
    header = ['bot', 'benchmark', 'metric', 'story']
    test_paths = self.ListTestPaths(benchmark)
    for tp in test_paths:
      if not filters or all(f in tp for f in filters):
        ts = self.GetTimeseries(tp, days=days)
        if header:
          # First entry in the timeseries is a header. We only need this once.
          full_header = header + ts['timeseries'][0]
          header = None
          yield full_header
        for point in ts['timeseries'][1:]:
          # Splits the test path into [bot, benchmark, metric, story] and
          # appends the data from a timeseries entry. Current data returned:
          # 'revision', 'value', 'timestamp', 'r_commit_pos', 'r_webrtc_rev',
          # 'r_chromium', 'r_webkit_rev', 'r_v8_rev'
          test_data = tp.split('/', 4)[1:] + [data for data in point]
          yield test_data
