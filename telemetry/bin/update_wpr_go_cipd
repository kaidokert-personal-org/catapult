#!/usr/bin/env python
# Copyright (c) 2017 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Downloads wpr_go binaries from GCS and update CIPD.
import os
import shutil
import sys
import subprocess
import tempfile
import platform

TELEMETRY_DIR = os.path.join(os.path.abspath(os.path.dirname(__file__)), '..')
sys.path.insert(1, TELEMETRY_DIR)
from telemetry.core import util
from telemetry.core import platform as platform_module
from telemetry.internal.util import binary_manager

import py_utils


# TODO(nedn): support building other architectures & OSes.
_SUPPORTED_PLATFORMS = (
  ('win', 'x86'),
  ('mac', 'x86_64'),
  ('linux', 'x86_64'),
  ('win', 'AMD64'),
  ('linux', 'armv7l'),
  ('linux', 'aarch64'),
  ('linux', 'mips')
)

_SUPPORTED_CIPD_PLATFORMS = [
    'linux_x86_64'
]

_DEFAULT_YAML_TEMPLATE ="""
package: infra/tools/wpr/{plat}
description: wpr_go executeable on {plat}
install_mode: copy
data:
  - file: bin/{os_name}/{arch}/wpr
"""

class cipd_uploader(object):
  """Helper to upload wpr binaries to cipd."""
  def __init__(self):
    self._common_path = ''
    self._cipd_yaml_file_path = ''
    self._wpr_binaries = {}

  def register_wpr_binary(self, path):
    """Registers the wpr binary into dictionary."""
    path_segments = path.split('/')
    if self._common_path:
      assert(self._common_path == '/'.join(path_segments[:-4]))
    else:
      self._common_path = '/'.join(path_segments[:-4])
    related_path = '/'.join(path_segments[-4:0])
    os_arch = '/'.join(path_segments[-3:-2])
    self._wpr_binaries[os_arch] = related_path

  def update_to_cipd(self):
    """Updates the wpr binaries to cipd."""
    for platform in _SUPPORTED_CIPD_PLATFORMS:
      pkg_def_file = self._write_pkg_def_file(self._common_path, platform)
      self._update_cipd_with_pkg_def(pkg_def_file)
      os.remove(pkg_def_file)

  def _write_pkg_def_file(self, path, platform):
    """Creates a cipd pkg_def file in disk and returns path."""
    pkg_def_path = os.path.join(path, 'cipd.yaml')
    os_name = platform.split('_')[:1][0]
    arch = '_'.join(platform.split('_')[1:])
    with open(pkg_def_path, 'w') as pkg_def:
      pkg_def.write(_DEFAULT_YAML_TEMPLATE.format(
          plat=platform, os_name=os_name, arch=arch))
    print('Create CIPD pkg_def file %s', pkg_def_path)
    return pkg_def_path

  def _update_cipd_with_pkg_def(self, pkg_def):
    """Updates cipd with pkg_def."""
    upload_cmd = ['cipd', 'create', '-pkg-def=cipd.yaml']
    subprocess.check_call(upload_cmd, cwd=self._common_path)


def download_from_gcs_and_update_cipd():
  """Builds proper wpr_go binaries and update CIPD."""
  uploader = cipd_uploader()

  for os_name, arch_name in _SUPPORTED_PLATFORMS:
    print('Download WPR binary dependency for OS %s, ARCH: %s',
          os_name, arch_name)
    # Downloads wpr_binaries from GCS.
    if binary_manager.NeedsInit():
      binary_manager.InitDependencyManager(None)
    wpr_bin = binary_manager.FetchPath(
        'wpr_go', os_name=os_name, arch=arch_name)
    print('The downloaded binary is %s', wpr_bin)
    # Register each wpr_binary with uploader and then batch upload.
    uploader.register_wpr_binary(wpr_bin)
  uploader.update_to_cipd()


def main():
  download_from_gcs_and_update_cipd()


if __name__ == "__main__":
  sys.exit(main())
