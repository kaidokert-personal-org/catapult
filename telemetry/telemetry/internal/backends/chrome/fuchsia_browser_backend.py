# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import logging
from subprocess import PIPE

from telemetry.internal.backends.chrome import chrome_browser_backend


class FuchsiaBrowserBackend(chrome_browser_backend.ChromeBrowserBackend):
  def __init__(self,
               fuchsia_platform_backend,
               browser_options,
               browser_directory,
               profile_directory,
               is_guest):
    # Copied from CrOS. Currently, it is unknown whether Fuchsia will require
    # a custom BrowserOptions subclass. As such, no potentially fatal assertions
    # on the type of the browser options

    # assert browser_options.IsFuchsiaBrowserOptions()
    super(FuchsiaBrowserBackend, self).__init__(
        fuchsia_platform_backend,
        browser_options=browser_options,
        browser_directory=browser_directory,
        profile_directory=profile_directory,
        supports_extensions=not is_guest,
        supports_tab_control=True)
    self._is_guest = is_guest
    self._pid = None

  @property
  def log_file_path(self):
    return None

  @property
  def pid(self):
    return self._pid

  def _GetDevToolsActivePortPath(self):
    """This function needs to return a path on the target device to the magic
    file generated by DevTools which specifies the port that DevTools is
    listening for the host connection on.
    """
    # Currently, this path is an assumption based on the form of the CrOS path.
    return "/data/DevToolsActivePort"

  def _FindDevToolsPortAndTarget(self):
    devtools_file_path = self._GetDevToolsActivePortPath()
    # GetFileContents may rise IOError or OSError, the caller will retry.
    cat_command = ['cat', devtools_file_path]
    cat_proc = self._forwarder.device.RunCommandPiped(cat_command, stdout=PIPE)
    contents = cat_proc.communicate()[0] # We only care about stdout
    lines = contents.decode('utf-8').split('\n')
    if not lines:
      raise EnvironmentError('DevTools file empty')

    devtools_port = int(lines[0])
    browser_target = lines[1] if len(lines) >= 2 else None
    return devtools_port, browser_target

  def Start(self, startup_args, startup_url=None):
    assert not startup_url, 'startup_url not supported by fuchsia backend'

    # Remove the stale file with the devtools port / browser target
    # prior to restarting chrome.
    self.platform_backend.EnsureStart()
    self.platform_backend.DeletePath(self._GetDevToolsActivePortPath())

    try:
      self.BindDevToolsClient()
    except:
      self.Close()
      raise

    logging.info('Browser is up!')

  def Background(self):
    raise NotImplementedError()

  def Close(self):
    pass

  def GetStandardOutput(self):
    return 'Cannot get standard output on Fuchsia'

  def IsBrowserRunning(self):
    ps_proc = self.platform_backend.RunCommandPiped(['ps'])
    running_procs = ps_proc.communicate()[0] # Just get stdout
    # If an executable named content_shell is in the output of ps, we can
    # assume that's our browser
    return "content_shell" in running_procs.decode("utf-8")
