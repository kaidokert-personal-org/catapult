# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import logging
import os
from subprocess import Popen
import sys
from threading import Thread

from telemetry.internal.backends.chrome import chrome_browser_backend
from telemetry.internal.backends.chrome_inspector import devtools_client_backend
from telemetry.core.fuchsia_interface import CHROMIUM_SRC, OUT_DIR
from run_package import RunPackage


class FuchsiaBrowserBackend(chrome_browser_backend.ChromeBrowserBackend):
  def __init__(self,
               fuchsia_platform_backend,
               browser_options,
               browser_directory,
               profile_directory,
               is_guest):
    # Copied from CrOS. Currently, it is unknown whether Fuchsia will require
    # a custom BrowserOptions subclass. As such, no potentially fatal assertions
    # on the type of the browser options

    # assert browser_options.IsFuchsiaBrowserOptions()
    super(FuchsiaBrowserBackend, self).__init__(
        fuchsia_platform_backend,
        browser_options=browser_options,
        browser_directory=browser_directory,
        profile_directory=profile_directory,
        supports_extensions=not is_guest,
        supports_tab_control=True)
    self._is_guest = is_guest
    self._browser_handle = None

  @property
  def log_file_path(self):
    return None

  @property
  def pid(self):
    assert self._browser_handle, (
      "The browser doesn't exist, so cannot get its PID")
    return self._browser_handle.pid

  def _GetDevToolsActivePortPath(self):
    """This function needs to return a path on the target device to the magic
    file generated by DevTools which specifies the port that DevTools is
    listening for the host connection on.
    """
    # Currently, this path is an assumption based on the form of the CrOS path.
    return "/data/DevToolsActivePort"

  def _FindDevToolsPortAndTarget(self):
    devtools_file_path = self._GetDevToolsActivePortPath()
    lines = self.platform_backend.ReadFile(devtools_file_path).split('\n')
    if not lines or lines[0] == '':
      raise EnvironmentError('DevTools file empty')
    try:
      devtools_port = int(lines[0])
    except ValueError as v:
      err = "Failed to parse port number from %s because of %s" % (lines[0], v)
      raise EnvironmentError(err)
    browser_target = lines[1] if len(lines) >= 2 else None
    return devtools_port, browser_target

  def BindDevToolsClient(self):
    if self._devtools_client:
      self._devtools_client.Close()
      self._devtools_client = None
    self._devtools_client = devtools_client_backend.GetDevToolsBackEndIfReady(
      self.platform_backend.GetRemotePort(), self, None)

  def Start(self, startup_args, startup_url=None):
    assert not startup_url, 'startup_url not supported by fuchsia backend'

    # Remove the stale file with the devtools port / browser target
    # prior to restarting chrome.
    self.platform_backend.EnsureStart()

    runner_path = os.path.join(CHROMIUM_SRC, 'build/fuchsia/exe_runner.py')
    gen_root = os.path.join(OUT_DIR, 'gen/content/shell/content_shell')
    bin_path = os.path.join(gen_root, 'content_shell.far')
    manifest_path = os.path.join(gen_root, 'content_shell.archive_manifest')
    runner_args = [
      '--target-cpu', 'x64',
      '--package-name', 'content_shell',
      '--output-directory', OUT_DIR,
      '--package', bin_path,
      '--package-manifest', manifest_path,
      '--host', self.platform_backend._fi.hostname
    ] + ['--child_args'] + startup_args

    self._browser_handle = Popen([runner_path] + runner_args)

    try:
      self.BindDevToolsClient()
    except:
      self.Close()
      raise

    logging.info('Browser is up!')

  def Background(self):
    raise NotImplementedError()

  def Close(self):
    assert self._browser_handle, "Cannot Close a browser that wasn't opened!"
    if self._browser_handle.poll() is None:
      self._browser_handle.kill()

  def GetStandardOutput(self):
    return 'Cannot get standard output on Fuchsia'

  def IsBrowserRunning(self):
    if self._browser_handle:
      return True
    return False

  def GetStackTrace(self):
    assert self._browser_handle, ("Can't get a stack trace until the browser is"
                                  " started at least once!")
    out, err = self._browser_handle.communicate()
    return True, "Out:\n%s\nErr:\n%s\n" % (out, err)